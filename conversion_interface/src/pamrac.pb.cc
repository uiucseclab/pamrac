// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pamrac.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "pamrac.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace pamrac {

namespace {

const ::google::protobuf::Descriptor* PAMRACMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PAMRACMessage_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PAMRACMessage_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* NonceResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NonceResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlobFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlobFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* InnerBlob_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InnerBlob_reflection_ = NULL;
const ::google::protobuf::Descriptor* InnerBlob_KeyValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InnerBlob_KeyValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* MasterKeyPasswordedFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterKeyPasswordedFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* InnerPassworded_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InnerPassworded_reflection_ = NULL;
const ::google::protobuf::Descriptor* MasterKeyRetrievableFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterKeyRetrievableFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* InnerRetrievable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InnerRetrievable_reflection_ = NULL;
const ::google::protobuf::Descriptor* InitBlobRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InitBlobRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* InitBlobResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InitBlobResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlobRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlobRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlobRequest_BlobHash_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlobRequest_BlobHash_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlobResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlobResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlobUpload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlobUpload_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlobUploadResult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlobUploadResult_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareListRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareListRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareList_ShareRecipient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareList_ShareRecipient_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareID_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyShare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyShare_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareUpload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareUpload_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareUploadResult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareUploadResult_reflection_ = NULL;
const ::google::protobuf::Descriptor* FriendNameMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FriendNameMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* FriendNameMap_FriendNickname_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FriendNameMap_FriendNickname_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_pamrac_2eproto() {
  protobuf_AddDesc_pamrac_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "pamrac.proto");
  GOOGLE_CHECK(file != NULL);
  PAMRACMessage_descriptor_ = file->message_type(0);
  static const int PAMRACMessage_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, user_fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, init_blob_request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, init_blob_response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, blob_request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, blob_response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, blob_upload_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, blob_upload_result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, nonce_response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, share_upload_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, share_upload_result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, share_request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, key_share_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, share_list_request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, share_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, client_pubkey_),
  };
  PAMRACMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PAMRACMessage_descriptor_,
      PAMRACMessage::default_instance_,
      PAMRACMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PAMRACMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PAMRACMessage));
  PAMRACMessage_Type_descriptor_ = PAMRACMessage_descriptor_->enum_type(0);
  NonceResponse_descriptor_ = file->message_type(1);
  static const int NonceResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NonceResponse, nonce_),
  };
  NonceResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NonceResponse_descriptor_,
      NonceResponse::default_instance_,
      NonceResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NonceResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NonceResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NonceResponse));
  BlobFile_descriptor_ = file->message_type(2);
  static const int BlobFile_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobFile, salt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobFile, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobFile, aes_init_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobFile, inner_blob_ciphertext_),
  };
  BlobFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlobFile_descriptor_,
      BlobFile::default_instance_,
      BlobFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlobFile));
  InnerBlob_descriptor_ = file->message_type(3);
  static const int InnerBlob_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob, fields_),
  };
  InnerBlob_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InnerBlob_descriptor_,
      InnerBlob::default_instance_,
      InnerBlob_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InnerBlob));
  InnerBlob_KeyValue_descriptor_ = InnerBlob_descriptor_->nested_type(0);
  static const int InnerBlob_KeyValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob_KeyValue, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob_KeyValue, value_),
  };
  InnerBlob_KeyValue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InnerBlob_KeyValue_descriptor_,
      InnerBlob_KeyValue::default_instance_,
      InnerBlob_KeyValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob_KeyValue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerBlob_KeyValue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InnerBlob_KeyValue));
  MasterKeyPasswordedFile_descriptor_ = file->message_type(4);
  static const int MasterKeyPasswordedFile_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyPasswordedFile, salt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyPasswordedFile, aes_init_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyPasswordedFile, inner_ciphertext_),
  };
  MasterKeyPasswordedFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MasterKeyPasswordedFile_descriptor_,
      MasterKeyPasswordedFile::default_instance_,
      MasterKeyPasswordedFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyPasswordedFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyPasswordedFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MasterKeyPasswordedFile));
  InnerPassworded_descriptor_ = file->message_type(5);
  static const int InnerPassworded_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, master_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, filenamesalt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, site_names_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, downloadsecret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, private_key_),
  };
  InnerPassworded_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InnerPassworded_descriptor_,
      InnerPassworded::default_instance_,
      InnerPassworded_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerPassworded, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InnerPassworded));
  MasterKeyRetrievableFile_descriptor_ = file->message_type(6);
  static const int MasterKeyRetrievableFile_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyRetrievableFile, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyRetrievableFile, aes_init_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyRetrievableFile, inner_retrievable_ciphertext_),
  };
  MasterKeyRetrievableFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MasterKeyRetrievableFile_descriptor_,
      MasterKeyRetrievableFile::default_instance_,
      MasterKeyRetrievableFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyRetrievableFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterKeyRetrievableFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MasterKeyRetrievableFile));
  InnerRetrievable_descriptor_ = file->message_type(7);
  static const int InnerRetrievable_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerRetrievable, master_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerRetrievable, downloadsecret_),
  };
  InnerRetrievable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InnerRetrievable_descriptor_,
      InnerRetrievable::default_instance_,
      InnerRetrievable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerRetrievable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InnerRetrievable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InnerRetrievable));
  InitBlobRequest_descriptor_ = file->message_type(8);
  static const int InitBlobRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobRequest, all_hash_xor_),
  };
  InitBlobRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InitBlobRequest_descriptor_,
      InitBlobRequest::default_instance_,
      InitBlobRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InitBlobRequest));
  InitBlobResponse_descriptor_ = file->message_type(9);
  static const int InitBlobResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobResponse, xor_matches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobResponse, nonce_),
  };
  InitBlobResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InitBlobResponse_descriptor_,
      InitBlobResponse::default_instance_,
      InitBlobResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitBlobResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InitBlobResponse));
  BlobRequest_descriptor_ = file->message_type(10);
  static const int BlobRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest, cached_blobs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest, downloadsecret_proof_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest, proof_nonce_),
  };
  BlobRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlobRequest_descriptor_,
      BlobRequest::default_instance_,
      BlobRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlobRequest));
  BlobRequest_BlobHash_descriptor_ = BlobRequest_descriptor_->nested_type(0);
  static const int BlobRequest_BlobHash_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest_BlobHash, blob_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest_BlobHash, blob_hash_),
  };
  BlobRequest_BlobHash_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlobRequest_BlobHash_descriptor_,
      BlobRequest_BlobHash::default_instance_,
      BlobRequest_BlobHash_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest_BlobHash, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobRequest_BlobHash, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlobRequest_BlobHash));
  BlobResponse_descriptor_ = file->message_type(11);
  static const int BlobResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobResponse, new_blobs_),
  };
  BlobResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlobResponse_descriptor_,
      BlobResponse::default_instance_,
      BlobResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlobResponse));
  BlobUpload_descriptor_ = file->message_type(12);
  static const int BlobUpload_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUpload, hashed_filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUpload, blob_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUpload, nonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUpload, signature_),
  };
  BlobUpload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlobUpload_descriptor_,
      BlobUpload::default_instance_,
      BlobUpload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUpload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUpload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlobUpload));
  BlobUploadResult_descriptor_ = file->message_type(13);
  static const int BlobUploadResult_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUploadResult, verification_ok_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUploadResult, upload_successful_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUploadResult, server_version_),
  };
  BlobUploadResult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlobUploadResult_descriptor_,
      BlobUploadResult::default_instance_,
      BlobUploadResult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUploadResult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlobUploadResult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlobUploadResult));
  ShareListRequest_descriptor_ = file->message_type(14);
  static const int ShareListRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareListRequest, requester_fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareListRequest, nonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareListRequest, signature_),
  };
  ShareListRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareListRequest_descriptor_,
      ShareListRequest::default_instance_,
      ShareListRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareListRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareListRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareListRequest));
  ShareList_descriptor_ = file->message_type(15);
  static const int ShareList_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList, threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList, recipients_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList, signature_),
  };
  ShareList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareList_descriptor_,
      ShareList::default_instance_,
      ShareList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareList));
  ShareList_ShareRecipient_descriptor_ = ShareList_descriptor_->nested_type(0);
  static const int ShareList_ShareRecipient_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList_ShareRecipient, nickname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList_ShareRecipient, fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList_ShareRecipient, initiator_),
  };
  ShareList_ShareRecipient_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareList_ShareRecipient_descriptor_,
      ShareList_ShareRecipient::default_instance_,
      ShareList_ShareRecipient_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList_ShareRecipient, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareList_ShareRecipient, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareList_ShareRecipient));
  ShareID_descriptor_ = file->message_type(16);
  static const int ShareID_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareID, originator_fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareID, owner_fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareID, encrypted_to_fingerprint_),
  };
  ShareID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareID_descriptor_,
      ShareID::default_instance_,
      ShareID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareID));
  ShareRequest_descriptor_ = file->message_type(17);
  static const int ShareRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareRequest, share_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareRequest, nonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareRequest, signature_),
  };
  ShareRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareRequest_descriptor_,
      ShareRequest::default_instance_,
      ShareRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareRequest));
  KeyShare_descriptor_ = file->message_type(18);
  static const int KeyShare_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, masterkey_retrievable_file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, encrypted_initiator_mask_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, encrypted_share_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, share_id_),
  };
  KeyShare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyShare_descriptor_,
      KeyShare::default_instance_,
      KeyShare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyShare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyShare));
  ShareUpload_descriptor_ = file->message_type(19);
  static const int ShareUpload_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, revoke_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, share_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, nonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, signature_),
  };
  ShareUpload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareUpload_descriptor_,
      ShareUpload::default_instance_,
      ShareUpload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUpload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareUpload));
  ShareUploadResult_descriptor_ = file->message_type(20);
  static const int ShareUploadResult_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUploadResult, verification_ok_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUploadResult, ids_revoked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUploadResult, shares_added_),
  };
  ShareUploadResult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareUploadResult_descriptor_,
      ShareUploadResult::default_instance_,
      ShareUploadResult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUploadResult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareUploadResult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareUploadResult));
  FriendNameMap_descriptor_ = file->message_type(21);
  static const int FriendNameMap_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap, friends_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap, signature_),
  };
  FriendNameMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FriendNameMap_descriptor_,
      FriendNameMap::default_instance_,
      FriendNameMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FriendNameMap));
  FriendNameMap_FriendNickname_descriptor_ = FriendNameMap_descriptor_->nested_type(0);
  static const int FriendNameMap_FriendNickname_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap_FriendNickname, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap_FriendNickname, friend_fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap_FriendNickname, server_address_),
  };
  FriendNameMap_FriendNickname_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FriendNameMap_FriendNickname_descriptor_,
      FriendNameMap_FriendNickname::default_instance_,
      FriendNameMap_FriendNickname_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap_FriendNickname, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FriendNameMap_FriendNickname, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FriendNameMap_FriendNickname));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_pamrac_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PAMRACMessage_descriptor_, &PAMRACMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NonceResponse_descriptor_, &NonceResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlobFile_descriptor_, &BlobFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InnerBlob_descriptor_, &InnerBlob::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InnerBlob_KeyValue_descriptor_, &InnerBlob_KeyValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MasterKeyPasswordedFile_descriptor_, &MasterKeyPasswordedFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InnerPassworded_descriptor_, &InnerPassworded::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MasterKeyRetrievableFile_descriptor_, &MasterKeyRetrievableFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InnerRetrievable_descriptor_, &InnerRetrievable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InitBlobRequest_descriptor_, &InitBlobRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InitBlobResponse_descriptor_, &InitBlobResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlobRequest_descriptor_, &BlobRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlobRequest_BlobHash_descriptor_, &BlobRequest_BlobHash::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlobResponse_descriptor_, &BlobResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlobUpload_descriptor_, &BlobUpload::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlobUploadResult_descriptor_, &BlobUploadResult::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareListRequest_descriptor_, &ShareListRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareList_descriptor_, &ShareList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareList_ShareRecipient_descriptor_, &ShareList_ShareRecipient::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareID_descriptor_, &ShareID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareRequest_descriptor_, &ShareRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyShare_descriptor_, &KeyShare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareUpload_descriptor_, &ShareUpload::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareUploadResult_descriptor_, &ShareUploadResult::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FriendNameMap_descriptor_, &FriendNameMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FriendNameMap_FriendNickname_descriptor_, &FriendNameMap_FriendNickname::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_pamrac_2eproto() {
  delete PAMRACMessage::default_instance_;
  delete PAMRACMessage_reflection_;
  delete NonceResponse::default_instance_;
  delete NonceResponse_reflection_;
  delete BlobFile::default_instance_;
  delete BlobFile_reflection_;
  delete InnerBlob::default_instance_;
  delete InnerBlob_reflection_;
  delete InnerBlob_KeyValue::default_instance_;
  delete InnerBlob_KeyValue_reflection_;
  delete MasterKeyPasswordedFile::default_instance_;
  delete MasterKeyPasswordedFile_reflection_;
  delete InnerPassworded::default_instance_;
  delete InnerPassworded_reflection_;
  delete MasterKeyRetrievableFile::default_instance_;
  delete MasterKeyRetrievableFile_reflection_;
  delete InnerRetrievable::default_instance_;
  delete InnerRetrievable_reflection_;
  delete InitBlobRequest::default_instance_;
  delete InitBlobRequest_reflection_;
  delete InitBlobResponse::default_instance_;
  delete InitBlobResponse_reflection_;
  delete BlobRequest::default_instance_;
  delete BlobRequest_reflection_;
  delete BlobRequest_BlobHash::default_instance_;
  delete BlobRequest_BlobHash_reflection_;
  delete BlobResponse::default_instance_;
  delete BlobResponse_reflection_;
  delete BlobUpload::default_instance_;
  delete BlobUpload_reflection_;
  delete BlobUploadResult::default_instance_;
  delete BlobUploadResult_reflection_;
  delete ShareListRequest::default_instance_;
  delete ShareListRequest_reflection_;
  delete ShareList::default_instance_;
  delete ShareList_reflection_;
  delete ShareList_ShareRecipient::default_instance_;
  delete ShareList_ShareRecipient_reflection_;
  delete ShareID::default_instance_;
  delete ShareID_reflection_;
  delete ShareRequest::default_instance_;
  delete ShareRequest_reflection_;
  delete KeyShare::default_instance_;
  delete KeyShare_reflection_;
  delete ShareUpload::default_instance_;
  delete ShareUpload_reflection_;
  delete ShareUploadResult::default_instance_;
  delete ShareUploadResult_reflection_;
  delete FriendNameMap::default_instance_;
  delete FriendNameMap_reflection_;
  delete FriendNameMap_FriendNickname::default_instance_;
  delete FriendNameMap_FriendNickname_reflection_;
}

void protobuf_AddDesc_pamrac_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014pamrac.proto\022\006pamrac\"\243\t\n\rPAMRACMessage"
    "\022\030\n\020user_fingerprint\030\001 \001(\014\022(\n\004type\030\002 \002(\016"
    "2\032.pamrac.PAMRACMessage.Type\0222\n\021init_blo"
    "b_request\030\003 \001(\0132\027.pamrac.InitBlobRequest"
    "\0224\n\022init_blob_response\030\004 \001(\0132\030.pamrac.In"
    "itBlobResponse\022)\n\014blob_request\030\005 \001(\0132\023.p"
    "amrac.BlobRequest\022+\n\rblob_response\030\006 \001(\013"
    "2\024.pamrac.BlobResponse\022\'\n\013blob_upload\030\007 "
    "\001(\0132\022.pamrac.BlobUpload\0224\n\022blob_upload_r"
    "esult\030\010 \001(\0132\030.pamrac.BlobUploadResult\022-\n"
    "\016nonce_response\030\t \001(\0132\025.pamrac.NonceResp"
    "onse\022)\n\014share_upload\030\n \001(\0132\023.pamrac.Shar"
    "eUpload\0226\n\023share_upload_result\030\013 \001(\0132\031.p"
    "amrac.ShareUploadResult\022+\n\rshare_request"
    "\030\014 \001(\0132\024.pamrac.ShareRequest\022#\n\tkey_shar"
    "e\030\r \001(\0132\020.pamrac.KeyShare\0224\n\022share_list_"
    "request\030\016 \001(\0132\030.pamrac.ShareListRequest\022"
    "%\n\nshare_list\030\017 \001(\0132\021.pamrac.ShareList\022\025"
    "\n\rclient_pubkey\030\020 \001(\014\"\324\003\n\004Type\022\025\n\021INIT_B"
    "LOB_REQUEST\020\000\022\026\n\022INIT_BLOB_RESPONSE\020\001\022\020\n"
    "\014BLOB_REQUEST\020\002\022\021\n\rBLOB_RESPONSE\020\003\022\024\n\020IN"
    "IT_BLOB_UPLOAD\020\004\022\025\n\021BLOB_UPLOAD_NONCE\020\005\022"
    "\017\n\013BLOB_UPLOAD\020\006\022\026\n\022BLOB_UPLOAD_RESULT\020\007"
    "\022\025\n\021INIT_SHARE_UPLOAD\020\010\022\026\n\022SHARE_UPLOAD_"
    "NONCE\020\t\022\020\n\014SHARE_UPLOAD\020\n\022\027\n\023SHARE_UPLOA"
    "D_RESULT\020\013\022\026\n\022INIT_SHARE_REQUEST\020\014\022\027\n\023SH"
    "ARE_REQUEST_NONCE\020\r\022\021\n\rSHARE_REQUEST\020\016\022\r"
    "\n\tKEY_SHARE\020\017\022\033\n\027INIT_SHARE_LIST_REQUEST"
    "\020\020\022\034\n\030SHARE_LIST_REQUEST_NONCE\020\021\022\026\n\022SHAR"
    "E_LIST_REQUEST\020\022\022\016\n\nSHARE_LIST\020\023\022\022\n\016NOT_"
    "AUTHORIZED\020\024\"\036\n\rNonceResponse\022\r\n\005nonce\030\001"
    " \002(\014\"a\n\010BlobFile\022\014\n\004salt\030\001 \001(\014\022\017\n\007versio"
    "n\030\002 \002(\005\022\027\n\017aes_init_vector\030\003 \002(\014\022\035\n\025inne"
    "r_blob_ciphertext\030\004 \002(\014\"r\n\tInnerBlob\022\020\n\010"
    "filename\030\001 \002(\t\022*\n\006fields\030\002 \003(\0132\032.pamrac."
    "InnerBlob.KeyValue\032\'\n\010KeyValue\022\014\n\004name\030\001"
    " \002(\t\022\r\n\005value\030\002 \002(\t\"Z\n\027MasterKeyPassword"
    "edFile\022\014\n\004salt\030\001 \002(\014\022\027\n\017aes_init_vector\030"
    "\002 \002(\014\022\030\n\020inner_ciphertext\030\003 \002(\014\"|\n\017Inner"
    "Passworded\022\022\n\nmaster_key\030\001 \002(\014\022\024\n\014filena"
    "mesalt\030\002 \002(\014\022\022\n\nsite_names\030\003 \003(\t\022\026\n\016down"
    "loadsecret\030\004 \002(\014\022\023\n\013private_key\030\005 \002(\014\"l\n"
    "\030MasterKeyRetrievableFile\022\021\n\ttimestamp\030\001"
    " \002(\003\022\027\n\017aes_init_vector\030\002 \002(\014\022$\n\034inner_r"
    "etrievable_ciphertext\030\003 \002(\014\">\n\020InnerRetr"
    "ievable\022\022\n\nmaster_key\030\001 \002(\014\022\026\n\016DOWNLOADS"
    "ECRET\030\002 \002(\014\"\'\n\017InitBlobRequest\022\024\n\014all_ha"
    "sh_xor\030\001 \002(\014\"6\n\020InitBlobResponse\022\023\n\013xor_"
    "matches\030\001 \002(\010\022\r\n\005nonce\030\002 \001(\014\"\246\001\n\013BlobReq"
    "uest\0222\n\014cached_blobs\030\001 \003(\0132\034.pamrac.Blob"
    "Request.BlobHash\022\034\n\024downloadsecret_proof"
    "\030\002 \002(\014\022\023\n\013proof_nonce\030\003 \002(\014\0320\n\010BlobHash\022"
    "\021\n\tblob_name\030\001 \002(\t\022\021\n\tblob_hash\030\002 \002(\014\"3\n"
    "\014BlobResponse\022#\n\tnew_blobs\030\001 \003(\0132\020.pamra"
    "c.BlobFile\"g\n\nBlobUpload\022\027\n\017hashed_filen"
    "ame\030\001 \002(\t\022\036\n\004blob\030\002 \002(\0132\020.pamrac.BlobFil"
    "e\022\r\n\005nonce\030\003 \002(\014\022\021\n\tsignature\030\004 \002(\014\"^\n\020B"
    "lobUploadResult\022\027\n\017verification_ok\030\001 \002(\010"
    "\022\031\n\021upload_successful\030\002 \001(\010\022\026\n\016server_ve"
    "rsion\030\003 \001(\005\"S\n\020ShareListRequest\022\035\n\025reque"
    "ster_fingerprint\030\001 \002(\014\022\r\n\005nonce\030\002 \002(\014\022\021\n"
    "\tsignature\030\003 \002(\014\"\306\001\n\tShareList\022\021\n\ttimest"
    "amp\030\001 \002(\003\022\021\n\tthreshold\030\002 \002(\005\0224\n\nrecipien"
    "ts\030\003 \003(\0132 .pamrac.ShareList.ShareRecipie"
    "nt\022\021\n\tsignature\030\004 \002(\014\032J\n\016ShareRecipient\022"
    "\020\n\010nickname\030\001 \001(\t\022\023\n\013fingerprint\030\002 \002(\014\022\021"
    "\n\tinitiator\030\003 \002(\010\"f\n\007ShareID\022\036\n\026originat"
    "or_fingerprint\030\001 \002(\014\022\031\n\021owner_fingerprin"
    "t\030\002 \002(\014\022 \n\030encrypted_to_fingerprint\030\003 \002("
    "\014\"S\n\014ShareRequest\022!\n\010share_id\030\001 \002(\0132\017.pa"
    "mrac.ShareID\022\r\n\005nonce\030\002 \002(\014\022\021\n\tsignature"
    "\030\003 \002(\014\"\301\001\n\010KeyShare\022\021\n\ttimestamp\030\001 \002(\003\022D"
    "\n\032masterkey_retrievable_file\030\002 \001(\0132 .pam"
    "rac.MasterKeyRetrievableFile\022 \n\030encrypte"
    "d_initiator_mask\030\003 \001(\014\022\027\n\017encrypted_shar"
    "e\030\004 \002(\014\022!\n\010share_id\030\005 \002(\0132\017.pamrac.Share"
    "ID\"\225\001\n\013ShareUpload\022\"\n\trevoke_id\030\001 \003(\0132\017."
    "pamrac.ShareID\022\037\n\005share\030\002 \003(\0132\020.pamrac.K"
    "eyShare\022\037\n\004list\030\003 \001(\0132\021.pamrac.ShareList"
    "\022\r\n\005nonce\030\004 \002(\014\022\021\n\tsignature\030\005 \002(\014\"y\n\021Sh"
    "areUploadResult\022\027\n\017verification_ok\030\001 \002(\010"
    "\022$\n\013ids_revoked\030\002 \003(\0132\017.pamrac.ShareID\022%"
    "\n\014shares_added\030\003 \003(\0132\017.pamrac.ShareID\"\300\001"
    "\n\rFriendNameMap\0225\n\007friends\030\001 \003(\0132$.pamra"
    "c.FriendNameMap.FriendNickname\022\021\n\ttimest"
    "amp\030\002 \002(\003\022\021\n\tsignature\030\003 \002(\014\032R\n\016FriendNi"
    "ckname\022\014\n\004name\030\001 \002(\t\022\032\n\022friend_fingerpri"
    "nt\030\002 \002(\014\022\026\n\016server_address\030\003 \002(\tB6\n\'edu."
    "illinois.cs.salmon.fredshoppinglistB\013PAM"
    "RACProto", 3568);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "pamrac.proto", &protobuf_RegisterTypes);
  PAMRACMessage::default_instance_ = new PAMRACMessage();
  NonceResponse::default_instance_ = new NonceResponse();
  BlobFile::default_instance_ = new BlobFile();
  InnerBlob::default_instance_ = new InnerBlob();
  InnerBlob_KeyValue::default_instance_ = new InnerBlob_KeyValue();
  MasterKeyPasswordedFile::default_instance_ = new MasterKeyPasswordedFile();
  InnerPassworded::default_instance_ = new InnerPassworded();
  MasterKeyRetrievableFile::default_instance_ = new MasterKeyRetrievableFile();
  InnerRetrievable::default_instance_ = new InnerRetrievable();
  InitBlobRequest::default_instance_ = new InitBlobRequest();
  InitBlobResponse::default_instance_ = new InitBlobResponse();
  BlobRequest::default_instance_ = new BlobRequest();
  BlobRequest_BlobHash::default_instance_ = new BlobRequest_BlobHash();
  BlobResponse::default_instance_ = new BlobResponse();
  BlobUpload::default_instance_ = new BlobUpload();
  BlobUploadResult::default_instance_ = new BlobUploadResult();
  ShareListRequest::default_instance_ = new ShareListRequest();
  ShareList::default_instance_ = new ShareList();
  ShareList_ShareRecipient::default_instance_ = new ShareList_ShareRecipient();
  ShareID::default_instance_ = new ShareID();
  ShareRequest::default_instance_ = new ShareRequest();
  KeyShare::default_instance_ = new KeyShare();
  ShareUpload::default_instance_ = new ShareUpload();
  ShareUploadResult::default_instance_ = new ShareUploadResult();
  FriendNameMap::default_instance_ = new FriendNameMap();
  FriendNameMap_FriendNickname::default_instance_ = new FriendNameMap_FriendNickname();
  PAMRACMessage::default_instance_->InitAsDefaultInstance();
  NonceResponse::default_instance_->InitAsDefaultInstance();
  BlobFile::default_instance_->InitAsDefaultInstance();
  InnerBlob::default_instance_->InitAsDefaultInstance();
  InnerBlob_KeyValue::default_instance_->InitAsDefaultInstance();
  MasterKeyPasswordedFile::default_instance_->InitAsDefaultInstance();
  InnerPassworded::default_instance_->InitAsDefaultInstance();
  MasterKeyRetrievableFile::default_instance_->InitAsDefaultInstance();
  InnerRetrievable::default_instance_->InitAsDefaultInstance();
  InitBlobRequest::default_instance_->InitAsDefaultInstance();
  InitBlobResponse::default_instance_->InitAsDefaultInstance();
  BlobRequest::default_instance_->InitAsDefaultInstance();
  BlobRequest_BlobHash::default_instance_->InitAsDefaultInstance();
  BlobResponse::default_instance_->InitAsDefaultInstance();
  BlobUpload::default_instance_->InitAsDefaultInstance();
  BlobUploadResult::default_instance_->InitAsDefaultInstance();
  ShareListRequest::default_instance_->InitAsDefaultInstance();
  ShareList::default_instance_->InitAsDefaultInstance();
  ShareList_ShareRecipient::default_instance_->InitAsDefaultInstance();
  ShareID::default_instance_->InitAsDefaultInstance();
  ShareRequest::default_instance_->InitAsDefaultInstance();
  KeyShare::default_instance_->InitAsDefaultInstance();
  ShareUpload::default_instance_->InitAsDefaultInstance();
  ShareUploadResult::default_instance_->InitAsDefaultInstance();
  FriendNameMap::default_instance_->InitAsDefaultInstance();
  FriendNameMap_FriendNickname::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_pamrac_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_pamrac_2eproto {
  StaticDescriptorInitializer_pamrac_2eproto() {
    protobuf_AddDesc_pamrac_2eproto();
  }
} static_descriptor_initializer_pamrac_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* PAMRACMessage_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PAMRACMessage_Type_descriptor_;
}
bool PAMRACMessage_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const PAMRACMessage_Type PAMRACMessage::INIT_BLOB_REQUEST;
const PAMRACMessage_Type PAMRACMessage::INIT_BLOB_RESPONSE;
const PAMRACMessage_Type PAMRACMessage::BLOB_REQUEST;
const PAMRACMessage_Type PAMRACMessage::BLOB_RESPONSE;
const PAMRACMessage_Type PAMRACMessage::INIT_BLOB_UPLOAD;
const PAMRACMessage_Type PAMRACMessage::BLOB_UPLOAD_NONCE;
const PAMRACMessage_Type PAMRACMessage::BLOB_UPLOAD;
const PAMRACMessage_Type PAMRACMessage::BLOB_UPLOAD_RESULT;
const PAMRACMessage_Type PAMRACMessage::INIT_SHARE_UPLOAD;
const PAMRACMessage_Type PAMRACMessage::SHARE_UPLOAD_NONCE;
const PAMRACMessage_Type PAMRACMessage::SHARE_UPLOAD;
const PAMRACMessage_Type PAMRACMessage::SHARE_UPLOAD_RESULT;
const PAMRACMessage_Type PAMRACMessage::INIT_SHARE_REQUEST;
const PAMRACMessage_Type PAMRACMessage::SHARE_REQUEST_NONCE;
const PAMRACMessage_Type PAMRACMessage::SHARE_REQUEST;
const PAMRACMessage_Type PAMRACMessage::KEY_SHARE;
const PAMRACMessage_Type PAMRACMessage::INIT_SHARE_LIST_REQUEST;
const PAMRACMessage_Type PAMRACMessage::SHARE_LIST_REQUEST_NONCE;
const PAMRACMessage_Type PAMRACMessage::SHARE_LIST_REQUEST;
const PAMRACMessage_Type PAMRACMessage::SHARE_LIST;
const PAMRACMessage_Type PAMRACMessage::NOT_AUTHORIZED;
const PAMRACMessage_Type PAMRACMessage::Type_MIN;
const PAMRACMessage_Type PAMRACMessage::Type_MAX;
const int PAMRACMessage::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int PAMRACMessage::kUserFingerprintFieldNumber;
const int PAMRACMessage::kTypeFieldNumber;
const int PAMRACMessage::kInitBlobRequestFieldNumber;
const int PAMRACMessage::kInitBlobResponseFieldNumber;
const int PAMRACMessage::kBlobRequestFieldNumber;
const int PAMRACMessage::kBlobResponseFieldNumber;
const int PAMRACMessage::kBlobUploadFieldNumber;
const int PAMRACMessage::kBlobUploadResultFieldNumber;
const int PAMRACMessage::kNonceResponseFieldNumber;
const int PAMRACMessage::kShareUploadFieldNumber;
const int PAMRACMessage::kShareUploadResultFieldNumber;
const int PAMRACMessage::kShareRequestFieldNumber;
const int PAMRACMessage::kKeyShareFieldNumber;
const int PAMRACMessage::kShareListRequestFieldNumber;
const int PAMRACMessage::kShareListFieldNumber;
const int PAMRACMessage::kClientPubkeyFieldNumber;
#endif  // !_MSC_VER

PAMRACMessage::PAMRACMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.PAMRACMessage)
}

void PAMRACMessage::InitAsDefaultInstance() {
  init_blob_request_ = const_cast< ::pamrac::InitBlobRequest*>(&::pamrac::InitBlobRequest::default_instance());
  init_blob_response_ = const_cast< ::pamrac::InitBlobResponse*>(&::pamrac::InitBlobResponse::default_instance());
  blob_request_ = const_cast< ::pamrac::BlobRequest*>(&::pamrac::BlobRequest::default_instance());
  blob_response_ = const_cast< ::pamrac::BlobResponse*>(&::pamrac::BlobResponse::default_instance());
  blob_upload_ = const_cast< ::pamrac::BlobUpload*>(&::pamrac::BlobUpload::default_instance());
  blob_upload_result_ = const_cast< ::pamrac::BlobUploadResult*>(&::pamrac::BlobUploadResult::default_instance());
  nonce_response_ = const_cast< ::pamrac::NonceResponse*>(&::pamrac::NonceResponse::default_instance());
  share_upload_ = const_cast< ::pamrac::ShareUpload*>(&::pamrac::ShareUpload::default_instance());
  share_upload_result_ = const_cast< ::pamrac::ShareUploadResult*>(&::pamrac::ShareUploadResult::default_instance());
  share_request_ = const_cast< ::pamrac::ShareRequest*>(&::pamrac::ShareRequest::default_instance());
  key_share_ = const_cast< ::pamrac::KeyShare*>(&::pamrac::KeyShare::default_instance());
  share_list_request_ = const_cast< ::pamrac::ShareListRequest*>(&::pamrac::ShareListRequest::default_instance());
  share_list_ = const_cast< ::pamrac::ShareList*>(&::pamrac::ShareList::default_instance());
}

PAMRACMessage::PAMRACMessage(const PAMRACMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.PAMRACMessage)
}

void PAMRACMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  init_blob_request_ = NULL;
  init_blob_response_ = NULL;
  blob_request_ = NULL;
  blob_response_ = NULL;
  blob_upload_ = NULL;
  blob_upload_result_ = NULL;
  nonce_response_ = NULL;
  share_upload_ = NULL;
  share_upload_result_ = NULL;
  share_request_ = NULL;
  key_share_ = NULL;
  share_list_request_ = NULL;
  share_list_ = NULL;
  client_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PAMRACMessage::~PAMRACMessage() {
  // @@protoc_insertion_point(destructor:pamrac.PAMRACMessage)
  SharedDtor();
}

void PAMRACMessage::SharedDtor() {
  if (user_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_fingerprint_;
  }
  if (client_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_pubkey_;
  }
  if (this != default_instance_) {
    delete init_blob_request_;
    delete init_blob_response_;
    delete blob_request_;
    delete blob_response_;
    delete blob_upload_;
    delete blob_upload_result_;
    delete nonce_response_;
    delete share_upload_;
    delete share_upload_result_;
    delete share_request_;
    delete key_share_;
    delete share_list_request_;
    delete share_list_;
  }
}

void PAMRACMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PAMRACMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PAMRACMessage_descriptor_;
}

const PAMRACMessage& PAMRACMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

PAMRACMessage* PAMRACMessage::default_instance_ = NULL;

PAMRACMessage* PAMRACMessage::New() const {
  return new PAMRACMessage;
}

void PAMRACMessage::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_user_fingerprint()) {
      if (user_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_fingerprint_->clear();
      }
    }
    type_ = 0;
    if (has_init_blob_request()) {
      if (init_blob_request_ != NULL) init_blob_request_->::pamrac::InitBlobRequest::Clear();
    }
    if (has_init_blob_response()) {
      if (init_blob_response_ != NULL) init_blob_response_->::pamrac::InitBlobResponse::Clear();
    }
    if (has_blob_request()) {
      if (blob_request_ != NULL) blob_request_->::pamrac::BlobRequest::Clear();
    }
    if (has_blob_response()) {
      if (blob_response_ != NULL) blob_response_->::pamrac::BlobResponse::Clear();
    }
    if (has_blob_upload()) {
      if (blob_upload_ != NULL) blob_upload_->::pamrac::BlobUpload::Clear();
    }
    if (has_blob_upload_result()) {
      if (blob_upload_result_ != NULL) blob_upload_result_->::pamrac::BlobUploadResult::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    if (has_nonce_response()) {
      if (nonce_response_ != NULL) nonce_response_->::pamrac::NonceResponse::Clear();
    }
    if (has_share_upload()) {
      if (share_upload_ != NULL) share_upload_->::pamrac::ShareUpload::Clear();
    }
    if (has_share_upload_result()) {
      if (share_upload_result_ != NULL) share_upload_result_->::pamrac::ShareUploadResult::Clear();
    }
    if (has_share_request()) {
      if (share_request_ != NULL) share_request_->::pamrac::ShareRequest::Clear();
    }
    if (has_key_share()) {
      if (key_share_ != NULL) key_share_->::pamrac::KeyShare::Clear();
    }
    if (has_share_list_request()) {
      if (share_list_request_ != NULL) share_list_request_->::pamrac::ShareListRequest::Clear();
    }
    if (has_share_list()) {
      if (share_list_ != NULL) share_list_->::pamrac::ShareList::Clear();
    }
    if (has_client_pubkey()) {
      if (client_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        client_pubkey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PAMRACMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.PAMRACMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes user_fingerprint = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .pamrac.PAMRACMessage.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pamrac::PAMRACMessage_Type_IsValid(value)) {
            set_type(static_cast< ::pamrac::PAMRACMessage_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_init_blob_request;
        break;
      }

      // optional .pamrac.InitBlobRequest init_blob_request = 3;
      case 3: {
        if (tag == 26) {
         parse_init_blob_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_init_blob_request()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_init_blob_response;
        break;
      }

      // optional .pamrac.InitBlobResponse init_blob_response = 4;
      case 4: {
        if (tag == 34) {
         parse_init_blob_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_init_blob_response()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_blob_request;
        break;
      }

      // optional .pamrac.BlobRequest blob_request = 5;
      case 5: {
        if (tag == 42) {
         parse_blob_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blob_request()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_blob_response;
        break;
      }

      // optional .pamrac.BlobResponse blob_response = 6;
      case 6: {
        if (tag == 50) {
         parse_blob_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blob_response()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_blob_upload;
        break;
      }

      // optional .pamrac.BlobUpload blob_upload = 7;
      case 7: {
        if (tag == 58) {
         parse_blob_upload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blob_upload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_blob_upload_result;
        break;
      }

      // optional .pamrac.BlobUploadResult blob_upload_result = 8;
      case 8: {
        if (tag == 66) {
         parse_blob_upload_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blob_upload_result()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_nonce_response;
        break;
      }

      // optional .pamrac.NonceResponse nonce_response = 9;
      case 9: {
        if (tag == 74) {
         parse_nonce_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nonce_response()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_share_upload;
        break;
      }

      // optional .pamrac.ShareUpload share_upload = 10;
      case 10: {
        if (tag == 82) {
         parse_share_upload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_upload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_share_upload_result;
        break;
      }

      // optional .pamrac.ShareUploadResult share_upload_result = 11;
      case 11: {
        if (tag == 90) {
         parse_share_upload_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_upload_result()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_share_request;
        break;
      }

      // optional .pamrac.ShareRequest share_request = 12;
      case 12: {
        if (tag == 98) {
         parse_share_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_request()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_key_share;
        break;
      }

      // optional .pamrac.KeyShare key_share = 13;
      case 13: {
        if (tag == 106) {
         parse_key_share:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key_share()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_share_list_request;
        break;
      }

      // optional .pamrac.ShareListRequest share_list_request = 14;
      case 14: {
        if (tag == 114) {
         parse_share_list_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_list_request()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_share_list;
        break;
      }

      // optional .pamrac.ShareList share_list = 15;
      case 15: {
        if (tag == 122) {
         parse_share_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_client_pubkey;
        break;
      }

      // optional bytes client_pubkey = 16;
      case 16: {
        if (tag == 130) {
         parse_client_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_pubkey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.PAMRACMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.PAMRACMessage)
  return false;
#undef DO_
}

void PAMRACMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.PAMRACMessage)
  // optional bytes user_fingerprint = 1;
  if (has_user_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->user_fingerprint(), output);
  }

  // required .pamrac.PAMRACMessage.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .pamrac.InitBlobRequest init_blob_request = 3;
  if (has_init_blob_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->init_blob_request(), output);
  }

  // optional .pamrac.InitBlobResponse init_blob_response = 4;
  if (has_init_blob_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->init_blob_response(), output);
  }

  // optional .pamrac.BlobRequest blob_request = 5;
  if (has_blob_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->blob_request(), output);
  }

  // optional .pamrac.BlobResponse blob_response = 6;
  if (has_blob_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->blob_response(), output);
  }

  // optional .pamrac.BlobUpload blob_upload = 7;
  if (has_blob_upload()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->blob_upload(), output);
  }

  // optional .pamrac.BlobUploadResult blob_upload_result = 8;
  if (has_blob_upload_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->blob_upload_result(), output);
  }

  // optional .pamrac.NonceResponse nonce_response = 9;
  if (has_nonce_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->nonce_response(), output);
  }

  // optional .pamrac.ShareUpload share_upload = 10;
  if (has_share_upload()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->share_upload(), output);
  }

  // optional .pamrac.ShareUploadResult share_upload_result = 11;
  if (has_share_upload_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->share_upload_result(), output);
  }

  // optional .pamrac.ShareRequest share_request = 12;
  if (has_share_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->share_request(), output);
  }

  // optional .pamrac.KeyShare key_share = 13;
  if (has_key_share()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->key_share(), output);
  }

  // optional .pamrac.ShareListRequest share_list_request = 14;
  if (has_share_list_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->share_list_request(), output);
  }

  // optional .pamrac.ShareList share_list = 15;
  if (has_share_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->share_list(), output);
  }

  // optional bytes client_pubkey = 16;
  if (has_client_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      16, this->client_pubkey(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.PAMRACMessage)
}

::google::protobuf::uint8* PAMRACMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.PAMRACMessage)
  // optional bytes user_fingerprint = 1;
  if (has_user_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->user_fingerprint(), target);
  }

  // required .pamrac.PAMRACMessage.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .pamrac.InitBlobRequest init_blob_request = 3;
  if (has_init_blob_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->init_blob_request(), target);
  }

  // optional .pamrac.InitBlobResponse init_blob_response = 4;
  if (has_init_blob_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->init_blob_response(), target);
  }

  // optional .pamrac.BlobRequest blob_request = 5;
  if (has_blob_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->blob_request(), target);
  }

  // optional .pamrac.BlobResponse blob_response = 6;
  if (has_blob_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->blob_response(), target);
  }

  // optional .pamrac.BlobUpload blob_upload = 7;
  if (has_blob_upload()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->blob_upload(), target);
  }

  // optional .pamrac.BlobUploadResult blob_upload_result = 8;
  if (has_blob_upload_result()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->blob_upload_result(), target);
  }

  // optional .pamrac.NonceResponse nonce_response = 9;
  if (has_nonce_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->nonce_response(), target);
  }

  // optional .pamrac.ShareUpload share_upload = 10;
  if (has_share_upload()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->share_upload(), target);
  }

  // optional .pamrac.ShareUploadResult share_upload_result = 11;
  if (has_share_upload_result()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->share_upload_result(), target);
  }

  // optional .pamrac.ShareRequest share_request = 12;
  if (has_share_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->share_request(), target);
  }

  // optional .pamrac.KeyShare key_share = 13;
  if (has_key_share()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->key_share(), target);
  }

  // optional .pamrac.ShareListRequest share_list_request = 14;
  if (has_share_list_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->share_list_request(), target);
  }

  // optional .pamrac.ShareList share_list = 15;
  if (has_share_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->share_list(), target);
  }

  // optional bytes client_pubkey = 16;
  if (has_client_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        16, this->client_pubkey(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.PAMRACMessage)
  return target;
}

int PAMRACMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes user_fingerprint = 1;
    if (has_user_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_fingerprint());
    }

    // required .pamrac.PAMRACMessage.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .pamrac.InitBlobRequest init_blob_request = 3;
    if (has_init_blob_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->init_blob_request());
    }

    // optional .pamrac.InitBlobResponse init_blob_response = 4;
    if (has_init_blob_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->init_blob_response());
    }

    // optional .pamrac.BlobRequest blob_request = 5;
    if (has_blob_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->blob_request());
    }

    // optional .pamrac.BlobResponse blob_response = 6;
    if (has_blob_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->blob_response());
    }

    // optional .pamrac.BlobUpload blob_upload = 7;
    if (has_blob_upload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->blob_upload());
    }

    // optional .pamrac.BlobUploadResult blob_upload_result = 8;
    if (has_blob_upload_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->blob_upload_result());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .pamrac.NonceResponse nonce_response = 9;
    if (has_nonce_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nonce_response());
    }

    // optional .pamrac.ShareUpload share_upload = 10;
    if (has_share_upload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_upload());
    }

    // optional .pamrac.ShareUploadResult share_upload_result = 11;
    if (has_share_upload_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_upload_result());
    }

    // optional .pamrac.ShareRequest share_request = 12;
    if (has_share_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_request());
    }

    // optional .pamrac.KeyShare key_share = 13;
    if (has_key_share()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->key_share());
    }

    // optional .pamrac.ShareListRequest share_list_request = 14;
    if (has_share_list_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_list_request());
    }

    // optional .pamrac.ShareList share_list = 15;
    if (has_share_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_list());
    }

    // optional bytes client_pubkey = 16;
    if (has_client_pubkey()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->client_pubkey());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PAMRACMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PAMRACMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PAMRACMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PAMRACMessage::MergeFrom(const PAMRACMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_fingerprint()) {
      set_user_fingerprint(from.user_fingerprint());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_init_blob_request()) {
      mutable_init_blob_request()->::pamrac::InitBlobRequest::MergeFrom(from.init_blob_request());
    }
    if (from.has_init_blob_response()) {
      mutable_init_blob_response()->::pamrac::InitBlobResponse::MergeFrom(from.init_blob_response());
    }
    if (from.has_blob_request()) {
      mutable_blob_request()->::pamrac::BlobRequest::MergeFrom(from.blob_request());
    }
    if (from.has_blob_response()) {
      mutable_blob_response()->::pamrac::BlobResponse::MergeFrom(from.blob_response());
    }
    if (from.has_blob_upload()) {
      mutable_blob_upload()->::pamrac::BlobUpload::MergeFrom(from.blob_upload());
    }
    if (from.has_blob_upload_result()) {
      mutable_blob_upload_result()->::pamrac::BlobUploadResult::MergeFrom(from.blob_upload_result());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_nonce_response()) {
      mutable_nonce_response()->::pamrac::NonceResponse::MergeFrom(from.nonce_response());
    }
    if (from.has_share_upload()) {
      mutable_share_upload()->::pamrac::ShareUpload::MergeFrom(from.share_upload());
    }
    if (from.has_share_upload_result()) {
      mutable_share_upload_result()->::pamrac::ShareUploadResult::MergeFrom(from.share_upload_result());
    }
    if (from.has_share_request()) {
      mutable_share_request()->::pamrac::ShareRequest::MergeFrom(from.share_request());
    }
    if (from.has_key_share()) {
      mutable_key_share()->::pamrac::KeyShare::MergeFrom(from.key_share());
    }
    if (from.has_share_list_request()) {
      mutable_share_list_request()->::pamrac::ShareListRequest::MergeFrom(from.share_list_request());
    }
    if (from.has_share_list()) {
      mutable_share_list()->::pamrac::ShareList::MergeFrom(from.share_list());
    }
    if (from.has_client_pubkey()) {
      set_client_pubkey(from.client_pubkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PAMRACMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PAMRACMessage::CopyFrom(const PAMRACMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PAMRACMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_init_blob_request()) {
    if (!this->init_blob_request().IsInitialized()) return false;
  }
  if (has_init_blob_response()) {
    if (!this->init_blob_response().IsInitialized()) return false;
  }
  if (has_blob_request()) {
    if (!this->blob_request().IsInitialized()) return false;
  }
  if (has_blob_response()) {
    if (!this->blob_response().IsInitialized()) return false;
  }
  if (has_blob_upload()) {
    if (!this->blob_upload().IsInitialized()) return false;
  }
  if (has_blob_upload_result()) {
    if (!this->blob_upload_result().IsInitialized()) return false;
  }
  if (has_nonce_response()) {
    if (!this->nonce_response().IsInitialized()) return false;
  }
  if (has_share_upload()) {
    if (!this->share_upload().IsInitialized()) return false;
  }
  if (has_share_upload_result()) {
    if (!this->share_upload_result().IsInitialized()) return false;
  }
  if (has_share_request()) {
    if (!this->share_request().IsInitialized()) return false;
  }
  if (has_key_share()) {
    if (!this->key_share().IsInitialized()) return false;
  }
  if (has_share_list_request()) {
    if (!this->share_list_request().IsInitialized()) return false;
  }
  if (has_share_list()) {
    if (!this->share_list().IsInitialized()) return false;
  }
  return true;
}

void PAMRACMessage::Swap(PAMRACMessage* other) {
  if (other != this) {
    std::swap(user_fingerprint_, other->user_fingerprint_);
    std::swap(type_, other->type_);
    std::swap(init_blob_request_, other->init_blob_request_);
    std::swap(init_blob_response_, other->init_blob_response_);
    std::swap(blob_request_, other->blob_request_);
    std::swap(blob_response_, other->blob_response_);
    std::swap(blob_upload_, other->blob_upload_);
    std::swap(blob_upload_result_, other->blob_upload_result_);
    std::swap(nonce_response_, other->nonce_response_);
    std::swap(share_upload_, other->share_upload_);
    std::swap(share_upload_result_, other->share_upload_result_);
    std::swap(share_request_, other->share_request_);
    std::swap(key_share_, other->key_share_);
    std::swap(share_list_request_, other->share_list_request_);
    std::swap(share_list_, other->share_list_);
    std::swap(client_pubkey_, other->client_pubkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PAMRACMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PAMRACMessage_descriptor_;
  metadata.reflection = PAMRACMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NonceResponse::kNonceFieldNumber;
#endif  // !_MSC_VER

NonceResponse::NonceResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.NonceResponse)
}

void NonceResponse::InitAsDefaultInstance() {
}

NonceResponse::NonceResponse(const NonceResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.NonceResponse)
}

void NonceResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NonceResponse::~NonceResponse() {
  // @@protoc_insertion_point(destructor:pamrac.NonceResponse)
  SharedDtor();
}

void NonceResponse::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (this != default_instance_) {
  }
}

void NonceResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NonceResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NonceResponse_descriptor_;
}

const NonceResponse& NonceResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

NonceResponse* NonceResponse::default_instance_ = NULL;

NonceResponse* NonceResponse::New() const {
  return new NonceResponse;
}

void NonceResponse::Clear() {
  if (has_nonce()) {
    if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      nonce_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NonceResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.NonceResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes nonce = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.NonceResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.NonceResponse)
  return false;
#undef DO_
}

void NonceResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.NonceResponse)
  // required bytes nonce = 1;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->nonce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.NonceResponse)
}

::google::protobuf::uint8* NonceResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.NonceResponse)
  // required bytes nonce = 1;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->nonce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.NonceResponse)
  return target;
}

int NonceResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes nonce = 1;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NonceResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NonceResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NonceResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NonceResponse::MergeFrom(const NonceResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NonceResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NonceResponse::CopyFrom(const NonceResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NonceResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void NonceResponse::Swap(NonceResponse* other) {
  if (other != this) {
    std::swap(nonce_, other->nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NonceResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NonceResponse_descriptor_;
  metadata.reflection = NonceResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlobFile::kSaltFieldNumber;
const int BlobFile::kVersionFieldNumber;
const int BlobFile::kAesInitVectorFieldNumber;
const int BlobFile::kInnerBlobCiphertextFieldNumber;
#endif  // !_MSC_VER

BlobFile::BlobFile()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.BlobFile)
}

void BlobFile::InitAsDefaultInstance() {
}

BlobFile::BlobFile(const BlobFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.BlobFile)
}

void BlobFile::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = 0;
  aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  inner_blob_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlobFile::~BlobFile() {
  // @@protoc_insertion_point(destructor:pamrac.BlobFile)
  SharedDtor();
}

void BlobFile::SharedDtor() {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete salt_;
  }
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes_init_vector_;
  }
  if (inner_blob_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_blob_ciphertext_;
  }
  if (this != default_instance_) {
  }
}

void BlobFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlobFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlobFile_descriptor_;
}

const BlobFile& BlobFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

BlobFile* BlobFile::default_instance_ = NULL;

BlobFile* BlobFile::New() const {
  return new BlobFile;
}

void BlobFile::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_salt()) {
      if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        salt_->clear();
      }
    }
    version_ = 0;
    if (has_aes_init_vector()) {
      if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        aes_init_vector_->clear();
      }
    }
    if (has_inner_blob_ciphertext()) {
      if (inner_blob_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        inner_blob_ciphertext_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlobFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.BlobFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes salt = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_salt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }

      // required int32 version = 2;
      case 2: {
        if (tag == 16) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_aes_init_vector;
        break;
      }

      // required bytes aes_init_vector = 3;
      case 3: {
        if (tag == 26) {
         parse_aes_init_vector:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes_init_vector()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_inner_blob_ciphertext;
        break;
      }

      // required bytes inner_blob_ciphertext = 4;
      case 4: {
        if (tag == 34) {
         parse_inner_blob_ciphertext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_inner_blob_ciphertext()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.BlobFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.BlobFile)
  return false;
#undef DO_
}

void BlobFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.BlobFile)
  // optional bytes salt = 1;
  if (has_salt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->salt(), output);
  }

  // required int32 version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->version(), output);
  }

  // required bytes aes_init_vector = 3;
  if (has_aes_init_vector()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->aes_init_vector(), output);
  }

  // required bytes inner_blob_ciphertext = 4;
  if (has_inner_blob_ciphertext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->inner_blob_ciphertext(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.BlobFile)
}

::google::protobuf::uint8* BlobFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.BlobFile)
  // optional bytes salt = 1;
  if (has_salt()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->salt(), target);
  }

  // required int32 version = 2;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->version(), target);
  }

  // required bytes aes_init_vector = 3;
  if (has_aes_init_vector()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->aes_init_vector(), target);
  }

  // required bytes inner_blob_ciphertext = 4;
  if (has_inner_blob_ciphertext()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->inner_blob_ciphertext(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.BlobFile)
  return target;
}

int BlobFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes salt = 1;
    if (has_salt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->salt());
    }

    // required int32 version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

    // required bytes aes_init_vector = 3;
    if (has_aes_init_vector()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes_init_vector());
    }

    // required bytes inner_blob_ciphertext = 4;
    if (has_inner_blob_ciphertext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->inner_blob_ciphertext());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlobFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlobFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlobFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlobFile::MergeFrom(const BlobFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_salt()) {
      set_salt(from.salt());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_aes_init_vector()) {
      set_aes_init_vector(from.aes_init_vector());
    }
    if (from.has_inner_blob_ciphertext()) {
      set_inner_blob_ciphertext(from.inner_blob_ciphertext());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlobFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobFile::CopyFrom(const BlobFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  return true;
}

void BlobFile::Swap(BlobFile* other) {
  if (other != this) {
    std::swap(salt_, other->salt_);
    std::swap(version_, other->version_);
    std::swap(aes_init_vector_, other->aes_init_vector_);
    std::swap(inner_blob_ciphertext_, other->inner_blob_ciphertext_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlobFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlobFile_descriptor_;
  metadata.reflection = BlobFile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InnerBlob_KeyValue::kNameFieldNumber;
const int InnerBlob_KeyValue::kValueFieldNumber;
#endif  // !_MSC_VER

InnerBlob_KeyValue::InnerBlob_KeyValue()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.InnerBlob.KeyValue)
}

void InnerBlob_KeyValue::InitAsDefaultInstance() {
}

InnerBlob_KeyValue::InnerBlob_KeyValue(const InnerBlob_KeyValue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.InnerBlob.KeyValue)
}

void InnerBlob_KeyValue::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InnerBlob_KeyValue::~InnerBlob_KeyValue() {
  // @@protoc_insertion_point(destructor:pamrac.InnerBlob.KeyValue)
  SharedDtor();
}

void InnerBlob_KeyValue::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void InnerBlob_KeyValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InnerBlob_KeyValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InnerBlob_KeyValue_descriptor_;
}

const InnerBlob_KeyValue& InnerBlob_KeyValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

InnerBlob_KeyValue* InnerBlob_KeyValue::default_instance_ = NULL;

InnerBlob_KeyValue* InnerBlob_KeyValue::New() const {
  return new InnerBlob_KeyValue;
}

void InnerBlob_KeyValue::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InnerBlob_KeyValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.InnerBlob.KeyValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.InnerBlob.KeyValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.InnerBlob.KeyValue)
  return false;
#undef DO_
}

void InnerBlob_KeyValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.InnerBlob.KeyValue)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.InnerBlob.KeyValue)
}

::google::protobuf::uint8* InnerBlob_KeyValue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.InnerBlob.KeyValue)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.InnerBlob.KeyValue)
  return target;
}

int InnerBlob_KeyValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InnerBlob_KeyValue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InnerBlob_KeyValue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InnerBlob_KeyValue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InnerBlob_KeyValue::MergeFrom(const InnerBlob_KeyValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InnerBlob_KeyValue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InnerBlob_KeyValue::CopyFrom(const InnerBlob_KeyValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerBlob_KeyValue::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void InnerBlob_KeyValue::Swap(InnerBlob_KeyValue* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InnerBlob_KeyValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InnerBlob_KeyValue_descriptor_;
  metadata.reflection = InnerBlob_KeyValue_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int InnerBlob::kFilenameFieldNumber;
const int InnerBlob::kFieldsFieldNumber;
#endif  // !_MSC_VER

InnerBlob::InnerBlob()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.InnerBlob)
}

void InnerBlob::InitAsDefaultInstance() {
}

InnerBlob::InnerBlob(const InnerBlob& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.InnerBlob)
}

void InnerBlob::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InnerBlob::~InnerBlob() {
  // @@protoc_insertion_point(destructor:pamrac.InnerBlob)
  SharedDtor();
}

void InnerBlob::SharedDtor() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (this != default_instance_) {
  }
}

void InnerBlob::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InnerBlob::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InnerBlob_descriptor_;
}

const InnerBlob& InnerBlob::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

InnerBlob* InnerBlob::default_instance_ = NULL;

InnerBlob* InnerBlob::New() const {
  return new InnerBlob;
}

void InnerBlob::Clear() {
  if (has_filename()) {
    if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      filename_->clear();
    }
  }
  fields_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InnerBlob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.InnerBlob)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string filename = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_fields;
        break;
      }

      // repeated .pamrac.InnerBlob.KeyValue fields = 2;
      case 2: {
        if (tag == 18) {
         parse_fields:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fields()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_fields;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.InnerBlob)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.InnerBlob)
  return false;
#undef DO_
}

void InnerBlob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.InnerBlob)
  // required string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->filename(), output);
  }

  // repeated .pamrac.InnerBlob.KeyValue fields = 2;
  for (int i = 0; i < this->fields_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->fields(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.InnerBlob)
}

::google::protobuf::uint8* InnerBlob::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.InnerBlob)
  // required string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filename(), target);
  }

  // repeated .pamrac.InnerBlob.KeyValue fields = 2;
  for (int i = 0; i < this->fields_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->fields(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.InnerBlob)
  return target;
}

int InnerBlob::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string filename = 1;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

  }
  // repeated .pamrac.InnerBlob.KeyValue fields = 2;
  total_size += 1 * this->fields_size();
  for (int i = 0; i < this->fields_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fields(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InnerBlob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InnerBlob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InnerBlob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InnerBlob::MergeFrom(const InnerBlob& from) {
  GOOGLE_CHECK_NE(&from, this);
  fields_.MergeFrom(from.fields_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filename()) {
      set_filename(from.filename());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InnerBlob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InnerBlob::CopyFrom(const InnerBlob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerBlob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->fields())) return false;
  return true;
}

void InnerBlob::Swap(InnerBlob* other) {
  if (other != this) {
    std::swap(filename_, other->filename_);
    fields_.Swap(&other->fields_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InnerBlob::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InnerBlob_descriptor_;
  metadata.reflection = InnerBlob_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MasterKeyPasswordedFile::kSaltFieldNumber;
const int MasterKeyPasswordedFile::kAesInitVectorFieldNumber;
const int MasterKeyPasswordedFile::kInnerCiphertextFieldNumber;
#endif  // !_MSC_VER

MasterKeyPasswordedFile::MasterKeyPasswordedFile()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.MasterKeyPasswordedFile)
}

void MasterKeyPasswordedFile::InitAsDefaultInstance() {
}

MasterKeyPasswordedFile::MasterKeyPasswordedFile(const MasterKeyPasswordedFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.MasterKeyPasswordedFile)
}

void MasterKeyPasswordedFile::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  inner_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterKeyPasswordedFile::~MasterKeyPasswordedFile() {
  // @@protoc_insertion_point(destructor:pamrac.MasterKeyPasswordedFile)
  SharedDtor();
}

void MasterKeyPasswordedFile::SharedDtor() {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete salt_;
  }
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes_init_vector_;
  }
  if (inner_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_ciphertext_;
  }
  if (this != default_instance_) {
  }
}

void MasterKeyPasswordedFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterKeyPasswordedFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterKeyPasswordedFile_descriptor_;
}

const MasterKeyPasswordedFile& MasterKeyPasswordedFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

MasterKeyPasswordedFile* MasterKeyPasswordedFile::default_instance_ = NULL;

MasterKeyPasswordedFile* MasterKeyPasswordedFile::New() const {
  return new MasterKeyPasswordedFile;
}

void MasterKeyPasswordedFile::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_salt()) {
      if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        salt_->clear();
      }
    }
    if (has_aes_init_vector()) {
      if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        aes_init_vector_->clear();
      }
    }
    if (has_inner_ciphertext()) {
      if (inner_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        inner_ciphertext_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MasterKeyPasswordedFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.MasterKeyPasswordedFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes salt = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_salt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_aes_init_vector;
        break;
      }

      // required bytes aes_init_vector = 2;
      case 2: {
        if (tag == 18) {
         parse_aes_init_vector:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes_init_vector()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_inner_ciphertext;
        break;
      }

      // required bytes inner_ciphertext = 3;
      case 3: {
        if (tag == 26) {
         parse_inner_ciphertext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_inner_ciphertext()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.MasterKeyPasswordedFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.MasterKeyPasswordedFile)
  return false;
#undef DO_
}

void MasterKeyPasswordedFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.MasterKeyPasswordedFile)
  // required bytes salt = 1;
  if (has_salt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->salt(), output);
  }

  // required bytes aes_init_vector = 2;
  if (has_aes_init_vector()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->aes_init_vector(), output);
  }

  // required bytes inner_ciphertext = 3;
  if (has_inner_ciphertext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->inner_ciphertext(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.MasterKeyPasswordedFile)
}

::google::protobuf::uint8* MasterKeyPasswordedFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.MasterKeyPasswordedFile)
  // required bytes salt = 1;
  if (has_salt()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->salt(), target);
  }

  // required bytes aes_init_vector = 2;
  if (has_aes_init_vector()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->aes_init_vector(), target);
  }

  // required bytes inner_ciphertext = 3;
  if (has_inner_ciphertext()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->inner_ciphertext(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.MasterKeyPasswordedFile)
  return target;
}

int MasterKeyPasswordedFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes salt = 1;
    if (has_salt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->salt());
    }

    // required bytes aes_init_vector = 2;
    if (has_aes_init_vector()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes_init_vector());
    }

    // required bytes inner_ciphertext = 3;
    if (has_inner_ciphertext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->inner_ciphertext());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterKeyPasswordedFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MasterKeyPasswordedFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MasterKeyPasswordedFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MasterKeyPasswordedFile::MergeFrom(const MasterKeyPasswordedFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_salt()) {
      set_salt(from.salt());
    }
    if (from.has_aes_init_vector()) {
      set_aes_init_vector(from.aes_init_vector());
    }
    if (from.has_inner_ciphertext()) {
      set_inner_ciphertext(from.inner_ciphertext());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MasterKeyPasswordedFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterKeyPasswordedFile::CopyFrom(const MasterKeyPasswordedFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterKeyPasswordedFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MasterKeyPasswordedFile::Swap(MasterKeyPasswordedFile* other) {
  if (other != this) {
    std::swap(salt_, other->salt_);
    std::swap(aes_init_vector_, other->aes_init_vector_);
    std::swap(inner_ciphertext_, other->inner_ciphertext_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MasterKeyPasswordedFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterKeyPasswordedFile_descriptor_;
  metadata.reflection = MasterKeyPasswordedFile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InnerPassworded::kMasterKeyFieldNumber;
const int InnerPassworded::kFilenamesaltFieldNumber;
const int InnerPassworded::kSiteNamesFieldNumber;
const int InnerPassworded::kDownloadsecretFieldNumber;
const int InnerPassworded::kPrivateKeyFieldNumber;
#endif  // !_MSC_VER

InnerPassworded::InnerPassworded()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.InnerPassworded)
}

void InnerPassworded::InitAsDefaultInstance() {
}

InnerPassworded::InnerPassworded(const InnerPassworded& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.InnerPassworded)
}

void InnerPassworded::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  master_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filenamesalt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  downloadsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InnerPassworded::~InnerPassworded() {
  // @@protoc_insertion_point(destructor:pamrac.InnerPassworded)
  SharedDtor();
}

void InnerPassworded::SharedDtor() {
  if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_key_;
  }
  if (filenamesalt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filenamesalt_;
  }
  if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete downloadsecret_;
  }
  if (private_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete private_key_;
  }
  if (this != default_instance_) {
  }
}

void InnerPassworded::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InnerPassworded::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InnerPassworded_descriptor_;
}

const InnerPassworded& InnerPassworded::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

InnerPassworded* InnerPassworded::default_instance_ = NULL;

InnerPassworded* InnerPassworded::New() const {
  return new InnerPassworded;
}

void InnerPassworded::Clear() {
  if (_has_bits_[0 / 32] & 27) {
    if (has_master_key()) {
      if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        master_key_->clear();
      }
    }
    if (has_filenamesalt()) {
      if (filenamesalt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filenamesalt_->clear();
      }
    }
    if (has_downloadsecret()) {
      if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        downloadsecret_->clear();
      }
    }
    if (has_private_key()) {
      if (private_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        private_key_->clear();
      }
    }
  }
  site_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InnerPassworded::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.InnerPassworded)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes master_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_master_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_filenamesalt;
        break;
      }

      // required bytes filenamesalt = 2;
      case 2: {
        if (tag == 18) {
         parse_filenamesalt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_filenamesalt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_site_names;
        break;
      }

      // repeated string site_names = 3;
      case 3: {
        if (tag == 26) {
         parse_site_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_site_names()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->site_names(this->site_names_size() - 1).data(),
            this->site_names(this->site_names_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "site_names");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_site_names;
        if (input->ExpectTag(34)) goto parse_downloadsecret;
        break;
      }

      // required bytes downloadsecret = 4;
      case 4: {
        if (tag == 34) {
         parse_downloadsecret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_downloadsecret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_private_key;
        break;
      }

      // required bytes private_key = 5;
      case 5: {
        if (tag == 42) {
         parse_private_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_private_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.InnerPassworded)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.InnerPassworded)
  return false;
#undef DO_
}

void InnerPassworded::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.InnerPassworded)
  // required bytes master_key = 1;
  if (has_master_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->master_key(), output);
  }

  // required bytes filenamesalt = 2;
  if (has_filenamesalt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->filenamesalt(), output);
  }

  // repeated string site_names = 3;
  for (int i = 0; i < this->site_names_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->site_names(i).data(), this->site_names(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "site_names");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->site_names(i), output);
  }

  // required bytes downloadsecret = 4;
  if (has_downloadsecret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->downloadsecret(), output);
  }

  // required bytes private_key = 5;
  if (has_private_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->private_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.InnerPassworded)
}

::google::protobuf::uint8* InnerPassworded::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.InnerPassworded)
  // required bytes master_key = 1;
  if (has_master_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->master_key(), target);
  }

  // required bytes filenamesalt = 2;
  if (has_filenamesalt()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->filenamesalt(), target);
  }

  // repeated string site_names = 3;
  for (int i = 0; i < this->site_names_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->site_names(i).data(), this->site_names(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "site_names");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->site_names(i), target);
  }

  // required bytes downloadsecret = 4;
  if (has_downloadsecret()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->downloadsecret(), target);
  }

  // required bytes private_key = 5;
  if (has_private_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->private_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.InnerPassworded)
  return target;
}

int InnerPassworded::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes master_key = 1;
    if (has_master_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->master_key());
    }

    // required bytes filenamesalt = 2;
    if (has_filenamesalt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->filenamesalt());
    }

    // required bytes downloadsecret = 4;
    if (has_downloadsecret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->downloadsecret());
    }

    // required bytes private_key = 5;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->private_key());
    }

  }
  // repeated string site_names = 3;
  total_size += 1 * this->site_names_size();
  for (int i = 0; i < this->site_names_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->site_names(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InnerPassworded::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InnerPassworded* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InnerPassworded*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InnerPassworded::MergeFrom(const InnerPassworded& from) {
  GOOGLE_CHECK_NE(&from, this);
  site_names_.MergeFrom(from.site_names_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master_key()) {
      set_master_key(from.master_key());
    }
    if (from.has_filenamesalt()) {
      set_filenamesalt(from.filenamesalt());
    }
    if (from.has_downloadsecret()) {
      set_downloadsecret(from.downloadsecret());
    }
    if (from.has_private_key()) {
      set_private_key(from.private_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InnerPassworded::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InnerPassworded::CopyFrom(const InnerPassworded& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerPassworded::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  return true;
}

void InnerPassworded::Swap(InnerPassworded* other) {
  if (other != this) {
    std::swap(master_key_, other->master_key_);
    std::swap(filenamesalt_, other->filenamesalt_);
    site_names_.Swap(&other->site_names_);
    std::swap(downloadsecret_, other->downloadsecret_);
    std::swap(private_key_, other->private_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InnerPassworded::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InnerPassworded_descriptor_;
  metadata.reflection = InnerPassworded_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MasterKeyRetrievableFile::kTimestampFieldNumber;
const int MasterKeyRetrievableFile::kAesInitVectorFieldNumber;
const int MasterKeyRetrievableFile::kInnerRetrievableCiphertextFieldNumber;
#endif  // !_MSC_VER

MasterKeyRetrievableFile::MasterKeyRetrievableFile()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.MasterKeyRetrievableFile)
}

void MasterKeyRetrievableFile::InitAsDefaultInstance() {
}

MasterKeyRetrievableFile::MasterKeyRetrievableFile(const MasterKeyRetrievableFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.MasterKeyRetrievableFile)
}

void MasterKeyRetrievableFile::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  inner_retrievable_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterKeyRetrievableFile::~MasterKeyRetrievableFile() {
  // @@protoc_insertion_point(destructor:pamrac.MasterKeyRetrievableFile)
  SharedDtor();
}

void MasterKeyRetrievableFile::SharedDtor() {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes_init_vector_;
  }
  if (inner_retrievable_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_retrievable_ciphertext_;
  }
  if (this != default_instance_) {
  }
}

void MasterKeyRetrievableFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterKeyRetrievableFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterKeyRetrievableFile_descriptor_;
}

const MasterKeyRetrievableFile& MasterKeyRetrievableFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

MasterKeyRetrievableFile* MasterKeyRetrievableFile::default_instance_ = NULL;

MasterKeyRetrievableFile* MasterKeyRetrievableFile::New() const {
  return new MasterKeyRetrievableFile;
}

void MasterKeyRetrievableFile::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    timestamp_ = GOOGLE_LONGLONG(0);
    if (has_aes_init_vector()) {
      if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        aes_init_vector_->clear();
      }
    }
    if (has_inner_retrievable_ciphertext()) {
      if (inner_retrievable_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        inner_retrievable_ciphertext_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MasterKeyRetrievableFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.MasterKeyRetrievableFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 timestamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_aes_init_vector;
        break;
      }

      // required bytes aes_init_vector = 2;
      case 2: {
        if (tag == 18) {
         parse_aes_init_vector:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes_init_vector()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_inner_retrievable_ciphertext;
        break;
      }

      // required bytes inner_retrievable_ciphertext = 3;
      case 3: {
        if (tag == 26) {
         parse_inner_retrievable_ciphertext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_inner_retrievable_ciphertext()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.MasterKeyRetrievableFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.MasterKeyRetrievableFile)
  return false;
#undef DO_
}

void MasterKeyRetrievableFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.MasterKeyRetrievableFile)
  // required int64 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->timestamp(), output);
  }

  // required bytes aes_init_vector = 2;
  if (has_aes_init_vector()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->aes_init_vector(), output);
  }

  // required bytes inner_retrievable_ciphertext = 3;
  if (has_inner_retrievable_ciphertext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->inner_retrievable_ciphertext(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.MasterKeyRetrievableFile)
}

::google::protobuf::uint8* MasterKeyRetrievableFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.MasterKeyRetrievableFile)
  // required int64 timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->timestamp(), target);
  }

  // required bytes aes_init_vector = 2;
  if (has_aes_init_vector()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->aes_init_vector(), target);
  }

  // required bytes inner_retrievable_ciphertext = 3;
  if (has_inner_retrievable_ciphertext()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->inner_retrievable_ciphertext(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.MasterKeyRetrievableFile)
  return target;
}

int MasterKeyRetrievableFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // required bytes aes_init_vector = 2;
    if (has_aes_init_vector()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes_init_vector());
    }

    // required bytes inner_retrievable_ciphertext = 3;
    if (has_inner_retrievable_ciphertext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->inner_retrievable_ciphertext());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterKeyRetrievableFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MasterKeyRetrievableFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MasterKeyRetrievableFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MasterKeyRetrievableFile::MergeFrom(const MasterKeyRetrievableFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_aes_init_vector()) {
      set_aes_init_vector(from.aes_init_vector());
    }
    if (from.has_inner_retrievable_ciphertext()) {
      set_inner_retrievable_ciphertext(from.inner_retrievable_ciphertext());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MasterKeyRetrievableFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterKeyRetrievableFile::CopyFrom(const MasterKeyRetrievableFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterKeyRetrievableFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MasterKeyRetrievableFile::Swap(MasterKeyRetrievableFile* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(aes_init_vector_, other->aes_init_vector_);
    std::swap(inner_retrievable_ciphertext_, other->inner_retrievable_ciphertext_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MasterKeyRetrievableFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterKeyRetrievableFile_descriptor_;
  metadata.reflection = MasterKeyRetrievableFile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InnerRetrievable::kMasterKeyFieldNumber;
const int InnerRetrievable::kDOWNLOADSECRETFieldNumber;
#endif  // !_MSC_VER

InnerRetrievable::InnerRetrievable()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.InnerRetrievable)
}

void InnerRetrievable::InitAsDefaultInstance() {
}

InnerRetrievable::InnerRetrievable(const InnerRetrievable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.InnerRetrievable)
}

void InnerRetrievable::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  master_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  downloadsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InnerRetrievable::~InnerRetrievable() {
  // @@protoc_insertion_point(destructor:pamrac.InnerRetrievable)
  SharedDtor();
}

void InnerRetrievable::SharedDtor() {
  if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_key_;
  }
  if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete downloadsecret_;
  }
  if (this != default_instance_) {
  }
}

void InnerRetrievable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InnerRetrievable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InnerRetrievable_descriptor_;
}

const InnerRetrievable& InnerRetrievable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

InnerRetrievable* InnerRetrievable::default_instance_ = NULL;

InnerRetrievable* InnerRetrievable::New() const {
  return new InnerRetrievable;
}

void InnerRetrievable::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_master_key()) {
      if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        master_key_->clear();
      }
    }
    if (has_downloadsecret()) {
      if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        downloadsecret_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InnerRetrievable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.InnerRetrievable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes master_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_master_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_DOWNLOADSECRET;
        break;
      }

      // required bytes DOWNLOADSECRET = 2;
      case 2: {
        if (tag == 18) {
         parse_DOWNLOADSECRET:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_downloadsecret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.InnerRetrievable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.InnerRetrievable)
  return false;
#undef DO_
}

void InnerRetrievable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.InnerRetrievable)
  // required bytes master_key = 1;
  if (has_master_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->master_key(), output);
  }

  // required bytes DOWNLOADSECRET = 2;
  if (has_downloadsecret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->downloadsecret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.InnerRetrievable)
}

::google::protobuf::uint8* InnerRetrievable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.InnerRetrievable)
  // required bytes master_key = 1;
  if (has_master_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->master_key(), target);
  }

  // required bytes DOWNLOADSECRET = 2;
  if (has_downloadsecret()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->downloadsecret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.InnerRetrievable)
  return target;
}

int InnerRetrievable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes master_key = 1;
    if (has_master_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->master_key());
    }

    // required bytes DOWNLOADSECRET = 2;
    if (has_downloadsecret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->downloadsecret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InnerRetrievable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InnerRetrievable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InnerRetrievable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InnerRetrievable::MergeFrom(const InnerRetrievable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master_key()) {
      set_master_key(from.master_key());
    }
    if (from.has_downloadsecret()) {
      set_downloadsecret(from.downloadsecret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InnerRetrievable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InnerRetrievable::CopyFrom(const InnerRetrievable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InnerRetrievable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void InnerRetrievable::Swap(InnerRetrievable* other) {
  if (other != this) {
    std::swap(master_key_, other->master_key_);
    std::swap(downloadsecret_, other->downloadsecret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InnerRetrievable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InnerRetrievable_descriptor_;
  metadata.reflection = InnerRetrievable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InitBlobRequest::kAllHashXorFieldNumber;
#endif  // !_MSC_VER

InitBlobRequest::InitBlobRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.InitBlobRequest)
}

void InitBlobRequest::InitAsDefaultInstance() {
}

InitBlobRequest::InitBlobRequest(const InitBlobRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.InitBlobRequest)
}

void InitBlobRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  all_hash_xor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitBlobRequest::~InitBlobRequest() {
  // @@protoc_insertion_point(destructor:pamrac.InitBlobRequest)
  SharedDtor();
}

void InitBlobRequest::SharedDtor() {
  if (all_hash_xor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete all_hash_xor_;
  }
  if (this != default_instance_) {
  }
}

void InitBlobRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InitBlobRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InitBlobRequest_descriptor_;
}

const InitBlobRequest& InitBlobRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

InitBlobRequest* InitBlobRequest::default_instance_ = NULL;

InitBlobRequest* InitBlobRequest::New() const {
  return new InitBlobRequest;
}

void InitBlobRequest::Clear() {
  if (has_all_hash_xor()) {
    if (all_hash_xor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      all_hash_xor_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InitBlobRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.InitBlobRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes all_hash_xor = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_all_hash_xor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.InitBlobRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.InitBlobRequest)
  return false;
#undef DO_
}

void InitBlobRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.InitBlobRequest)
  // required bytes all_hash_xor = 1;
  if (has_all_hash_xor()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->all_hash_xor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.InitBlobRequest)
}

::google::protobuf::uint8* InitBlobRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.InitBlobRequest)
  // required bytes all_hash_xor = 1;
  if (has_all_hash_xor()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->all_hash_xor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.InitBlobRequest)
  return target;
}

int InitBlobRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes all_hash_xor = 1;
    if (has_all_hash_xor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->all_hash_xor());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitBlobRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InitBlobRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InitBlobRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InitBlobRequest::MergeFrom(const InitBlobRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_all_hash_xor()) {
      set_all_hash_xor(from.all_hash_xor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InitBlobRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitBlobRequest::CopyFrom(const InitBlobRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitBlobRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void InitBlobRequest::Swap(InitBlobRequest* other) {
  if (other != this) {
    std::swap(all_hash_xor_, other->all_hash_xor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InitBlobRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InitBlobRequest_descriptor_;
  metadata.reflection = InitBlobRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InitBlobResponse::kXorMatchesFieldNumber;
const int InitBlobResponse::kNonceFieldNumber;
#endif  // !_MSC_VER

InitBlobResponse::InitBlobResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.InitBlobResponse)
}

void InitBlobResponse::InitAsDefaultInstance() {
}

InitBlobResponse::InitBlobResponse(const InitBlobResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.InitBlobResponse)
}

void InitBlobResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  xor_matches_ = false;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitBlobResponse::~InitBlobResponse() {
  // @@protoc_insertion_point(destructor:pamrac.InitBlobResponse)
  SharedDtor();
}

void InitBlobResponse::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (this != default_instance_) {
  }
}

void InitBlobResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InitBlobResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InitBlobResponse_descriptor_;
}

const InitBlobResponse& InitBlobResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

InitBlobResponse* InitBlobResponse::default_instance_ = NULL;

InitBlobResponse* InitBlobResponse::New() const {
  return new InitBlobResponse;
}

void InitBlobResponse::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    xor_matches_ = false;
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nonce_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InitBlobResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.InitBlobResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool xor_matches = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &xor_matches_)));
          set_has_xor_matches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nonce;
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (tag == 18) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.InitBlobResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.InitBlobResponse)
  return false;
#undef DO_
}

void InitBlobResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.InitBlobResponse)
  // required bool xor_matches = 1;
  if (has_xor_matches()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->xor_matches(), output);
  }

  // optional bytes nonce = 2;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.InitBlobResponse)
}

::google::protobuf::uint8* InitBlobResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.InitBlobResponse)
  // required bool xor_matches = 1;
  if (has_xor_matches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->xor_matches(), target);
  }

  // optional bytes nonce = 2;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.InitBlobResponse)
  return target;
}

int InitBlobResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool xor_matches = 1;
    if (has_xor_matches()) {
      total_size += 1 + 1;
    }

    // optional bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitBlobResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InitBlobResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InitBlobResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InitBlobResponse::MergeFrom(const InitBlobResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xor_matches()) {
      set_xor_matches(from.xor_matches());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InitBlobResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitBlobResponse::CopyFrom(const InitBlobResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitBlobResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void InitBlobResponse::Swap(InitBlobResponse* other) {
  if (other != this) {
    std::swap(xor_matches_, other->xor_matches_);
    std::swap(nonce_, other->nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InitBlobResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InitBlobResponse_descriptor_;
  metadata.reflection = InitBlobResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlobRequest_BlobHash::kBlobNameFieldNumber;
const int BlobRequest_BlobHash::kBlobHashFieldNumber;
#endif  // !_MSC_VER

BlobRequest_BlobHash::BlobRequest_BlobHash()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.BlobRequest.BlobHash)
}

void BlobRequest_BlobHash::InitAsDefaultInstance() {
}

BlobRequest_BlobHash::BlobRequest_BlobHash(const BlobRequest_BlobHash& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.BlobRequest.BlobHash)
}

void BlobRequest_BlobHash::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  blob_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  blob_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlobRequest_BlobHash::~BlobRequest_BlobHash() {
  // @@protoc_insertion_point(destructor:pamrac.BlobRequest.BlobHash)
  SharedDtor();
}

void BlobRequest_BlobHash::SharedDtor() {
  if (blob_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_name_;
  }
  if (blob_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_hash_;
  }
  if (this != default_instance_) {
  }
}

void BlobRequest_BlobHash::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlobRequest_BlobHash::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlobRequest_BlobHash_descriptor_;
}

const BlobRequest_BlobHash& BlobRequest_BlobHash::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

BlobRequest_BlobHash* BlobRequest_BlobHash::default_instance_ = NULL;

BlobRequest_BlobHash* BlobRequest_BlobHash::New() const {
  return new BlobRequest_BlobHash;
}

void BlobRequest_BlobHash::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_blob_name()) {
      if (blob_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        blob_name_->clear();
      }
    }
    if (has_blob_hash()) {
      if (blob_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        blob_hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlobRequest_BlobHash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.BlobRequest.BlobHash)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string blob_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_blob_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->blob_name().data(), this->blob_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "blob_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_blob_hash;
        break;
      }

      // required bytes blob_hash = 2;
      case 2: {
        if (tag == 18) {
         parse_blob_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_blob_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.BlobRequest.BlobHash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.BlobRequest.BlobHash)
  return false;
#undef DO_
}

void BlobRequest_BlobHash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.BlobRequest.BlobHash)
  // required string blob_name = 1;
  if (has_blob_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->blob_name().data(), this->blob_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "blob_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->blob_name(), output);
  }

  // required bytes blob_hash = 2;
  if (has_blob_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->blob_hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.BlobRequest.BlobHash)
}

::google::protobuf::uint8* BlobRequest_BlobHash::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.BlobRequest.BlobHash)
  // required string blob_name = 1;
  if (has_blob_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->blob_name().data(), this->blob_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "blob_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->blob_name(), target);
  }

  // required bytes blob_hash = 2;
  if (has_blob_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->blob_hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.BlobRequest.BlobHash)
  return target;
}

int BlobRequest_BlobHash::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string blob_name = 1;
    if (has_blob_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->blob_name());
    }

    // required bytes blob_hash = 2;
    if (has_blob_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->blob_hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlobRequest_BlobHash::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlobRequest_BlobHash* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlobRequest_BlobHash*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlobRequest_BlobHash::MergeFrom(const BlobRequest_BlobHash& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_blob_name()) {
      set_blob_name(from.blob_name());
    }
    if (from.has_blob_hash()) {
      set_blob_hash(from.blob_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlobRequest_BlobHash::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobRequest_BlobHash::CopyFrom(const BlobRequest_BlobHash& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobRequest_BlobHash::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BlobRequest_BlobHash::Swap(BlobRequest_BlobHash* other) {
  if (other != this) {
    std::swap(blob_name_, other->blob_name_);
    std::swap(blob_hash_, other->blob_hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlobRequest_BlobHash::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlobRequest_BlobHash_descriptor_;
  metadata.reflection = BlobRequest_BlobHash_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BlobRequest::kCachedBlobsFieldNumber;
const int BlobRequest::kDownloadsecretProofFieldNumber;
const int BlobRequest::kProofNonceFieldNumber;
#endif  // !_MSC_VER

BlobRequest::BlobRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.BlobRequest)
}

void BlobRequest::InitAsDefaultInstance() {
}

BlobRequest::BlobRequest(const BlobRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.BlobRequest)
}

void BlobRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  downloadsecret_proof_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  proof_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlobRequest::~BlobRequest() {
  // @@protoc_insertion_point(destructor:pamrac.BlobRequest)
  SharedDtor();
}

void BlobRequest::SharedDtor() {
  if (downloadsecret_proof_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete downloadsecret_proof_;
  }
  if (proof_nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete proof_nonce_;
  }
  if (this != default_instance_) {
  }
}

void BlobRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlobRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlobRequest_descriptor_;
}

const BlobRequest& BlobRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

BlobRequest* BlobRequest::default_instance_ = NULL;

BlobRequest* BlobRequest::New() const {
  return new BlobRequest;
}

void BlobRequest::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    if (has_downloadsecret_proof()) {
      if (downloadsecret_proof_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        downloadsecret_proof_->clear();
      }
    }
    if (has_proof_nonce()) {
      if (proof_nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        proof_nonce_->clear();
      }
    }
  }
  cached_blobs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlobRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.BlobRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pamrac.BlobRequest.BlobHash cached_blobs = 1;
      case 1: {
        if (tag == 10) {
         parse_cached_blobs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cached_blobs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_cached_blobs;
        if (input->ExpectTag(18)) goto parse_downloadsecret_proof;
        break;
      }

      // required bytes downloadsecret_proof = 2;
      case 2: {
        if (tag == 18) {
         parse_downloadsecret_proof:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_downloadsecret_proof()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_proof_nonce;
        break;
      }

      // required bytes proof_nonce = 3;
      case 3: {
        if (tag == 26) {
         parse_proof_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_proof_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.BlobRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.BlobRequest)
  return false;
#undef DO_
}

void BlobRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.BlobRequest)
  // repeated .pamrac.BlobRequest.BlobHash cached_blobs = 1;
  for (int i = 0; i < this->cached_blobs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cached_blobs(i), output);
  }

  // required bytes downloadsecret_proof = 2;
  if (has_downloadsecret_proof()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->downloadsecret_proof(), output);
  }

  // required bytes proof_nonce = 3;
  if (has_proof_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->proof_nonce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.BlobRequest)
}

::google::protobuf::uint8* BlobRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.BlobRequest)
  // repeated .pamrac.BlobRequest.BlobHash cached_blobs = 1;
  for (int i = 0; i < this->cached_blobs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cached_blobs(i), target);
  }

  // required bytes downloadsecret_proof = 2;
  if (has_downloadsecret_proof()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->downloadsecret_proof(), target);
  }

  // required bytes proof_nonce = 3;
  if (has_proof_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->proof_nonce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.BlobRequest)
  return target;
}

int BlobRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes downloadsecret_proof = 2;
    if (has_downloadsecret_proof()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->downloadsecret_proof());
    }

    // required bytes proof_nonce = 3;
    if (has_proof_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->proof_nonce());
    }

  }
  // repeated .pamrac.BlobRequest.BlobHash cached_blobs = 1;
  total_size += 1 * this->cached_blobs_size();
  for (int i = 0; i < this->cached_blobs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cached_blobs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlobRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlobRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlobRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlobRequest::MergeFrom(const BlobRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  cached_blobs_.MergeFrom(from.cached_blobs_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_downloadsecret_proof()) {
      set_downloadsecret_proof(from.downloadsecret_proof());
    }
    if (from.has_proof_nonce()) {
      set_proof_nonce(from.proof_nonce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlobRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobRequest::CopyFrom(const BlobRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->cached_blobs())) return false;
  return true;
}

void BlobRequest::Swap(BlobRequest* other) {
  if (other != this) {
    cached_blobs_.Swap(&other->cached_blobs_);
    std::swap(downloadsecret_proof_, other->downloadsecret_proof_);
    std::swap(proof_nonce_, other->proof_nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlobRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlobRequest_descriptor_;
  metadata.reflection = BlobRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlobResponse::kNewBlobsFieldNumber;
#endif  // !_MSC_VER

BlobResponse::BlobResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.BlobResponse)
}

void BlobResponse::InitAsDefaultInstance() {
}

BlobResponse::BlobResponse(const BlobResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.BlobResponse)
}

void BlobResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlobResponse::~BlobResponse() {
  // @@protoc_insertion_point(destructor:pamrac.BlobResponse)
  SharedDtor();
}

void BlobResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BlobResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlobResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlobResponse_descriptor_;
}

const BlobResponse& BlobResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

BlobResponse* BlobResponse::default_instance_ = NULL;

BlobResponse* BlobResponse::New() const {
  return new BlobResponse;
}

void BlobResponse::Clear() {
  new_blobs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlobResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.BlobResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pamrac.BlobFile new_blobs = 1;
      case 1: {
        if (tag == 10) {
         parse_new_blobs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_new_blobs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_new_blobs;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.BlobResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.BlobResponse)
  return false;
#undef DO_
}

void BlobResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.BlobResponse)
  // repeated .pamrac.BlobFile new_blobs = 1;
  for (int i = 0; i < this->new_blobs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->new_blobs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.BlobResponse)
}

::google::protobuf::uint8* BlobResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.BlobResponse)
  // repeated .pamrac.BlobFile new_blobs = 1;
  for (int i = 0; i < this->new_blobs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->new_blobs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.BlobResponse)
  return target;
}

int BlobResponse::ByteSize() const {
  int total_size = 0;

  // repeated .pamrac.BlobFile new_blobs = 1;
  total_size += 1 * this->new_blobs_size();
  for (int i = 0; i < this->new_blobs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->new_blobs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlobResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlobResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlobResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlobResponse::MergeFrom(const BlobResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  new_blobs_.MergeFrom(from.new_blobs_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlobResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobResponse::CopyFrom(const BlobResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->new_blobs())) return false;
  return true;
}

void BlobResponse::Swap(BlobResponse* other) {
  if (other != this) {
    new_blobs_.Swap(&other->new_blobs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlobResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlobResponse_descriptor_;
  metadata.reflection = BlobResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlobUpload::kHashedFilenameFieldNumber;
const int BlobUpload::kBlobFieldNumber;
const int BlobUpload::kNonceFieldNumber;
const int BlobUpload::kSignatureFieldNumber;
#endif  // !_MSC_VER

BlobUpload::BlobUpload()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.BlobUpload)
}

void BlobUpload::InitAsDefaultInstance() {
  blob_ = const_cast< ::pamrac::BlobFile*>(&::pamrac::BlobFile::default_instance());
}

BlobUpload::BlobUpload(const BlobUpload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.BlobUpload)
}

void BlobUpload::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hashed_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  blob_ = NULL;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlobUpload::~BlobUpload() {
  // @@protoc_insertion_point(destructor:pamrac.BlobUpload)
  SharedDtor();
}

void BlobUpload::SharedDtor() {
  if (hashed_filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hashed_filename_;
  }
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
    delete blob_;
  }
}

void BlobUpload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlobUpload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlobUpload_descriptor_;
}

const BlobUpload& BlobUpload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

BlobUpload* BlobUpload::default_instance_ = NULL;

BlobUpload* BlobUpload::New() const {
  return new BlobUpload;
}

void BlobUpload::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_hashed_filename()) {
      if (hashed_filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hashed_filename_->clear();
      }
    }
    if (has_blob()) {
      if (blob_ != NULL) blob_->::pamrac::BlobFile::Clear();
    }
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nonce_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlobUpload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.BlobUpload)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string hashed_filename = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hashed_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hashed_filename().data(), this->hashed_filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hashed_filename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_blob;
        break;
      }

      // required .pamrac.BlobFile blob = 2;
      case 2: {
        if (tag == 18) {
         parse_blob:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blob()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 3;
      case 3: {
        if (tag == 26) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // required bytes signature = 4;
      case 4: {
        if (tag == 34) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.BlobUpload)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.BlobUpload)
  return false;
#undef DO_
}

void BlobUpload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.BlobUpload)
  // required string hashed_filename = 1;
  if (has_hashed_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hashed_filename().data(), this->hashed_filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hashed_filename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hashed_filename(), output);
  }

  // required .pamrac.BlobFile blob = 2;
  if (has_blob()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->blob(), output);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->nonce(), output);
  }

  // required bytes signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.BlobUpload)
}

::google::protobuf::uint8* BlobUpload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.BlobUpload)
  // required string hashed_filename = 1;
  if (has_hashed_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hashed_filename().data(), this->hashed_filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hashed_filename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hashed_filename(), target);
  }

  // required .pamrac.BlobFile blob = 2;
  if (has_blob()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->blob(), target);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nonce(), target);
  }

  // required bytes signature = 4;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.BlobUpload)
  return target;
}

int BlobUpload::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string hashed_filename = 1;
    if (has_hashed_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hashed_filename());
    }

    // required .pamrac.BlobFile blob = 2;
    if (has_blob()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->blob());
    }

    // required bytes nonce = 3;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // required bytes signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlobUpload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlobUpload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlobUpload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlobUpload::MergeFrom(const BlobUpload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hashed_filename()) {
      set_hashed_filename(from.hashed_filename());
    }
    if (from.has_blob()) {
      mutable_blob()->::pamrac::BlobFile::MergeFrom(from.blob());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlobUpload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobUpload::CopyFrom(const BlobUpload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobUpload::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_blob()) {
    if (!this->blob().IsInitialized()) return false;
  }
  return true;
}

void BlobUpload::Swap(BlobUpload* other) {
  if (other != this) {
    std::swap(hashed_filename_, other->hashed_filename_);
    std::swap(blob_, other->blob_);
    std::swap(nonce_, other->nonce_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlobUpload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlobUpload_descriptor_;
  metadata.reflection = BlobUpload_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlobUploadResult::kVerificationOkFieldNumber;
const int BlobUploadResult::kUploadSuccessfulFieldNumber;
const int BlobUploadResult::kServerVersionFieldNumber;
#endif  // !_MSC_VER

BlobUploadResult::BlobUploadResult()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.BlobUploadResult)
}

void BlobUploadResult::InitAsDefaultInstance() {
}

BlobUploadResult::BlobUploadResult(const BlobUploadResult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.BlobUploadResult)
}

void BlobUploadResult::SharedCtor() {
  _cached_size_ = 0;
  verification_ok_ = false;
  upload_successful_ = false;
  server_version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlobUploadResult::~BlobUploadResult() {
  // @@protoc_insertion_point(destructor:pamrac.BlobUploadResult)
  SharedDtor();
}

void BlobUploadResult::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BlobUploadResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlobUploadResult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlobUploadResult_descriptor_;
}

const BlobUploadResult& BlobUploadResult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

BlobUploadResult* BlobUploadResult::default_instance_ = NULL;

BlobUploadResult* BlobUploadResult::New() const {
  return new BlobUploadResult;
}

void BlobUploadResult::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BlobUploadResult*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(verification_ok_, server_version_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlobUploadResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.BlobUploadResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool verification_ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &verification_ok_)));
          set_has_verification_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_upload_successful;
        break;
      }

      // optional bool upload_successful = 2;
      case 2: {
        if (tag == 16) {
         parse_upload_successful:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &upload_successful_)));
          set_has_upload_successful();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_server_version;
        break;
      }

      // optional int32 server_version = 3;
      case 3: {
        if (tag == 24) {
         parse_server_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &server_version_)));
          set_has_server_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.BlobUploadResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.BlobUploadResult)
  return false;
#undef DO_
}

void BlobUploadResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.BlobUploadResult)
  // required bool verification_ok = 1;
  if (has_verification_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->verification_ok(), output);
  }

  // optional bool upload_successful = 2;
  if (has_upload_successful()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->upload_successful(), output);
  }

  // optional int32 server_version = 3;
  if (has_server_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->server_version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.BlobUploadResult)
}

::google::protobuf::uint8* BlobUploadResult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.BlobUploadResult)
  // required bool verification_ok = 1;
  if (has_verification_ok()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->verification_ok(), target);
  }

  // optional bool upload_successful = 2;
  if (has_upload_successful()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->upload_successful(), target);
  }

  // optional int32 server_version = 3;
  if (has_server_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->server_version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.BlobUploadResult)
  return target;
}

int BlobUploadResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool verification_ok = 1;
    if (has_verification_ok()) {
      total_size += 1 + 1;
    }

    // optional bool upload_successful = 2;
    if (has_upload_successful()) {
      total_size += 1 + 1;
    }

    // optional int32 server_version = 3;
    if (has_server_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->server_version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlobUploadResult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlobUploadResult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlobUploadResult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlobUploadResult::MergeFrom(const BlobUploadResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_verification_ok()) {
      set_verification_ok(from.verification_ok());
    }
    if (from.has_upload_successful()) {
      set_upload_successful(from.upload_successful());
    }
    if (from.has_server_version()) {
      set_server_version(from.server_version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlobUploadResult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobUploadResult::CopyFrom(const BlobUploadResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobUploadResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BlobUploadResult::Swap(BlobUploadResult* other) {
  if (other != this) {
    std::swap(verification_ok_, other->verification_ok_);
    std::swap(upload_successful_, other->upload_successful_);
    std::swap(server_version_, other->server_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlobUploadResult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlobUploadResult_descriptor_;
  metadata.reflection = BlobUploadResult_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShareListRequest::kRequesterFingerprintFieldNumber;
const int ShareListRequest::kNonceFieldNumber;
const int ShareListRequest::kSignatureFieldNumber;
#endif  // !_MSC_VER

ShareListRequest::ShareListRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareListRequest)
}

void ShareListRequest::InitAsDefaultInstance() {
}

ShareListRequest::ShareListRequest(const ShareListRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareListRequest)
}

void ShareListRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  requester_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareListRequest::~ShareListRequest() {
  // @@protoc_insertion_point(destructor:pamrac.ShareListRequest)
  SharedDtor();
}

void ShareListRequest::SharedDtor() {
  if (requester_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requester_fingerprint_;
  }
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void ShareListRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareListRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareListRequest_descriptor_;
}

const ShareListRequest& ShareListRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareListRequest* ShareListRequest::default_instance_ = NULL;

ShareListRequest* ShareListRequest::New() const {
  return new ShareListRequest;
}

void ShareListRequest::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_requester_fingerprint()) {
      if (requester_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        requester_fingerprint_->clear();
      }
    }
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nonce_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareListRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareListRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes requester_fingerprint = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_requester_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 2;
      case 2: {
        if (tag == 18) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_signature;
        break;
      }

      // required bytes signature = 3;
      case 3: {
        if (tag == 26) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareListRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareListRequest)
  return false;
#undef DO_
}

void ShareListRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareListRequest)
  // required bytes requester_fingerprint = 1;
  if (has_requester_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->requester_fingerprint(), output);
  }

  // required bytes nonce = 2;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareListRequest)
}

::google::protobuf::uint8* ShareListRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareListRequest)
  // required bytes requester_fingerprint = 1;
  if (has_requester_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->requester_fingerprint(), target);
  }

  // required bytes nonce = 2;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareListRequest)
  return target;
}

int ShareListRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes requester_fingerprint = 1;
    if (has_requester_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->requester_fingerprint());
    }

    // required bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // required bytes signature = 3;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareListRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareListRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareListRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareListRequest::MergeFrom(const ShareListRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_requester_fingerprint()) {
      set_requester_fingerprint(from.requester_fingerprint());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareListRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareListRequest::CopyFrom(const ShareListRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareListRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ShareListRequest::Swap(ShareListRequest* other) {
  if (other != this) {
    std::swap(requester_fingerprint_, other->requester_fingerprint_);
    std::swap(nonce_, other->nonce_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareListRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareListRequest_descriptor_;
  metadata.reflection = ShareListRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShareList_ShareRecipient::kNicknameFieldNumber;
const int ShareList_ShareRecipient::kFingerprintFieldNumber;
const int ShareList_ShareRecipient::kInitiatorFieldNumber;
#endif  // !_MSC_VER

ShareList_ShareRecipient::ShareList_ShareRecipient()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareList.ShareRecipient)
}

void ShareList_ShareRecipient::InitAsDefaultInstance() {
}

ShareList_ShareRecipient::ShareList_ShareRecipient(const ShareList_ShareRecipient& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareList.ShareRecipient)
}

void ShareList_ShareRecipient::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  initiator_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareList_ShareRecipient::~ShareList_ShareRecipient() {
  // @@protoc_insertion_point(destructor:pamrac.ShareList.ShareRecipient)
  SharedDtor();
}

void ShareList_ShareRecipient::SharedDtor() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fingerprint_;
  }
  if (this != default_instance_) {
  }
}

void ShareList_ShareRecipient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareList_ShareRecipient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareList_ShareRecipient_descriptor_;
}

const ShareList_ShareRecipient& ShareList_ShareRecipient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareList_ShareRecipient* ShareList_ShareRecipient::default_instance_ = NULL;

ShareList_ShareRecipient* ShareList_ShareRecipient::New() const {
  return new ShareList_ShareRecipient;
}

void ShareList_ShareRecipient::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nickname_->clear();
      }
    }
    if (has_fingerprint()) {
      if (fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        fingerprint_->clear();
      }
    }
    initiator_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareList_ShareRecipient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareList.ShareRecipient)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string nickname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->nickname().data(), this->nickname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "nickname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_fingerprint;
        break;
      }

      // required bytes fingerprint = 2;
      case 2: {
        if (tag == 18) {
         parse_fingerprint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_initiator;
        break;
      }

      // required bool initiator = 3;
      case 3: {
        if (tag == 24) {
         parse_initiator:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &initiator_)));
          set_has_initiator();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareList.ShareRecipient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareList.ShareRecipient)
  return false;
#undef DO_
}

void ShareList_ShareRecipient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareList.ShareRecipient)
  // optional string nickname = 1;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nickname().data(), this->nickname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "nickname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->nickname(), output);
  }

  // required bytes fingerprint = 2;
  if (has_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->fingerprint(), output);
  }

  // required bool initiator = 3;
  if (has_initiator()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->initiator(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareList.ShareRecipient)
}

::google::protobuf::uint8* ShareList_ShareRecipient::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareList.ShareRecipient)
  // optional string nickname = 1;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nickname().data(), this->nickname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "nickname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->nickname(), target);
  }

  // required bytes fingerprint = 2;
  if (has_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->fingerprint(), target);
  }

  // required bool initiator = 3;
  if (has_initiator()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->initiator(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareList.ShareRecipient)
  return target;
}

int ShareList_ShareRecipient::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string nickname = 1;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

    // required bytes fingerprint = 2;
    if (has_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fingerprint());
    }

    // required bool initiator = 3;
    if (has_initiator()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareList_ShareRecipient::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareList_ShareRecipient* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareList_ShareRecipient*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareList_ShareRecipient::MergeFrom(const ShareList_ShareRecipient& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
    if (from.has_fingerprint()) {
      set_fingerprint(from.fingerprint());
    }
    if (from.has_initiator()) {
      set_initiator(from.initiator());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareList_ShareRecipient::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareList_ShareRecipient::CopyFrom(const ShareList_ShareRecipient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareList_ShareRecipient::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  return true;
}

void ShareList_ShareRecipient::Swap(ShareList_ShareRecipient* other) {
  if (other != this) {
    std::swap(nickname_, other->nickname_);
    std::swap(fingerprint_, other->fingerprint_);
    std::swap(initiator_, other->initiator_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareList_ShareRecipient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareList_ShareRecipient_descriptor_;
  metadata.reflection = ShareList_ShareRecipient_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ShareList::kTimestampFieldNumber;
const int ShareList::kThresholdFieldNumber;
const int ShareList::kRecipientsFieldNumber;
const int ShareList::kSignatureFieldNumber;
#endif  // !_MSC_VER

ShareList::ShareList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareList)
}

void ShareList::InitAsDefaultInstance() {
}

ShareList::ShareList(const ShareList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareList)
}

void ShareList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  threshold_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareList::~ShareList() {
  // @@protoc_insertion_point(destructor:pamrac.ShareList)
  SharedDtor();
}

void ShareList::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void ShareList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareList_descriptor_;
}

const ShareList& ShareList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareList* ShareList::default_instance_ = NULL;

ShareList* ShareList::New() const {
  return new ShareList;
}

void ShareList::Clear() {
  if (_has_bits_[0 / 32] & 11) {
    timestamp_ = GOOGLE_LONGLONG(0);
    threshold_ = 0;
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  recipients_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 timestamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_threshold;
        break;
      }

      // required int32 threshold = 2;
      case 2: {
        if (tag == 16) {
         parse_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &threshold_)));
          set_has_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_recipients;
        break;
      }

      // repeated .pamrac.ShareList.ShareRecipient recipients = 3;
      case 3: {
        if (tag == 26) {
         parse_recipients:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_recipients()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_recipients;
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // required bytes signature = 4;
      case 4: {
        if (tag == 34) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareList)
  return false;
#undef DO_
}

void ShareList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareList)
  // required int64 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->timestamp(), output);
  }

  // required int32 threshold = 2;
  if (has_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->threshold(), output);
  }

  // repeated .pamrac.ShareList.ShareRecipient recipients = 3;
  for (int i = 0; i < this->recipients_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->recipients(i), output);
  }

  // required bytes signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareList)
}

::google::protobuf::uint8* ShareList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareList)
  // required int64 timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->timestamp(), target);
  }

  // required int32 threshold = 2;
  if (has_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->threshold(), target);
  }

  // repeated .pamrac.ShareList.ShareRecipient recipients = 3;
  for (int i = 0; i < this->recipients_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->recipients(i), target);
  }

  // required bytes signature = 4;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareList)
  return target;
}

int ShareList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // required int32 threshold = 2;
    if (has_threshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->threshold());
    }

    // required bytes signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  // repeated .pamrac.ShareList.ShareRecipient recipients = 3;
  total_size += 1 * this->recipients_size();
  for (int i = 0; i < this->recipients_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->recipients(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareList::MergeFrom(const ShareList& from) {
  GOOGLE_CHECK_NE(&from, this);
  recipients_.MergeFrom(from.recipients_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_threshold()) {
      set_threshold(from.threshold());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareList::CopyFrom(const ShareList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareList::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->recipients())) return false;
  return true;
}

void ShareList::Swap(ShareList* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(threshold_, other->threshold_);
    recipients_.Swap(&other->recipients_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareList_descriptor_;
  metadata.reflection = ShareList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShareID::kOriginatorFingerprintFieldNumber;
const int ShareID::kOwnerFingerprintFieldNumber;
const int ShareID::kEncryptedToFingerprintFieldNumber;
#endif  // !_MSC_VER

ShareID::ShareID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareID)
}

void ShareID::InitAsDefaultInstance() {
}

ShareID::ShareID(const ShareID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareID)
}

void ShareID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  originator_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  owner_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  encrypted_to_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareID::~ShareID() {
  // @@protoc_insertion_point(destructor:pamrac.ShareID)
  SharedDtor();
}

void ShareID::SharedDtor() {
  if (originator_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete originator_fingerprint_;
  }
  if (owner_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_fingerprint_;
  }
  if (encrypted_to_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypted_to_fingerprint_;
  }
  if (this != default_instance_) {
  }
}

void ShareID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareID_descriptor_;
}

const ShareID& ShareID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareID* ShareID::default_instance_ = NULL;

ShareID* ShareID::New() const {
  return new ShareID;
}

void ShareID::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_originator_fingerprint()) {
      if (originator_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        originator_fingerprint_->clear();
      }
    }
    if (has_owner_fingerprint()) {
      if (owner_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        owner_fingerprint_->clear();
      }
    }
    if (has_encrypted_to_fingerprint()) {
      if (encrypted_to_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        encrypted_to_fingerprint_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes originator_fingerprint = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_originator_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_owner_fingerprint;
        break;
      }

      // required bytes owner_fingerprint = 2;
      case 2: {
        if (tag == 18) {
         parse_owner_fingerprint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_owner_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_encrypted_to_fingerprint;
        break;
      }

      // required bytes encrypted_to_fingerprint = 3;
      case 3: {
        if (tag == 26) {
         parse_encrypted_to_fingerprint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_to_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareID)
  return false;
#undef DO_
}

void ShareID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareID)
  // required bytes originator_fingerprint = 1;
  if (has_originator_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->originator_fingerprint(), output);
  }

  // required bytes owner_fingerprint = 2;
  if (has_owner_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->owner_fingerprint(), output);
  }

  // required bytes encrypted_to_fingerprint = 3;
  if (has_encrypted_to_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->encrypted_to_fingerprint(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareID)
}

::google::protobuf::uint8* ShareID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareID)
  // required bytes originator_fingerprint = 1;
  if (has_originator_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->originator_fingerprint(), target);
  }

  // required bytes owner_fingerprint = 2;
  if (has_owner_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->owner_fingerprint(), target);
  }

  // required bytes encrypted_to_fingerprint = 3;
  if (has_encrypted_to_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->encrypted_to_fingerprint(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareID)
  return target;
}

int ShareID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes originator_fingerprint = 1;
    if (has_originator_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->originator_fingerprint());
    }

    // required bytes owner_fingerprint = 2;
    if (has_owner_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->owner_fingerprint());
    }

    // required bytes encrypted_to_fingerprint = 3;
    if (has_encrypted_to_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_to_fingerprint());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareID::MergeFrom(const ShareID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_originator_fingerprint()) {
      set_originator_fingerprint(from.originator_fingerprint());
    }
    if (from.has_owner_fingerprint()) {
      set_owner_fingerprint(from.owner_fingerprint());
    }
    if (from.has_encrypted_to_fingerprint()) {
      set_encrypted_to_fingerprint(from.encrypted_to_fingerprint());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareID::CopyFrom(const ShareID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ShareID::Swap(ShareID* other) {
  if (other != this) {
    std::swap(originator_fingerprint_, other->originator_fingerprint_);
    std::swap(owner_fingerprint_, other->owner_fingerprint_);
    std::swap(encrypted_to_fingerprint_, other->encrypted_to_fingerprint_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareID_descriptor_;
  metadata.reflection = ShareID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShareRequest::kShareIdFieldNumber;
const int ShareRequest::kNonceFieldNumber;
const int ShareRequest::kSignatureFieldNumber;
#endif  // !_MSC_VER

ShareRequest::ShareRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareRequest)
}

void ShareRequest::InitAsDefaultInstance() {
  share_id_ = const_cast< ::pamrac::ShareID*>(&::pamrac::ShareID::default_instance());
}

ShareRequest::ShareRequest(const ShareRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareRequest)
}

void ShareRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  share_id_ = NULL;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareRequest::~ShareRequest() {
  // @@protoc_insertion_point(destructor:pamrac.ShareRequest)
  SharedDtor();
}

void ShareRequest::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
    delete share_id_;
  }
}

void ShareRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareRequest_descriptor_;
}

const ShareRequest& ShareRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareRequest* ShareRequest::default_instance_ = NULL;

ShareRequest* ShareRequest::New() const {
  return new ShareRequest;
}

void ShareRequest::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_share_id()) {
      if (share_id_ != NULL) share_id_->::pamrac::ShareID::Clear();
    }
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nonce_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .pamrac.ShareID share_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 2;
      case 2: {
        if (tag == 18) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_signature;
        break;
      }

      // required bytes signature = 3;
      case 3: {
        if (tag == 26) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareRequest)
  return false;
#undef DO_
}

void ShareRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareRequest)
  // required .pamrac.ShareID share_id = 1;
  if (has_share_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->share_id(), output);
  }

  // required bytes nonce = 2;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareRequest)
}

::google::protobuf::uint8* ShareRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareRequest)
  // required .pamrac.ShareID share_id = 1;
  if (has_share_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->share_id(), target);
  }

  // required bytes nonce = 2;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareRequest)
  return target;
}

int ShareRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .pamrac.ShareID share_id = 1;
    if (has_share_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_id());
    }

    // required bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // required bytes signature = 3;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareRequest::MergeFrom(const ShareRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_share_id()) {
      mutable_share_id()->::pamrac::ShareID::MergeFrom(from.share_id());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareRequest::CopyFrom(const ShareRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_share_id()) {
    if (!this->share_id().IsInitialized()) return false;
  }
  return true;
}

void ShareRequest::Swap(ShareRequest* other) {
  if (other != this) {
    std::swap(share_id_, other->share_id_);
    std::swap(nonce_, other->nonce_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareRequest_descriptor_;
  metadata.reflection = ShareRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyShare::kTimestampFieldNumber;
const int KeyShare::kMasterkeyRetrievableFileFieldNumber;
const int KeyShare::kEncryptedInitiatorMaskFieldNumber;
const int KeyShare::kEncryptedShareFieldNumber;
const int KeyShare::kShareIdFieldNumber;
#endif  // !_MSC_VER

KeyShare::KeyShare()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.KeyShare)
}

void KeyShare::InitAsDefaultInstance() {
  masterkey_retrievable_file_ = const_cast< ::pamrac::MasterKeyRetrievableFile*>(&::pamrac::MasterKeyRetrievableFile::default_instance());
  share_id_ = const_cast< ::pamrac::ShareID*>(&::pamrac::ShareID::default_instance());
}

KeyShare::KeyShare(const KeyShare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.KeyShare)
}

void KeyShare::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  masterkey_retrievable_file_ = NULL;
  encrypted_initiator_mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  encrypted_share_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  share_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyShare::~KeyShare() {
  // @@protoc_insertion_point(destructor:pamrac.KeyShare)
  SharedDtor();
}

void KeyShare::SharedDtor() {
  if (encrypted_initiator_mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypted_initiator_mask_;
  }
  if (encrypted_share_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypted_share_;
  }
  if (this != default_instance_) {
    delete masterkey_retrievable_file_;
    delete share_id_;
  }
}

void KeyShare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyShare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyShare_descriptor_;
}

const KeyShare& KeyShare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

KeyShare* KeyShare::default_instance_ = NULL;

KeyShare* KeyShare::New() const {
  return new KeyShare;
}

void KeyShare::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    timestamp_ = GOOGLE_LONGLONG(0);
    if (has_masterkey_retrievable_file()) {
      if (masterkey_retrievable_file_ != NULL) masterkey_retrievable_file_->::pamrac::MasterKeyRetrievableFile::Clear();
    }
    if (has_encrypted_initiator_mask()) {
      if (encrypted_initiator_mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        encrypted_initiator_mask_->clear();
      }
    }
    if (has_encrypted_share()) {
      if (encrypted_share_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        encrypted_share_->clear();
      }
    }
    if (has_share_id()) {
      if (share_id_ != NULL) share_id_->::pamrac::ShareID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyShare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.KeyShare)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 timestamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_masterkey_retrievable_file;
        break;
      }

      // optional .pamrac.MasterKeyRetrievableFile masterkey_retrievable_file = 2;
      case 2: {
        if (tag == 18) {
         parse_masterkey_retrievable_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_masterkey_retrievable_file()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_encrypted_initiator_mask;
        break;
      }

      // optional bytes encrypted_initiator_mask = 3;
      case 3: {
        if (tag == 26) {
         parse_encrypted_initiator_mask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_initiator_mask()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_encrypted_share;
        break;
      }

      // required bytes encrypted_share = 4;
      case 4: {
        if (tag == 34) {
         parse_encrypted_share:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_share()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_share_id;
        break;
      }

      // required .pamrac.ShareID share_id = 5;
      case 5: {
        if (tag == 42) {
         parse_share_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_share_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.KeyShare)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.KeyShare)
  return false;
#undef DO_
}

void KeyShare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.KeyShare)
  // required int64 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->timestamp(), output);
  }

  // optional .pamrac.MasterKeyRetrievableFile masterkey_retrievable_file = 2;
  if (has_masterkey_retrievable_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->masterkey_retrievable_file(), output);
  }

  // optional bytes encrypted_initiator_mask = 3;
  if (has_encrypted_initiator_mask()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->encrypted_initiator_mask(), output);
  }

  // required bytes encrypted_share = 4;
  if (has_encrypted_share()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->encrypted_share(), output);
  }

  // required .pamrac.ShareID share_id = 5;
  if (has_share_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->share_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.KeyShare)
}

::google::protobuf::uint8* KeyShare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.KeyShare)
  // required int64 timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->timestamp(), target);
  }

  // optional .pamrac.MasterKeyRetrievableFile masterkey_retrievable_file = 2;
  if (has_masterkey_retrievable_file()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->masterkey_retrievable_file(), target);
  }

  // optional bytes encrypted_initiator_mask = 3;
  if (has_encrypted_initiator_mask()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->encrypted_initiator_mask(), target);
  }

  // required bytes encrypted_share = 4;
  if (has_encrypted_share()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->encrypted_share(), target);
  }

  // required .pamrac.ShareID share_id = 5;
  if (has_share_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->share_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.KeyShare)
  return target;
}

int KeyShare::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional .pamrac.MasterKeyRetrievableFile masterkey_retrievable_file = 2;
    if (has_masterkey_retrievable_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->masterkey_retrievable_file());
    }

    // optional bytes encrypted_initiator_mask = 3;
    if (has_encrypted_initiator_mask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_initiator_mask());
    }

    // required bytes encrypted_share = 4;
    if (has_encrypted_share()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_share());
    }

    // required .pamrac.ShareID share_id = 5;
    if (has_share_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->share_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyShare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyShare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyShare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyShare::MergeFrom(const KeyShare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_masterkey_retrievable_file()) {
      mutable_masterkey_retrievable_file()->::pamrac::MasterKeyRetrievableFile::MergeFrom(from.masterkey_retrievable_file());
    }
    if (from.has_encrypted_initiator_mask()) {
      set_encrypted_initiator_mask(from.encrypted_initiator_mask());
    }
    if (from.has_encrypted_share()) {
      set_encrypted_share(from.encrypted_share());
    }
    if (from.has_share_id()) {
      mutable_share_id()->::pamrac::ShareID::MergeFrom(from.share_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyShare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyShare::CopyFrom(const KeyShare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyShare::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;

  if (has_masterkey_retrievable_file()) {
    if (!this->masterkey_retrievable_file().IsInitialized()) return false;
  }
  if (has_share_id()) {
    if (!this->share_id().IsInitialized()) return false;
  }
  return true;
}

void KeyShare::Swap(KeyShare* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(masterkey_retrievable_file_, other->masterkey_retrievable_file_);
    std::swap(encrypted_initiator_mask_, other->encrypted_initiator_mask_);
    std::swap(encrypted_share_, other->encrypted_share_);
    std::swap(share_id_, other->share_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyShare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyShare_descriptor_;
  metadata.reflection = KeyShare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShareUpload::kRevokeIdFieldNumber;
const int ShareUpload::kShareFieldNumber;
const int ShareUpload::kListFieldNumber;
const int ShareUpload::kNonceFieldNumber;
const int ShareUpload::kSignatureFieldNumber;
#endif  // !_MSC_VER

ShareUpload::ShareUpload()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareUpload)
}

void ShareUpload::InitAsDefaultInstance() {
  list_ = const_cast< ::pamrac::ShareList*>(&::pamrac::ShareList::default_instance());
}

ShareUpload::ShareUpload(const ShareUpload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareUpload)
}

void ShareUpload::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  list_ = NULL;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareUpload::~ShareUpload() {
  // @@protoc_insertion_point(destructor:pamrac.ShareUpload)
  SharedDtor();
}

void ShareUpload::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
    delete list_;
  }
}

void ShareUpload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareUpload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareUpload_descriptor_;
}

const ShareUpload& ShareUpload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareUpload* ShareUpload::default_instance_ = NULL;

ShareUpload* ShareUpload::New() const {
  return new ShareUpload;
}

void ShareUpload::Clear() {
  if (_has_bits_[0 / 32] & 28) {
    if (has_list()) {
      if (list_ != NULL) list_->::pamrac::ShareList::Clear();
    }
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nonce_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  revoke_id_.Clear();
  share_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareUpload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareUpload)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pamrac.ShareID revoke_id = 1;
      case 1: {
        if (tag == 10) {
         parse_revoke_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_revoke_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_revoke_id;
        if (input->ExpectTag(18)) goto parse_share;
        break;
      }

      // repeated .pamrac.KeyShare share = 2;
      case 2: {
        if (tag == 18) {
         parse_share:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_share()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_share;
        if (input->ExpectTag(26)) goto parse_list;
        break;
      }

      // optional .pamrac.ShareList list = 3;
      case 3: {
        if (tag == 26) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 4;
      case 4: {
        if (tag == 34) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_signature;
        break;
      }

      // required bytes signature = 5;
      case 5: {
        if (tag == 42) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareUpload)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareUpload)
  return false;
#undef DO_
}

void ShareUpload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareUpload)
  // repeated .pamrac.ShareID revoke_id = 1;
  for (int i = 0; i < this->revoke_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->revoke_id(i), output);
  }

  // repeated .pamrac.KeyShare share = 2;
  for (int i = 0; i < this->share_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->share(i), output);
  }

  // optional .pamrac.ShareList list = 3;
  if (has_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->list(), output);
  }

  // required bytes nonce = 4;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->nonce(), output);
  }

  // required bytes signature = 5;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareUpload)
}

::google::protobuf::uint8* ShareUpload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareUpload)
  // repeated .pamrac.ShareID revoke_id = 1;
  for (int i = 0; i < this->revoke_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->revoke_id(i), target);
  }

  // repeated .pamrac.KeyShare share = 2;
  for (int i = 0; i < this->share_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->share(i), target);
  }

  // optional .pamrac.ShareList list = 3;
  if (has_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->list(), target);
  }

  // required bytes nonce = 4;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->nonce(), target);
  }

  // required bytes signature = 5;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareUpload)
  return target;
}

int ShareUpload::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional .pamrac.ShareList list = 3;
    if (has_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->list());
    }

    // required bytes nonce = 4;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // required bytes signature = 5;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  // repeated .pamrac.ShareID revoke_id = 1;
  total_size += 1 * this->revoke_id_size();
  for (int i = 0; i < this->revoke_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->revoke_id(i));
  }

  // repeated .pamrac.KeyShare share = 2;
  total_size += 1 * this->share_size();
  for (int i = 0; i < this->share_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->share(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareUpload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareUpload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareUpload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareUpload::MergeFrom(const ShareUpload& from) {
  GOOGLE_CHECK_NE(&from, this);
  revoke_id_.MergeFrom(from.revoke_id_);
  share_.MergeFrom(from.share_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_list()) {
      mutable_list()->::pamrac::ShareList::MergeFrom(from.list());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareUpload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareUpload::CopyFrom(const ShareUpload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareUpload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000018) != 0x00000018) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->revoke_id())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->share())) return false;
  if (has_list()) {
    if (!this->list().IsInitialized()) return false;
  }
  return true;
}

void ShareUpload::Swap(ShareUpload* other) {
  if (other != this) {
    revoke_id_.Swap(&other->revoke_id_);
    share_.Swap(&other->share_);
    std::swap(list_, other->list_);
    std::swap(nonce_, other->nonce_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareUpload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareUpload_descriptor_;
  metadata.reflection = ShareUpload_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShareUploadResult::kVerificationOkFieldNumber;
const int ShareUploadResult::kIdsRevokedFieldNumber;
const int ShareUploadResult::kSharesAddedFieldNumber;
#endif  // !_MSC_VER

ShareUploadResult::ShareUploadResult()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.ShareUploadResult)
}

void ShareUploadResult::InitAsDefaultInstance() {
}

ShareUploadResult::ShareUploadResult(const ShareUploadResult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.ShareUploadResult)
}

void ShareUploadResult::SharedCtor() {
  _cached_size_ = 0;
  verification_ok_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareUploadResult::~ShareUploadResult() {
  // @@protoc_insertion_point(destructor:pamrac.ShareUploadResult)
  SharedDtor();
}

void ShareUploadResult::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShareUploadResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShareUploadResult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareUploadResult_descriptor_;
}

const ShareUploadResult& ShareUploadResult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

ShareUploadResult* ShareUploadResult::default_instance_ = NULL;

ShareUploadResult* ShareUploadResult::New() const {
  return new ShareUploadResult;
}

void ShareUploadResult::Clear() {
  verification_ok_ = false;
  ids_revoked_.Clear();
  shares_added_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareUploadResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.ShareUploadResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool verification_ok = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &verification_ok_)));
          set_has_verification_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ids_revoked;
        break;
      }

      // repeated .pamrac.ShareID ids_revoked = 2;
      case 2: {
        if (tag == 18) {
         parse_ids_revoked:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ids_revoked()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ids_revoked;
        if (input->ExpectTag(26)) goto parse_shares_added;
        break;
      }

      // repeated .pamrac.ShareID shares_added = 3;
      case 3: {
        if (tag == 26) {
         parse_shares_added:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shares_added()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_shares_added;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.ShareUploadResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.ShareUploadResult)
  return false;
#undef DO_
}

void ShareUploadResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.ShareUploadResult)
  // required bool verification_ok = 1;
  if (has_verification_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->verification_ok(), output);
  }

  // repeated .pamrac.ShareID ids_revoked = 2;
  for (int i = 0; i < this->ids_revoked_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->ids_revoked(i), output);
  }

  // repeated .pamrac.ShareID shares_added = 3;
  for (int i = 0; i < this->shares_added_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->shares_added(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.ShareUploadResult)
}

::google::protobuf::uint8* ShareUploadResult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.ShareUploadResult)
  // required bool verification_ok = 1;
  if (has_verification_ok()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->verification_ok(), target);
  }

  // repeated .pamrac.ShareID ids_revoked = 2;
  for (int i = 0; i < this->ids_revoked_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->ids_revoked(i), target);
  }

  // repeated .pamrac.ShareID shares_added = 3;
  for (int i = 0; i < this->shares_added_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->shares_added(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.ShareUploadResult)
  return target;
}

int ShareUploadResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool verification_ok = 1;
    if (has_verification_ok()) {
      total_size += 1 + 1;
    }

  }
  // repeated .pamrac.ShareID ids_revoked = 2;
  total_size += 1 * this->ids_revoked_size();
  for (int i = 0; i < this->ids_revoked_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ids_revoked(i));
  }

  // repeated .pamrac.ShareID shares_added = 3;
  total_size += 1 * this->shares_added_size();
  for (int i = 0; i < this->shares_added_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shares_added(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShareUploadResult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareUploadResult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareUploadResult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareUploadResult::MergeFrom(const ShareUploadResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  ids_revoked_.MergeFrom(from.ids_revoked_);
  shares_added_.MergeFrom(from.shares_added_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_verification_ok()) {
      set_verification_ok(from.verification_ok());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareUploadResult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareUploadResult::CopyFrom(const ShareUploadResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareUploadResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->ids_revoked())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->shares_added())) return false;
  return true;
}

void ShareUploadResult::Swap(ShareUploadResult* other) {
  if (other != this) {
    std::swap(verification_ok_, other->verification_ok_);
    ids_revoked_.Swap(&other->ids_revoked_);
    shares_added_.Swap(&other->shares_added_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShareUploadResult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShareUploadResult_descriptor_;
  metadata.reflection = ShareUploadResult_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FriendNameMap_FriendNickname::kNameFieldNumber;
const int FriendNameMap_FriendNickname::kFriendFingerprintFieldNumber;
const int FriendNameMap_FriendNickname::kServerAddressFieldNumber;
#endif  // !_MSC_VER

FriendNameMap_FriendNickname::FriendNameMap_FriendNickname()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.FriendNameMap.FriendNickname)
}

void FriendNameMap_FriendNickname::InitAsDefaultInstance() {
}

FriendNameMap_FriendNickname::FriendNameMap_FriendNickname(const FriendNameMap_FriendNickname& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.FriendNameMap.FriendNickname)
}

void FriendNameMap_FriendNickname::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  friend_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendNameMap_FriendNickname::~FriendNameMap_FriendNickname() {
  // @@protoc_insertion_point(destructor:pamrac.FriendNameMap.FriendNickname)
  SharedDtor();
}

void FriendNameMap_FriendNickname::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (friend_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete friend_fingerprint_;
  }
  if (server_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_address_;
  }
  if (this != default_instance_) {
  }
}

void FriendNameMap_FriendNickname::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FriendNameMap_FriendNickname::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FriendNameMap_FriendNickname_descriptor_;
}

const FriendNameMap_FriendNickname& FriendNameMap_FriendNickname::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

FriendNameMap_FriendNickname* FriendNameMap_FriendNickname::default_instance_ = NULL;

FriendNameMap_FriendNickname* FriendNameMap_FriendNickname::New() const {
  return new FriendNameMap_FriendNickname;
}

void FriendNameMap_FriendNickname::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_friend_fingerprint()) {
      if (friend_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        friend_fingerprint_->clear();
      }
    }
    if (has_server_address()) {
      if (server_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        server_address_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FriendNameMap_FriendNickname::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.FriendNameMap.FriendNickname)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_friend_fingerprint;
        break;
      }

      // required bytes friend_fingerprint = 2;
      case 2: {
        if (tag == 18) {
         parse_friend_fingerprint:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_friend_fingerprint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_server_address;
        break;
      }

      // required string server_address = 3;
      case 3: {
        if (tag == 26) {
         parse_server_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->server_address().data(), this->server_address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "server_address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.FriendNameMap.FriendNickname)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.FriendNameMap.FriendNickname)
  return false;
#undef DO_
}

void FriendNameMap_FriendNickname::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.FriendNameMap.FriendNickname)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required bytes friend_fingerprint = 2;
  if (has_friend_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->friend_fingerprint(), output);
  }

  // required string server_address = 3;
  if (has_server_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->server_address().data(), this->server_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "server_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->server_address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.FriendNameMap.FriendNickname)
}

::google::protobuf::uint8* FriendNameMap_FriendNickname::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.FriendNameMap.FriendNickname)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required bytes friend_fingerprint = 2;
  if (has_friend_fingerprint()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->friend_fingerprint(), target);
  }

  // required string server_address = 3;
  if (has_server_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->server_address().data(), this->server_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "server_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->server_address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.FriendNameMap.FriendNickname)
  return target;
}

int FriendNameMap_FriendNickname::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required bytes friend_fingerprint = 2;
    if (has_friend_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->friend_fingerprint());
    }

    // required string server_address = 3;
    if (has_server_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->server_address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendNameMap_FriendNickname::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FriendNameMap_FriendNickname* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FriendNameMap_FriendNickname*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FriendNameMap_FriendNickname::MergeFrom(const FriendNameMap_FriendNickname& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_friend_fingerprint()) {
      set_friend_fingerprint(from.friend_fingerprint());
    }
    if (from.has_server_address()) {
      set_server_address(from.server_address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FriendNameMap_FriendNickname::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FriendNameMap_FriendNickname::CopyFrom(const FriendNameMap_FriendNickname& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendNameMap_FriendNickname::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void FriendNameMap_FriendNickname::Swap(FriendNameMap_FriendNickname* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(friend_fingerprint_, other->friend_fingerprint_);
    std::swap(server_address_, other->server_address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FriendNameMap_FriendNickname::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FriendNameMap_FriendNickname_descriptor_;
  metadata.reflection = FriendNameMap_FriendNickname_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int FriendNameMap::kFriendsFieldNumber;
const int FriendNameMap::kTimestampFieldNumber;
const int FriendNameMap::kSignatureFieldNumber;
#endif  // !_MSC_VER

FriendNameMap::FriendNameMap()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pamrac.FriendNameMap)
}

void FriendNameMap::InitAsDefaultInstance() {
}

FriendNameMap::FriendNameMap(const FriendNameMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pamrac.FriendNameMap)
}

void FriendNameMap::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FriendNameMap::~FriendNameMap() {
  // @@protoc_insertion_point(destructor:pamrac.FriendNameMap)
  SharedDtor();
}

void FriendNameMap::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void FriendNameMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FriendNameMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FriendNameMap_descriptor_;
}

const FriendNameMap& FriendNameMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pamrac_2eproto();
  return *default_instance_;
}

FriendNameMap* FriendNameMap::default_instance_ = NULL;

FriendNameMap* FriendNameMap::New() const {
  return new FriendNameMap;
}

void FriendNameMap::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    timestamp_ = GOOGLE_LONGLONG(0);
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signature_->clear();
      }
    }
  }
  friends_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FriendNameMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pamrac.FriendNameMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pamrac.FriendNameMap.FriendNickname friends = 1;
      case 1: {
        if (tag == 10) {
         parse_friends:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_friends()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_friends;
        if (input->ExpectTag(16)) goto parse_timestamp;
        break;
      }

      // required int64 timestamp = 2;
      case 2: {
        if (tag == 16) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_signature;
        break;
      }

      // required bytes signature = 3;
      case 3: {
        if (tag == 26) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pamrac.FriendNameMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pamrac.FriendNameMap)
  return false;
#undef DO_
}

void FriendNameMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pamrac.FriendNameMap)
  // repeated .pamrac.FriendNameMap.FriendNickname friends = 1;
  for (int i = 0; i < this->friends_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->friends(i), output);
  }

  // required int64 timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->timestamp(), output);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pamrac.FriendNameMap)
}

::google::protobuf::uint8* FriendNameMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pamrac.FriendNameMap)
  // repeated .pamrac.FriendNameMap.FriendNickname friends = 1;
  for (int i = 0; i < this->friends_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->friends(i), target);
  }

  // required int64 timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->timestamp(), target);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pamrac.FriendNameMap)
  return target;
}

int FriendNameMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int64 timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // required bytes signature = 3;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  // repeated .pamrac.FriendNameMap.FriendNickname friends = 1;
  total_size += 1 * this->friends_size();
  for (int i = 0; i < this->friends_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->friends(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FriendNameMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FriendNameMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FriendNameMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FriendNameMap::MergeFrom(const FriendNameMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  friends_.MergeFrom(from.friends_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FriendNameMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FriendNameMap::CopyFrom(const FriendNameMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendNameMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->friends())) return false;
  return true;
}

void FriendNameMap::Swap(FriendNameMap* other) {
  if (other != this) {
    friends_.Swap(&other->friends_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FriendNameMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FriendNameMap_descriptor_;
  metadata.reflection = FriendNameMap_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pamrac

// @@protoc_insertion_point(global_scope)
