// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pamrac.proto

#ifndef PROTOBUF_pamrac_2eproto__INCLUDED
#define PROTOBUF_pamrac_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pamrac {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pamrac_2eproto();
void protobuf_AssignDesc_pamrac_2eproto();
void protobuf_ShutdownFile_pamrac_2eproto();

class PAMRACMessage;
class NonceResponse;
class BlobFile;
class InnerBlob;
class InnerBlob_KeyValue;
class MasterKeyPasswordedFile;
class InnerPassworded;
class MasterKeyRetrievableFile;
class InnerRetrievable;
class InitBlobRequest;
class InitBlobResponse;
class BlobRequest;
class BlobRequest_BlobHash;
class BlobResponse;
class BlobResponse_NamedBlobFile;
class BlobUpload;
class BlobUploadResult;
class ShareListRequest;
class ShareList;
class ShareList_ShareRecipient;
class ShareID;
class ShareRequest;
class KeyShare;
class ShareUpload;
class ShareUploadResult;
class FriendNameMap;
class FriendNameMap_FriendNickname;
class ConnectToNewStore;
class NewStoreConnectResult;
class ConnectFriendServerResult;

enum PAMRACMessage_Type {
  PAMRACMessage_Type_INIT_BLOB_REQUEST = 0,
  PAMRACMessage_Type_INIT_BLOB_RESPONSE = 1,
  PAMRACMessage_Type_BLOB_REQUEST = 2,
  PAMRACMessage_Type_BLOB_RESPONSE = 3,
  PAMRACMessage_Type_INIT_BLOB_UPLOAD = 4,
  PAMRACMessage_Type_BLOB_UPLOAD_NONCE = 5,
  PAMRACMessage_Type_BLOB_UPLOAD = 6,
  PAMRACMessage_Type_BLOB_UPLOAD_RESULT = 7,
  PAMRACMessage_Type_INIT_SHARE_UPLOAD = 8,
  PAMRACMessage_Type_SHARE_UPLOAD_NONCE = 9,
  PAMRACMessage_Type_SHARE_UPLOAD = 10,
  PAMRACMessage_Type_SHARE_UPLOAD_RESULT = 11,
  PAMRACMessage_Type_INIT_SHARE_REQUEST = 12,
  PAMRACMessage_Type_SHARE_REQUEST_NONCE = 13,
  PAMRACMessage_Type_SHARE_REQUEST = 14,
  PAMRACMessage_Type_KEY_SHARE = 15,
  PAMRACMessage_Type_INIT_SHARE_LIST_REQUEST = 16,
  PAMRACMessage_Type_SHARE_LIST_REQUEST_NONCE = 17,
  PAMRACMessage_Type_SHARE_LIST_REQUEST = 18,
  PAMRACMessage_Type_SHARE_LIST = 19,
  PAMRACMessage_Type_CONNECT_TO_NEW_STORE = 20,
  PAMRACMessage_Type_NEW_STORE_CONNECT_RESULT = 21,
  PAMRACMessage_Type_CONNECT_TO_FRIEND_SERVER = 22,
  PAMRACMessage_Type_CONNECT_FRIEND_SERVER_RESULT = 23,
  PAMRACMessage_Type_NOT_AUTHORIZED = 24
};
bool PAMRACMessage_Type_IsValid(int value);
const PAMRACMessage_Type PAMRACMessage_Type_Type_MIN = PAMRACMessage_Type_INIT_BLOB_REQUEST;
const PAMRACMessage_Type PAMRACMessage_Type_Type_MAX = PAMRACMessage_Type_NOT_AUTHORIZED;
const int PAMRACMessage_Type_Type_ARRAYSIZE = PAMRACMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* PAMRACMessage_Type_descriptor();
inline const ::std::string& PAMRACMessage_Type_Name(PAMRACMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    PAMRACMessage_Type_descriptor(), value);
}
inline bool PAMRACMessage_Type_Parse(
    const ::std::string& name, PAMRACMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PAMRACMessage_Type>(
    PAMRACMessage_Type_descriptor(), name, value);
}
// ===================================================================

class PAMRACMessage : public ::google::protobuf::Message {
 public:
  PAMRACMessage();
  virtual ~PAMRACMessage();

  PAMRACMessage(const PAMRACMessage& from);

  inline PAMRACMessage& operator=(const PAMRACMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PAMRACMessage& default_instance();

  void Swap(PAMRACMessage* other);

  // implements Message ----------------------------------------------

  PAMRACMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PAMRACMessage& from);
  void MergeFrom(const PAMRACMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PAMRACMessage_Type Type;
  static const Type INIT_BLOB_REQUEST = PAMRACMessage_Type_INIT_BLOB_REQUEST;
  static const Type INIT_BLOB_RESPONSE = PAMRACMessage_Type_INIT_BLOB_RESPONSE;
  static const Type BLOB_REQUEST = PAMRACMessage_Type_BLOB_REQUEST;
  static const Type BLOB_RESPONSE = PAMRACMessage_Type_BLOB_RESPONSE;
  static const Type INIT_BLOB_UPLOAD = PAMRACMessage_Type_INIT_BLOB_UPLOAD;
  static const Type BLOB_UPLOAD_NONCE = PAMRACMessage_Type_BLOB_UPLOAD_NONCE;
  static const Type BLOB_UPLOAD = PAMRACMessage_Type_BLOB_UPLOAD;
  static const Type BLOB_UPLOAD_RESULT = PAMRACMessage_Type_BLOB_UPLOAD_RESULT;
  static const Type INIT_SHARE_UPLOAD = PAMRACMessage_Type_INIT_SHARE_UPLOAD;
  static const Type SHARE_UPLOAD_NONCE = PAMRACMessage_Type_SHARE_UPLOAD_NONCE;
  static const Type SHARE_UPLOAD = PAMRACMessage_Type_SHARE_UPLOAD;
  static const Type SHARE_UPLOAD_RESULT = PAMRACMessage_Type_SHARE_UPLOAD_RESULT;
  static const Type INIT_SHARE_REQUEST = PAMRACMessage_Type_INIT_SHARE_REQUEST;
  static const Type SHARE_REQUEST_NONCE = PAMRACMessage_Type_SHARE_REQUEST_NONCE;
  static const Type SHARE_REQUEST = PAMRACMessage_Type_SHARE_REQUEST;
  static const Type KEY_SHARE = PAMRACMessage_Type_KEY_SHARE;
  static const Type INIT_SHARE_LIST_REQUEST = PAMRACMessage_Type_INIT_SHARE_LIST_REQUEST;
  static const Type SHARE_LIST_REQUEST_NONCE = PAMRACMessage_Type_SHARE_LIST_REQUEST_NONCE;
  static const Type SHARE_LIST_REQUEST = PAMRACMessage_Type_SHARE_LIST_REQUEST;
  static const Type SHARE_LIST = PAMRACMessage_Type_SHARE_LIST;
  static const Type CONNECT_TO_NEW_STORE = PAMRACMessage_Type_CONNECT_TO_NEW_STORE;
  static const Type NEW_STORE_CONNECT_RESULT = PAMRACMessage_Type_NEW_STORE_CONNECT_RESULT;
  static const Type CONNECT_TO_FRIEND_SERVER = PAMRACMessage_Type_CONNECT_TO_FRIEND_SERVER;
  static const Type CONNECT_FRIEND_SERVER_RESULT = PAMRACMessage_Type_CONNECT_FRIEND_SERVER_RESULT;
  static const Type NOT_AUTHORIZED = PAMRACMessage_Type_NOT_AUTHORIZED;
  static inline bool Type_IsValid(int value) {
    return PAMRACMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PAMRACMessage_Type_Type_MIN;
  static const Type Type_MAX =
    PAMRACMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PAMRACMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return PAMRACMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return PAMRACMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return PAMRACMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes user_fingerprint = 1;
  inline bool has_user_fingerprint() const;
  inline void clear_user_fingerprint();
  static const int kUserFingerprintFieldNumber = 1;
  inline const ::std::string& user_fingerprint() const;
  inline void set_user_fingerprint(const ::std::string& value);
  inline void set_user_fingerprint(const char* value);
  inline void set_user_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_user_fingerprint();
  inline ::std::string* release_user_fingerprint();
  inline void set_allocated_user_fingerprint(::std::string* user_fingerprint);

  // required .pamrac.PAMRACMessage.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::pamrac::PAMRACMessage_Type type() const;
  inline void set_type(::pamrac::PAMRACMessage_Type value);

  // optional .pamrac.InitBlobRequest init_blob_request = 3;
  inline bool has_init_blob_request() const;
  inline void clear_init_blob_request();
  static const int kInitBlobRequestFieldNumber = 3;
  inline const ::pamrac::InitBlobRequest& init_blob_request() const;
  inline ::pamrac::InitBlobRequest* mutable_init_blob_request();
  inline ::pamrac::InitBlobRequest* release_init_blob_request();
  inline void set_allocated_init_blob_request(::pamrac::InitBlobRequest* init_blob_request);

  // optional .pamrac.InitBlobResponse init_blob_response = 4;
  inline bool has_init_blob_response() const;
  inline void clear_init_blob_response();
  static const int kInitBlobResponseFieldNumber = 4;
  inline const ::pamrac::InitBlobResponse& init_blob_response() const;
  inline ::pamrac::InitBlobResponse* mutable_init_blob_response();
  inline ::pamrac::InitBlobResponse* release_init_blob_response();
  inline void set_allocated_init_blob_response(::pamrac::InitBlobResponse* init_blob_response);

  // optional .pamrac.BlobRequest blob_request = 5;
  inline bool has_blob_request() const;
  inline void clear_blob_request();
  static const int kBlobRequestFieldNumber = 5;
  inline const ::pamrac::BlobRequest& blob_request() const;
  inline ::pamrac::BlobRequest* mutable_blob_request();
  inline ::pamrac::BlobRequest* release_blob_request();
  inline void set_allocated_blob_request(::pamrac::BlobRequest* blob_request);

  // optional .pamrac.BlobResponse blob_response = 6;
  inline bool has_blob_response() const;
  inline void clear_blob_response();
  static const int kBlobResponseFieldNumber = 6;
  inline const ::pamrac::BlobResponse& blob_response() const;
  inline ::pamrac::BlobResponse* mutable_blob_response();
  inline ::pamrac::BlobResponse* release_blob_response();
  inline void set_allocated_blob_response(::pamrac::BlobResponse* blob_response);

  // optional .pamrac.BlobUpload blob_upload = 7;
  inline bool has_blob_upload() const;
  inline void clear_blob_upload();
  static const int kBlobUploadFieldNumber = 7;
  inline const ::pamrac::BlobUpload& blob_upload() const;
  inline ::pamrac::BlobUpload* mutable_blob_upload();
  inline ::pamrac::BlobUpload* release_blob_upload();
  inline void set_allocated_blob_upload(::pamrac::BlobUpload* blob_upload);

  // optional .pamrac.BlobUploadResult blob_upload_result = 8;
  inline bool has_blob_upload_result() const;
  inline void clear_blob_upload_result();
  static const int kBlobUploadResultFieldNumber = 8;
  inline const ::pamrac::BlobUploadResult& blob_upload_result() const;
  inline ::pamrac::BlobUploadResult* mutable_blob_upload_result();
  inline ::pamrac::BlobUploadResult* release_blob_upload_result();
  inline void set_allocated_blob_upload_result(::pamrac::BlobUploadResult* blob_upload_result);

  // optional .pamrac.NonceResponse nonce_response = 9;
  inline bool has_nonce_response() const;
  inline void clear_nonce_response();
  static const int kNonceResponseFieldNumber = 9;
  inline const ::pamrac::NonceResponse& nonce_response() const;
  inline ::pamrac::NonceResponse* mutable_nonce_response();
  inline ::pamrac::NonceResponse* release_nonce_response();
  inline void set_allocated_nonce_response(::pamrac::NonceResponse* nonce_response);

  // optional .pamrac.ShareUpload share_upload = 10;
  inline bool has_share_upload() const;
  inline void clear_share_upload();
  static const int kShareUploadFieldNumber = 10;
  inline const ::pamrac::ShareUpload& share_upload() const;
  inline ::pamrac::ShareUpload* mutable_share_upload();
  inline ::pamrac::ShareUpload* release_share_upload();
  inline void set_allocated_share_upload(::pamrac::ShareUpload* share_upload);

  // optional .pamrac.ShareUploadResult share_upload_result = 11;
  inline bool has_share_upload_result() const;
  inline void clear_share_upload_result();
  static const int kShareUploadResultFieldNumber = 11;
  inline const ::pamrac::ShareUploadResult& share_upload_result() const;
  inline ::pamrac::ShareUploadResult* mutable_share_upload_result();
  inline ::pamrac::ShareUploadResult* release_share_upload_result();
  inline void set_allocated_share_upload_result(::pamrac::ShareUploadResult* share_upload_result);

  // optional .pamrac.ShareRequest share_request = 12;
  inline bool has_share_request() const;
  inline void clear_share_request();
  static const int kShareRequestFieldNumber = 12;
  inline const ::pamrac::ShareRequest& share_request() const;
  inline ::pamrac::ShareRequest* mutable_share_request();
  inline ::pamrac::ShareRequest* release_share_request();
  inline void set_allocated_share_request(::pamrac::ShareRequest* share_request);

  // optional .pamrac.KeyShare key_share = 13;
  inline bool has_key_share() const;
  inline void clear_key_share();
  static const int kKeyShareFieldNumber = 13;
  inline const ::pamrac::KeyShare& key_share() const;
  inline ::pamrac::KeyShare* mutable_key_share();
  inline ::pamrac::KeyShare* release_key_share();
  inline void set_allocated_key_share(::pamrac::KeyShare* key_share);

  // optional .pamrac.ShareListRequest share_list_request = 14;
  inline bool has_share_list_request() const;
  inline void clear_share_list_request();
  static const int kShareListRequestFieldNumber = 14;
  inline const ::pamrac::ShareListRequest& share_list_request() const;
  inline ::pamrac::ShareListRequest* mutable_share_list_request();
  inline ::pamrac::ShareListRequest* release_share_list_request();
  inline void set_allocated_share_list_request(::pamrac::ShareListRequest* share_list_request);

  // optional .pamrac.ShareList share_list = 15;
  inline bool has_share_list() const;
  inline void clear_share_list();
  static const int kShareListFieldNumber = 15;
  inline const ::pamrac::ShareList& share_list() const;
  inline ::pamrac::ShareList* mutable_share_list();
  inline ::pamrac::ShareList* release_share_list();
  inline void set_allocated_share_list(::pamrac::ShareList* share_list);

  // optional .pamrac.ConnectToNewStore connect_to_new_store = 16;
  inline bool has_connect_to_new_store() const;
  inline void clear_connect_to_new_store();
  static const int kConnectToNewStoreFieldNumber = 16;
  inline const ::pamrac::ConnectToNewStore& connect_to_new_store() const;
  inline ::pamrac::ConnectToNewStore* mutable_connect_to_new_store();
  inline ::pamrac::ConnectToNewStore* release_connect_to_new_store();
  inline void set_allocated_connect_to_new_store(::pamrac::ConnectToNewStore* connect_to_new_store);

  // optional .pamrac.NewStoreConnectResult new_store_connect_result = 17;
  inline bool has_new_store_connect_result() const;
  inline void clear_new_store_connect_result();
  static const int kNewStoreConnectResultFieldNumber = 17;
  inline const ::pamrac::NewStoreConnectResult& new_store_connect_result() const;
  inline ::pamrac::NewStoreConnectResult* mutable_new_store_connect_result();
  inline ::pamrac::NewStoreConnectResult* release_new_store_connect_result();
  inline void set_allocated_new_store_connect_result(::pamrac::NewStoreConnectResult* new_store_connect_result);

  // optional .pamrac.ConnectFriendServerResult connect_friend_server_result = 18;
  inline bool has_connect_friend_server_result() const;
  inline void clear_connect_friend_server_result();
  static const int kConnectFriendServerResultFieldNumber = 18;
  inline const ::pamrac::ConnectFriendServerResult& connect_friend_server_result() const;
  inline ::pamrac::ConnectFriendServerResult* mutable_connect_friend_server_result();
  inline ::pamrac::ConnectFriendServerResult* release_connect_friend_server_result();
  inline void set_allocated_connect_friend_server_result(::pamrac::ConnectFriendServerResult* connect_friend_server_result);

  // optional bytes client_pubkey = 19;
  inline bool has_client_pubkey() const;
  inline void clear_client_pubkey();
  static const int kClientPubkeyFieldNumber = 19;
  inline const ::std::string& client_pubkey() const;
  inline void set_client_pubkey(const ::std::string& value);
  inline void set_client_pubkey(const char* value);
  inline void set_client_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_client_pubkey();
  inline ::std::string* release_client_pubkey();
  inline void set_allocated_client_pubkey(::std::string* client_pubkey);

  // @@protoc_insertion_point(class_scope:pamrac.PAMRACMessage)
 private:
  inline void set_has_user_fingerprint();
  inline void clear_has_user_fingerprint();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_init_blob_request();
  inline void clear_has_init_blob_request();
  inline void set_has_init_blob_response();
  inline void clear_has_init_blob_response();
  inline void set_has_blob_request();
  inline void clear_has_blob_request();
  inline void set_has_blob_response();
  inline void clear_has_blob_response();
  inline void set_has_blob_upload();
  inline void clear_has_blob_upload();
  inline void set_has_blob_upload_result();
  inline void clear_has_blob_upload_result();
  inline void set_has_nonce_response();
  inline void clear_has_nonce_response();
  inline void set_has_share_upload();
  inline void clear_has_share_upload();
  inline void set_has_share_upload_result();
  inline void clear_has_share_upload_result();
  inline void set_has_share_request();
  inline void clear_has_share_request();
  inline void set_has_key_share();
  inline void clear_has_key_share();
  inline void set_has_share_list_request();
  inline void clear_has_share_list_request();
  inline void set_has_share_list();
  inline void clear_has_share_list();
  inline void set_has_connect_to_new_store();
  inline void clear_has_connect_to_new_store();
  inline void set_has_new_store_connect_result();
  inline void clear_has_new_store_connect_result();
  inline void set_has_connect_friend_server_result();
  inline void clear_has_connect_friend_server_result();
  inline void set_has_client_pubkey();
  inline void clear_has_client_pubkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_fingerprint_;
  ::pamrac::InitBlobRequest* init_blob_request_;
  ::pamrac::InitBlobResponse* init_blob_response_;
  ::pamrac::BlobRequest* blob_request_;
  ::pamrac::BlobResponse* blob_response_;
  ::pamrac::BlobUpload* blob_upload_;
  ::pamrac::BlobUploadResult* blob_upload_result_;
  ::pamrac::NonceResponse* nonce_response_;
  ::pamrac::ShareUpload* share_upload_;
  ::pamrac::ShareUploadResult* share_upload_result_;
  ::pamrac::ShareRequest* share_request_;
  ::pamrac::KeyShare* key_share_;
  ::pamrac::ShareListRequest* share_list_request_;
  ::pamrac::ShareList* share_list_;
  ::pamrac::ConnectToNewStore* connect_to_new_store_;
  ::pamrac::NewStoreConnectResult* new_store_connect_result_;
  ::pamrac::ConnectFriendServerResult* connect_friend_server_result_;
  ::std::string* client_pubkey_;
  int type_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static PAMRACMessage* default_instance_;
};
// -------------------------------------------------------------------

class NonceResponse : public ::google::protobuf::Message {
 public:
  NonceResponse();
  virtual ~NonceResponse();

  NonceResponse(const NonceResponse& from);

  inline NonceResponse& operator=(const NonceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NonceResponse& default_instance();

  void Swap(NonceResponse* other);

  // implements Message ----------------------------------------------

  NonceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NonceResponse& from);
  void MergeFrom(const NonceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes nonce = 1;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 1;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // @@protoc_insertion_point(class_scope:pamrac.NonceResponse)
 private:
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nonce_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static NonceResponse* default_instance_;
};
// -------------------------------------------------------------------

class BlobFile : public ::google::protobuf::Message {
 public:
  BlobFile();
  virtual ~BlobFile();

  BlobFile(const BlobFile& from);

  inline BlobFile& operator=(const BlobFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobFile& default_instance();

  void Swap(BlobFile* other);

  // implements Message ----------------------------------------------

  BlobFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobFile& from);
  void MergeFrom(const BlobFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes salt = 1;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 1;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  inline void set_allocated_salt(::std::string* salt);

  // required int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // required bytes aes_init_vector = 3;
  inline bool has_aes_init_vector() const;
  inline void clear_aes_init_vector();
  static const int kAesInitVectorFieldNumber = 3;
  inline const ::std::string& aes_init_vector() const;
  inline void set_aes_init_vector(const ::std::string& value);
  inline void set_aes_init_vector(const char* value);
  inline void set_aes_init_vector(const void* value, size_t size);
  inline ::std::string* mutable_aes_init_vector();
  inline ::std::string* release_aes_init_vector();
  inline void set_allocated_aes_init_vector(::std::string* aes_init_vector);

  // required bytes inner_blob_ciphertext = 4;
  inline bool has_inner_blob_ciphertext() const;
  inline void clear_inner_blob_ciphertext();
  static const int kInnerBlobCiphertextFieldNumber = 4;
  inline const ::std::string& inner_blob_ciphertext() const;
  inline void set_inner_blob_ciphertext(const ::std::string& value);
  inline void set_inner_blob_ciphertext(const char* value);
  inline void set_inner_blob_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_inner_blob_ciphertext();
  inline ::std::string* release_inner_blob_ciphertext();
  inline void set_allocated_inner_blob_ciphertext(::std::string* inner_blob_ciphertext);

  // @@protoc_insertion_point(class_scope:pamrac.BlobFile)
 private:
  inline void set_has_salt();
  inline void clear_has_salt();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_aes_init_vector();
  inline void clear_has_aes_init_vector();
  inline void set_has_inner_blob_ciphertext();
  inline void clear_has_inner_blob_ciphertext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* salt_;
  ::std::string* aes_init_vector_;
  ::std::string* inner_blob_ciphertext_;
  ::google::protobuf::int32 version_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobFile* default_instance_;
};
// -------------------------------------------------------------------

class InnerBlob_KeyValue : public ::google::protobuf::Message {
 public:
  InnerBlob_KeyValue();
  virtual ~InnerBlob_KeyValue();

  InnerBlob_KeyValue(const InnerBlob_KeyValue& from);

  inline InnerBlob_KeyValue& operator=(const InnerBlob_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerBlob_KeyValue& default_instance();

  void Swap(InnerBlob_KeyValue* other);

  // implements Message ----------------------------------------------

  InnerBlob_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerBlob_KeyValue& from);
  void MergeFrom(const InnerBlob_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pamrac.InnerBlob.KeyValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static InnerBlob_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class InnerBlob : public ::google::protobuf::Message {
 public:
  InnerBlob();
  virtual ~InnerBlob();

  InnerBlob(const InnerBlob& from);

  inline InnerBlob& operator=(const InnerBlob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerBlob& default_instance();

  void Swap(InnerBlob* other);

  // implements Message ----------------------------------------------

  InnerBlob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerBlob& from);
  void MergeFrom(const InnerBlob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InnerBlob_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // repeated .pamrac.InnerBlob.KeyValue fields = 2;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 2;
  inline const ::pamrac::InnerBlob_KeyValue& fields(int index) const;
  inline ::pamrac::InnerBlob_KeyValue* mutable_fields(int index);
  inline ::pamrac::InnerBlob_KeyValue* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::InnerBlob_KeyValue >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::InnerBlob_KeyValue >*
      mutable_fields();

  // @@protoc_insertion_point(class_scope:pamrac.InnerBlob)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::InnerBlob_KeyValue > fields_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static InnerBlob* default_instance_;
};
// -------------------------------------------------------------------

class MasterKeyPasswordedFile : public ::google::protobuf::Message {
 public:
  MasterKeyPasswordedFile();
  virtual ~MasterKeyPasswordedFile();

  MasterKeyPasswordedFile(const MasterKeyPasswordedFile& from);

  inline MasterKeyPasswordedFile& operator=(const MasterKeyPasswordedFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterKeyPasswordedFile& default_instance();

  void Swap(MasterKeyPasswordedFile* other);

  // implements Message ----------------------------------------------

  MasterKeyPasswordedFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterKeyPasswordedFile& from);
  void MergeFrom(const MasterKeyPasswordedFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes salt = 1;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 1;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  inline void set_allocated_salt(::std::string* salt);

  // required bytes aes_init_vector = 2;
  inline bool has_aes_init_vector() const;
  inline void clear_aes_init_vector();
  static const int kAesInitVectorFieldNumber = 2;
  inline const ::std::string& aes_init_vector() const;
  inline void set_aes_init_vector(const ::std::string& value);
  inline void set_aes_init_vector(const char* value);
  inline void set_aes_init_vector(const void* value, size_t size);
  inline ::std::string* mutable_aes_init_vector();
  inline ::std::string* release_aes_init_vector();
  inline void set_allocated_aes_init_vector(::std::string* aes_init_vector);

  // required bytes inner_ciphertext = 3;
  inline bool has_inner_ciphertext() const;
  inline void clear_inner_ciphertext();
  static const int kInnerCiphertextFieldNumber = 3;
  inline const ::std::string& inner_ciphertext() const;
  inline void set_inner_ciphertext(const ::std::string& value);
  inline void set_inner_ciphertext(const char* value);
  inline void set_inner_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_inner_ciphertext();
  inline ::std::string* release_inner_ciphertext();
  inline void set_allocated_inner_ciphertext(::std::string* inner_ciphertext);

  // @@protoc_insertion_point(class_scope:pamrac.MasterKeyPasswordedFile)
 private:
  inline void set_has_salt();
  inline void clear_has_salt();
  inline void set_has_aes_init_vector();
  inline void clear_has_aes_init_vector();
  inline void set_has_inner_ciphertext();
  inline void clear_has_inner_ciphertext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* salt_;
  ::std::string* aes_init_vector_;
  ::std::string* inner_ciphertext_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static MasterKeyPasswordedFile* default_instance_;
};
// -------------------------------------------------------------------

class InnerPassworded : public ::google::protobuf::Message {
 public:
  InnerPassworded();
  virtual ~InnerPassworded();

  InnerPassworded(const InnerPassworded& from);

  inline InnerPassworded& operator=(const InnerPassworded& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerPassworded& default_instance();

  void Swap(InnerPassworded* other);

  // implements Message ----------------------------------------------

  InnerPassworded* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerPassworded& from);
  void MergeFrom(const InnerPassworded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes master_key = 1;
  inline bool has_master_key() const;
  inline void clear_master_key();
  static const int kMasterKeyFieldNumber = 1;
  inline const ::std::string& master_key() const;
  inline void set_master_key(const ::std::string& value);
  inline void set_master_key(const char* value);
  inline void set_master_key(const void* value, size_t size);
  inline ::std::string* mutable_master_key();
  inline ::std::string* release_master_key();
  inline void set_allocated_master_key(::std::string* master_key);

  // required bytes filenamesalt = 2;
  inline bool has_filenamesalt() const;
  inline void clear_filenamesalt();
  static const int kFilenamesaltFieldNumber = 2;
  inline const ::std::string& filenamesalt() const;
  inline void set_filenamesalt(const ::std::string& value);
  inline void set_filenamesalt(const char* value);
  inline void set_filenamesalt(const void* value, size_t size);
  inline ::std::string* mutable_filenamesalt();
  inline ::std::string* release_filenamesalt();
  inline void set_allocated_filenamesalt(::std::string* filenamesalt);

  // repeated string site_names = 3;
  inline int site_names_size() const;
  inline void clear_site_names();
  static const int kSiteNamesFieldNumber = 3;
  inline const ::std::string& site_names(int index) const;
  inline ::std::string* mutable_site_names(int index);
  inline void set_site_names(int index, const ::std::string& value);
  inline void set_site_names(int index, const char* value);
  inline void set_site_names(int index, const char* value, size_t size);
  inline ::std::string* add_site_names();
  inline void add_site_names(const ::std::string& value);
  inline void add_site_names(const char* value);
  inline void add_site_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& site_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_site_names();

  // required bytes downloadsecret = 4;
  inline bool has_downloadsecret() const;
  inline void clear_downloadsecret();
  static const int kDownloadsecretFieldNumber = 4;
  inline const ::std::string& downloadsecret() const;
  inline void set_downloadsecret(const ::std::string& value);
  inline void set_downloadsecret(const char* value);
  inline void set_downloadsecret(const void* value, size_t size);
  inline ::std::string* mutable_downloadsecret();
  inline ::std::string* release_downloadsecret();
  inline void set_allocated_downloadsecret(::std::string* downloadsecret);

  // required bytes private_key = 5;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 5;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // @@protoc_insertion_point(class_scope:pamrac.InnerPassworded)
 private:
  inline void set_has_master_key();
  inline void clear_has_master_key();
  inline void set_has_filenamesalt();
  inline void clear_has_filenamesalt();
  inline void set_has_downloadsecret();
  inline void clear_has_downloadsecret();
  inline void set_has_private_key();
  inline void clear_has_private_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_key_;
  ::std::string* filenamesalt_;
  ::google::protobuf::RepeatedPtrField< ::std::string> site_names_;
  ::std::string* downloadsecret_;
  ::std::string* private_key_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static InnerPassworded* default_instance_;
};
// -------------------------------------------------------------------

class MasterKeyRetrievableFile : public ::google::protobuf::Message {
 public:
  MasterKeyRetrievableFile();
  virtual ~MasterKeyRetrievableFile();

  MasterKeyRetrievableFile(const MasterKeyRetrievableFile& from);

  inline MasterKeyRetrievableFile& operator=(const MasterKeyRetrievableFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterKeyRetrievableFile& default_instance();

  void Swap(MasterKeyRetrievableFile* other);

  // implements Message ----------------------------------------------

  MasterKeyRetrievableFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterKeyRetrievableFile& from);
  void MergeFrom(const MasterKeyRetrievableFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // required bytes aes_init_vector = 2;
  inline bool has_aes_init_vector() const;
  inline void clear_aes_init_vector();
  static const int kAesInitVectorFieldNumber = 2;
  inline const ::std::string& aes_init_vector() const;
  inline void set_aes_init_vector(const ::std::string& value);
  inline void set_aes_init_vector(const char* value);
  inline void set_aes_init_vector(const void* value, size_t size);
  inline ::std::string* mutable_aes_init_vector();
  inline ::std::string* release_aes_init_vector();
  inline void set_allocated_aes_init_vector(::std::string* aes_init_vector);

  // required bytes inner_retrievable_ciphertext = 3;
  inline bool has_inner_retrievable_ciphertext() const;
  inline void clear_inner_retrievable_ciphertext();
  static const int kInnerRetrievableCiphertextFieldNumber = 3;
  inline const ::std::string& inner_retrievable_ciphertext() const;
  inline void set_inner_retrievable_ciphertext(const ::std::string& value);
  inline void set_inner_retrievable_ciphertext(const char* value);
  inline void set_inner_retrievable_ciphertext(const void* value, size_t size);
  inline ::std::string* mutable_inner_retrievable_ciphertext();
  inline ::std::string* release_inner_retrievable_ciphertext();
  inline void set_allocated_inner_retrievable_ciphertext(::std::string* inner_retrievable_ciphertext);

  // @@protoc_insertion_point(class_scope:pamrac.MasterKeyRetrievableFile)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_aes_init_vector();
  inline void clear_has_aes_init_vector();
  inline void set_has_inner_retrievable_ciphertext();
  inline void clear_has_inner_retrievable_ciphertext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* aes_init_vector_;
  ::std::string* inner_retrievable_ciphertext_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static MasterKeyRetrievableFile* default_instance_;
};
// -------------------------------------------------------------------

class InnerRetrievable : public ::google::protobuf::Message {
 public:
  InnerRetrievable();
  virtual ~InnerRetrievable();

  InnerRetrievable(const InnerRetrievable& from);

  inline InnerRetrievable& operator=(const InnerRetrievable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerRetrievable& default_instance();

  void Swap(InnerRetrievable* other);

  // implements Message ----------------------------------------------

  InnerRetrievable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerRetrievable& from);
  void MergeFrom(const InnerRetrievable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes master_key = 1;
  inline bool has_master_key() const;
  inline void clear_master_key();
  static const int kMasterKeyFieldNumber = 1;
  inline const ::std::string& master_key() const;
  inline void set_master_key(const ::std::string& value);
  inline void set_master_key(const char* value);
  inline void set_master_key(const void* value, size_t size);
  inline ::std::string* mutable_master_key();
  inline ::std::string* release_master_key();
  inline void set_allocated_master_key(::std::string* master_key);

  // required bytes DOWNLOADSECRET = 2;
  inline bool has_downloadsecret() const;
  inline void clear_downloadsecret();
  static const int kDOWNLOADSECRETFieldNumber = 2;
  inline const ::std::string& downloadsecret() const;
  inline void set_downloadsecret(const ::std::string& value);
  inline void set_downloadsecret(const char* value);
  inline void set_downloadsecret(const void* value, size_t size);
  inline ::std::string* mutable_downloadsecret();
  inline ::std::string* release_downloadsecret();
  inline void set_allocated_downloadsecret(::std::string* downloadsecret);

  // @@protoc_insertion_point(class_scope:pamrac.InnerRetrievable)
 private:
  inline void set_has_master_key();
  inline void clear_has_master_key();
  inline void set_has_downloadsecret();
  inline void clear_has_downloadsecret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_key_;
  ::std::string* downloadsecret_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static InnerRetrievable* default_instance_;
};
// -------------------------------------------------------------------

class InitBlobRequest : public ::google::protobuf::Message {
 public:
  InitBlobRequest();
  virtual ~InitBlobRequest();

  InitBlobRequest(const InitBlobRequest& from);

  inline InitBlobRequest& operator=(const InitBlobRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitBlobRequest& default_instance();

  void Swap(InitBlobRequest* other);

  // implements Message ----------------------------------------------

  InitBlobRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitBlobRequest& from);
  void MergeFrom(const InitBlobRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes all_hash_xor = 1;
  inline bool has_all_hash_xor() const;
  inline void clear_all_hash_xor();
  static const int kAllHashXorFieldNumber = 1;
  inline const ::std::string& all_hash_xor() const;
  inline void set_all_hash_xor(const ::std::string& value);
  inline void set_all_hash_xor(const char* value);
  inline void set_all_hash_xor(const void* value, size_t size);
  inline ::std::string* mutable_all_hash_xor();
  inline ::std::string* release_all_hash_xor();
  inline void set_allocated_all_hash_xor(::std::string* all_hash_xor);

  // @@protoc_insertion_point(class_scope:pamrac.InitBlobRequest)
 private:
  inline void set_has_all_hash_xor();
  inline void clear_has_all_hash_xor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* all_hash_xor_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static InitBlobRequest* default_instance_;
};
// -------------------------------------------------------------------

class InitBlobResponse : public ::google::protobuf::Message {
 public:
  InitBlobResponse();
  virtual ~InitBlobResponse();

  InitBlobResponse(const InitBlobResponse& from);

  inline InitBlobResponse& operator=(const InitBlobResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitBlobResponse& default_instance();

  void Swap(InitBlobResponse* other);

  // implements Message ----------------------------------------------

  InitBlobResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitBlobResponse& from);
  void MergeFrom(const InitBlobResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool xor_matches = 1;
  inline bool has_xor_matches() const;
  inline void clear_xor_matches();
  static const int kXorMatchesFieldNumber = 1;
  inline bool xor_matches() const;
  inline void set_xor_matches(bool value);

  // optional bytes nonce = 2;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 2;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // @@protoc_insertion_point(class_scope:pamrac.InitBlobResponse)
 private:
  inline void set_has_xor_matches();
  inline void clear_has_xor_matches();
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nonce_;
  bool xor_matches_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static InitBlobResponse* default_instance_;
};
// -------------------------------------------------------------------

class BlobRequest_BlobHash : public ::google::protobuf::Message {
 public:
  BlobRequest_BlobHash();
  virtual ~BlobRequest_BlobHash();

  BlobRequest_BlobHash(const BlobRequest_BlobHash& from);

  inline BlobRequest_BlobHash& operator=(const BlobRequest_BlobHash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobRequest_BlobHash& default_instance();

  void Swap(BlobRequest_BlobHash* other);

  // implements Message ----------------------------------------------

  BlobRequest_BlobHash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobRequest_BlobHash& from);
  void MergeFrom(const BlobRequest_BlobHash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string blob_name = 1;
  inline bool has_blob_name() const;
  inline void clear_blob_name();
  static const int kBlobNameFieldNumber = 1;
  inline const ::std::string& blob_name() const;
  inline void set_blob_name(const ::std::string& value);
  inline void set_blob_name(const char* value);
  inline void set_blob_name(const char* value, size_t size);
  inline ::std::string* mutable_blob_name();
  inline ::std::string* release_blob_name();
  inline void set_allocated_blob_name(::std::string* blob_name);

  // required bytes blob_hash = 2;
  inline bool has_blob_hash() const;
  inline void clear_blob_hash();
  static const int kBlobHashFieldNumber = 2;
  inline const ::std::string& blob_hash() const;
  inline void set_blob_hash(const ::std::string& value);
  inline void set_blob_hash(const char* value);
  inline void set_blob_hash(const void* value, size_t size);
  inline ::std::string* mutable_blob_hash();
  inline ::std::string* release_blob_hash();
  inline void set_allocated_blob_hash(::std::string* blob_hash);

  // @@protoc_insertion_point(class_scope:pamrac.BlobRequest.BlobHash)
 private:
  inline void set_has_blob_name();
  inline void clear_has_blob_name();
  inline void set_has_blob_hash();
  inline void clear_has_blob_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* blob_name_;
  ::std::string* blob_hash_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobRequest_BlobHash* default_instance_;
};
// -------------------------------------------------------------------

class BlobRequest : public ::google::protobuf::Message {
 public:
  BlobRequest();
  virtual ~BlobRequest();

  BlobRequest(const BlobRequest& from);

  inline BlobRequest& operator=(const BlobRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobRequest& default_instance();

  void Swap(BlobRequest* other);

  // implements Message ----------------------------------------------

  BlobRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobRequest& from);
  void MergeFrom(const BlobRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlobRequest_BlobHash BlobHash;

  // accessors -------------------------------------------------------

  // repeated .pamrac.BlobRequest.BlobHash cached_blobs = 1;
  inline int cached_blobs_size() const;
  inline void clear_cached_blobs();
  static const int kCachedBlobsFieldNumber = 1;
  inline const ::pamrac::BlobRequest_BlobHash& cached_blobs(int index) const;
  inline ::pamrac::BlobRequest_BlobHash* mutable_cached_blobs(int index);
  inline ::pamrac::BlobRequest_BlobHash* add_cached_blobs();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::BlobRequest_BlobHash >&
      cached_blobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::BlobRequest_BlobHash >*
      mutable_cached_blobs();

  // required bytes downloadsecret_proof = 2;
  inline bool has_downloadsecret_proof() const;
  inline void clear_downloadsecret_proof();
  static const int kDownloadsecretProofFieldNumber = 2;
  inline const ::std::string& downloadsecret_proof() const;
  inline void set_downloadsecret_proof(const ::std::string& value);
  inline void set_downloadsecret_proof(const char* value);
  inline void set_downloadsecret_proof(const void* value, size_t size);
  inline ::std::string* mutable_downloadsecret_proof();
  inline ::std::string* release_downloadsecret_proof();
  inline void set_allocated_downloadsecret_proof(::std::string* downloadsecret_proof);

  // required bytes proof_nonce = 3;
  inline bool has_proof_nonce() const;
  inline void clear_proof_nonce();
  static const int kProofNonceFieldNumber = 3;
  inline const ::std::string& proof_nonce() const;
  inline void set_proof_nonce(const ::std::string& value);
  inline void set_proof_nonce(const char* value);
  inline void set_proof_nonce(const void* value, size_t size);
  inline ::std::string* mutable_proof_nonce();
  inline ::std::string* release_proof_nonce();
  inline void set_allocated_proof_nonce(::std::string* proof_nonce);

  // @@protoc_insertion_point(class_scope:pamrac.BlobRequest)
 private:
  inline void set_has_downloadsecret_proof();
  inline void clear_has_downloadsecret_proof();
  inline void set_has_proof_nonce();
  inline void clear_has_proof_nonce();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::BlobRequest_BlobHash > cached_blobs_;
  ::std::string* downloadsecret_proof_;
  ::std::string* proof_nonce_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobRequest* default_instance_;
};
// -------------------------------------------------------------------

class BlobResponse_NamedBlobFile : public ::google::protobuf::Message {
 public:
  BlobResponse_NamedBlobFile();
  virtual ~BlobResponse_NamedBlobFile();

  BlobResponse_NamedBlobFile(const BlobResponse_NamedBlobFile& from);

  inline BlobResponse_NamedBlobFile& operator=(const BlobResponse_NamedBlobFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobResponse_NamedBlobFile& default_instance();

  void Swap(BlobResponse_NamedBlobFile* other);

  // implements Message ----------------------------------------------

  BlobResponse_NamedBlobFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobResponse_NamedBlobFile& from);
  void MergeFrom(const BlobResponse_NamedBlobFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .pamrac.BlobFile blob = 2;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 2;
  inline const ::pamrac::BlobFile& blob() const;
  inline ::pamrac::BlobFile* mutable_blob();
  inline ::pamrac::BlobFile* release_blob();
  inline void set_allocated_blob(::pamrac::BlobFile* blob);

  // @@protoc_insertion_point(class_scope:pamrac.BlobResponse.NamedBlobFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_blob();
  inline void clear_has_blob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::pamrac::BlobFile* blob_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobResponse_NamedBlobFile* default_instance_;
};
// -------------------------------------------------------------------

class BlobResponse : public ::google::protobuf::Message {
 public:
  BlobResponse();
  virtual ~BlobResponse();

  BlobResponse(const BlobResponse& from);

  inline BlobResponse& operator=(const BlobResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobResponse& default_instance();

  void Swap(BlobResponse* other);

  // implements Message ----------------------------------------------

  BlobResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobResponse& from);
  void MergeFrom(const BlobResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlobResponse_NamedBlobFile NamedBlobFile;

  // accessors -------------------------------------------------------

  // repeated .pamrac.BlobResponse.NamedBlobFile new_blobs = 1;
  inline int new_blobs_size() const;
  inline void clear_new_blobs();
  static const int kNewBlobsFieldNumber = 1;
  inline const ::pamrac::BlobResponse_NamedBlobFile& new_blobs(int index) const;
  inline ::pamrac::BlobResponse_NamedBlobFile* mutable_new_blobs(int index);
  inline ::pamrac::BlobResponse_NamedBlobFile* add_new_blobs();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::BlobResponse_NamedBlobFile >&
      new_blobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::BlobResponse_NamedBlobFile >*
      mutable_new_blobs();

  // @@protoc_insertion_point(class_scope:pamrac.BlobResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::BlobResponse_NamedBlobFile > new_blobs_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobResponse* default_instance_;
};
// -------------------------------------------------------------------

class BlobUpload : public ::google::protobuf::Message {
 public:
  BlobUpload();
  virtual ~BlobUpload();

  BlobUpload(const BlobUpload& from);

  inline BlobUpload& operator=(const BlobUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobUpload& default_instance();

  void Swap(BlobUpload* other);

  // implements Message ----------------------------------------------

  BlobUpload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobUpload& from);
  void MergeFrom(const BlobUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hashed_filename = 1;
  inline bool has_hashed_filename() const;
  inline void clear_hashed_filename();
  static const int kHashedFilenameFieldNumber = 1;
  inline const ::std::string& hashed_filename() const;
  inline void set_hashed_filename(const ::std::string& value);
  inline void set_hashed_filename(const char* value);
  inline void set_hashed_filename(const char* value, size_t size);
  inline ::std::string* mutable_hashed_filename();
  inline ::std::string* release_hashed_filename();
  inline void set_allocated_hashed_filename(::std::string* hashed_filename);

  // required .pamrac.BlobFile blob = 2;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 2;
  inline const ::pamrac::BlobFile& blob() const;
  inline ::pamrac::BlobFile* mutable_blob();
  inline ::pamrac::BlobFile* release_blob();
  inline void set_allocated_blob(::pamrac::BlobFile* blob);

  // required bytes nonce = 3;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 3;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:pamrac.BlobUpload)
 private:
  inline void set_has_hashed_filename();
  inline void clear_has_hashed_filename();
  inline void set_has_blob();
  inline void clear_has_blob();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hashed_filename_;
  ::pamrac::BlobFile* blob_;
  ::std::string* nonce_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobUpload* default_instance_;
};
// -------------------------------------------------------------------

class BlobUploadResult : public ::google::protobuf::Message {
 public:
  BlobUploadResult();
  virtual ~BlobUploadResult();

  BlobUploadResult(const BlobUploadResult& from);

  inline BlobUploadResult& operator=(const BlobUploadResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobUploadResult& default_instance();

  void Swap(BlobUploadResult* other);

  // implements Message ----------------------------------------------

  BlobUploadResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobUploadResult& from);
  void MergeFrom(const BlobUploadResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool verification_ok = 1;
  inline bool has_verification_ok() const;
  inline void clear_verification_ok();
  static const int kVerificationOkFieldNumber = 1;
  inline bool verification_ok() const;
  inline void set_verification_ok(bool value);

  // optional bool upload_successful = 2;
  inline bool has_upload_successful() const;
  inline void clear_upload_successful();
  static const int kUploadSuccessfulFieldNumber = 2;
  inline bool upload_successful() const;
  inline void set_upload_successful(bool value);

  // optional int32 server_version = 3;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 3;
  inline ::google::protobuf::int32 server_version() const;
  inline void set_server_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pamrac.BlobUploadResult)
 private:
  inline void set_has_verification_ok();
  inline void clear_has_verification_ok();
  inline void set_has_upload_successful();
  inline void clear_has_upload_successful();
  inline void set_has_server_version();
  inline void clear_has_server_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool verification_ok_;
  bool upload_successful_;
  ::google::protobuf::int32 server_version_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static BlobUploadResult* default_instance_;
};
// -------------------------------------------------------------------

class ShareListRequest : public ::google::protobuf::Message {
 public:
  ShareListRequest();
  virtual ~ShareListRequest();

  ShareListRequest(const ShareListRequest& from);

  inline ShareListRequest& operator=(const ShareListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareListRequest& default_instance();

  void Swap(ShareListRequest* other);

  // implements Message ----------------------------------------------

  ShareListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareListRequest& from);
  void MergeFrom(const ShareListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes requester_fingerprint = 1;
  inline bool has_requester_fingerprint() const;
  inline void clear_requester_fingerprint();
  static const int kRequesterFingerprintFieldNumber = 1;
  inline const ::std::string& requester_fingerprint() const;
  inline void set_requester_fingerprint(const ::std::string& value);
  inline void set_requester_fingerprint(const char* value);
  inline void set_requester_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_requester_fingerprint();
  inline ::std::string* release_requester_fingerprint();
  inline void set_allocated_requester_fingerprint(::std::string* requester_fingerprint);

  // required bytes nonce = 2;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 2;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:pamrac.ShareListRequest)
 private:
  inline void set_has_requester_fingerprint();
  inline void clear_has_requester_fingerprint();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* requester_fingerprint_;
  ::std::string* nonce_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareListRequest* default_instance_;
};
// -------------------------------------------------------------------

class ShareList_ShareRecipient : public ::google::protobuf::Message {
 public:
  ShareList_ShareRecipient();
  virtual ~ShareList_ShareRecipient();

  ShareList_ShareRecipient(const ShareList_ShareRecipient& from);

  inline ShareList_ShareRecipient& operator=(const ShareList_ShareRecipient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareList_ShareRecipient& default_instance();

  void Swap(ShareList_ShareRecipient* other);

  // implements Message ----------------------------------------------

  ShareList_ShareRecipient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareList_ShareRecipient& from);
  void MergeFrom(const ShareList_ShareRecipient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required bytes fingerprint = 2;
  inline bool has_fingerprint() const;
  inline void clear_fingerprint();
  static const int kFingerprintFieldNumber = 2;
  inline const ::std::string& fingerprint() const;
  inline void set_fingerprint(const ::std::string& value);
  inline void set_fingerprint(const char* value);
  inline void set_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_fingerprint();
  inline ::std::string* release_fingerprint();
  inline void set_allocated_fingerprint(::std::string* fingerprint);

  // required bool initiator = 3;
  inline bool has_initiator() const;
  inline void clear_initiator();
  static const int kInitiatorFieldNumber = 3;
  inline bool initiator() const;
  inline void set_initiator(bool value);

  // @@protoc_insertion_point(class_scope:pamrac.ShareList.ShareRecipient)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_fingerprint();
  inline void clear_has_fingerprint();
  inline void set_has_initiator();
  inline void clear_has_initiator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::std::string* fingerprint_;
  bool initiator_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareList_ShareRecipient* default_instance_;
};
// -------------------------------------------------------------------

class ShareList : public ::google::protobuf::Message {
 public:
  ShareList();
  virtual ~ShareList();

  ShareList(const ShareList& from);

  inline ShareList& operator=(const ShareList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareList& default_instance();

  void Swap(ShareList* other);

  // implements Message ----------------------------------------------

  ShareList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareList& from);
  void MergeFrom(const ShareList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ShareList_ShareRecipient ShareRecipient;

  // accessors -------------------------------------------------------

  // required int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // required int32 threshold = 2;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  inline ::google::protobuf::int32 threshold() const;
  inline void set_threshold(::google::protobuf::int32 value);

  // repeated .pamrac.ShareList.ShareRecipient recipients = 3;
  inline int recipients_size() const;
  inline void clear_recipients();
  static const int kRecipientsFieldNumber = 3;
  inline const ::pamrac::ShareList_ShareRecipient& recipients(int index) const;
  inline ::pamrac::ShareList_ShareRecipient* mutable_recipients(int index);
  inline ::pamrac::ShareList_ShareRecipient* add_recipients();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareList_ShareRecipient >&
      recipients() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareList_ShareRecipient >*
      mutable_recipients();

  // optional bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:pamrac.ShareList)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_threshold();
  inline void clear_has_threshold();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::ShareList_ShareRecipient > recipients_;
  ::std::string* signature_;
  ::google::protobuf::int32 threshold_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareList* default_instance_;
};
// -------------------------------------------------------------------

class ShareID : public ::google::protobuf::Message {
 public:
  ShareID();
  virtual ~ShareID();

  ShareID(const ShareID& from);

  inline ShareID& operator=(const ShareID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareID& default_instance();

  void Swap(ShareID* other);

  // implements Message ----------------------------------------------

  ShareID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareID& from);
  void MergeFrom(const ShareID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes originator_fingerprint = 1;
  inline bool has_originator_fingerprint() const;
  inline void clear_originator_fingerprint();
  static const int kOriginatorFingerprintFieldNumber = 1;
  inline const ::std::string& originator_fingerprint() const;
  inline void set_originator_fingerprint(const ::std::string& value);
  inline void set_originator_fingerprint(const char* value);
  inline void set_originator_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_originator_fingerprint();
  inline ::std::string* release_originator_fingerprint();
  inline void set_allocated_originator_fingerprint(::std::string* originator_fingerprint);

  // required bytes owner_fingerprint = 2;
  inline bool has_owner_fingerprint() const;
  inline void clear_owner_fingerprint();
  static const int kOwnerFingerprintFieldNumber = 2;
  inline const ::std::string& owner_fingerprint() const;
  inline void set_owner_fingerprint(const ::std::string& value);
  inline void set_owner_fingerprint(const char* value);
  inline void set_owner_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_owner_fingerprint();
  inline ::std::string* release_owner_fingerprint();
  inline void set_allocated_owner_fingerprint(::std::string* owner_fingerprint);

  // required bytes encrypted_to_fingerprint = 3;
  inline bool has_encrypted_to_fingerprint() const;
  inline void clear_encrypted_to_fingerprint();
  static const int kEncryptedToFingerprintFieldNumber = 3;
  inline const ::std::string& encrypted_to_fingerprint() const;
  inline void set_encrypted_to_fingerprint(const ::std::string& value);
  inline void set_encrypted_to_fingerprint(const char* value);
  inline void set_encrypted_to_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_to_fingerprint();
  inline ::std::string* release_encrypted_to_fingerprint();
  inline void set_allocated_encrypted_to_fingerprint(::std::string* encrypted_to_fingerprint);

  // @@protoc_insertion_point(class_scope:pamrac.ShareID)
 private:
  inline void set_has_originator_fingerprint();
  inline void clear_has_originator_fingerprint();
  inline void set_has_owner_fingerprint();
  inline void clear_has_owner_fingerprint();
  inline void set_has_encrypted_to_fingerprint();
  inline void clear_has_encrypted_to_fingerprint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* originator_fingerprint_;
  ::std::string* owner_fingerprint_;
  ::std::string* encrypted_to_fingerprint_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareID* default_instance_;
};
// -------------------------------------------------------------------

class ShareRequest : public ::google::protobuf::Message {
 public:
  ShareRequest();
  virtual ~ShareRequest();

  ShareRequest(const ShareRequest& from);

  inline ShareRequest& operator=(const ShareRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareRequest& default_instance();

  void Swap(ShareRequest* other);

  // implements Message ----------------------------------------------

  ShareRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareRequest& from);
  void MergeFrom(const ShareRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pamrac.ShareID share_id = 1;
  inline bool has_share_id() const;
  inline void clear_share_id();
  static const int kShareIdFieldNumber = 1;
  inline const ::pamrac::ShareID& share_id() const;
  inline ::pamrac::ShareID* mutable_share_id();
  inline ::pamrac::ShareID* release_share_id();
  inline void set_allocated_share_id(::pamrac::ShareID* share_id);

  // required bytes nonce = 2;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 2;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:pamrac.ShareRequest)
 private:
  inline void set_has_share_id();
  inline void clear_has_share_id();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pamrac::ShareID* share_id_;
  ::std::string* nonce_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareRequest* default_instance_;
};
// -------------------------------------------------------------------

class KeyShare : public ::google::protobuf::Message {
 public:
  KeyShare();
  virtual ~KeyShare();

  KeyShare(const KeyShare& from);

  inline KeyShare& operator=(const KeyShare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyShare& default_instance();

  void Swap(KeyShare* other);

  // implements Message ----------------------------------------------

  KeyShare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyShare& from);
  void MergeFrom(const KeyShare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .pamrac.MasterKeyRetrievableFile masterkey_retrievable_file = 2;
  inline bool has_masterkey_retrievable_file() const;
  inline void clear_masterkey_retrievable_file();
  static const int kMasterkeyRetrievableFileFieldNumber = 2;
  inline const ::pamrac::MasterKeyRetrievableFile& masterkey_retrievable_file() const;
  inline ::pamrac::MasterKeyRetrievableFile* mutable_masterkey_retrievable_file();
  inline ::pamrac::MasterKeyRetrievableFile* release_masterkey_retrievable_file();
  inline void set_allocated_masterkey_retrievable_file(::pamrac::MasterKeyRetrievableFile* masterkey_retrievable_file);

  // optional bytes encrypted_initiator_mask = 3;
  inline bool has_encrypted_initiator_mask() const;
  inline void clear_encrypted_initiator_mask();
  static const int kEncryptedInitiatorMaskFieldNumber = 3;
  inline const ::std::string& encrypted_initiator_mask() const;
  inline void set_encrypted_initiator_mask(const ::std::string& value);
  inline void set_encrypted_initiator_mask(const char* value);
  inline void set_encrypted_initiator_mask(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_initiator_mask();
  inline ::std::string* release_encrypted_initiator_mask();
  inline void set_allocated_encrypted_initiator_mask(::std::string* encrypted_initiator_mask);

  // required bytes encrypted_share = 4;
  inline bool has_encrypted_share() const;
  inline void clear_encrypted_share();
  static const int kEncryptedShareFieldNumber = 4;
  inline const ::std::string& encrypted_share() const;
  inline void set_encrypted_share(const ::std::string& value);
  inline void set_encrypted_share(const char* value);
  inline void set_encrypted_share(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_share();
  inline ::std::string* release_encrypted_share();
  inline void set_allocated_encrypted_share(::std::string* encrypted_share);

  // required .pamrac.ShareID share_id = 5;
  inline bool has_share_id() const;
  inline void clear_share_id();
  static const int kShareIdFieldNumber = 5;
  inline const ::pamrac::ShareID& share_id() const;
  inline ::pamrac::ShareID* mutable_share_id();
  inline ::pamrac::ShareID* release_share_id();
  inline void set_allocated_share_id(::pamrac::ShareID* share_id);

  // @@protoc_insertion_point(class_scope:pamrac.KeyShare)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_masterkey_retrievable_file();
  inline void clear_has_masterkey_retrievable_file();
  inline void set_has_encrypted_initiator_mask();
  inline void clear_has_encrypted_initiator_mask();
  inline void set_has_encrypted_share();
  inline void clear_has_encrypted_share();
  inline void set_has_share_id();
  inline void clear_has_share_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  ::pamrac::MasterKeyRetrievableFile* masterkey_retrievable_file_;
  ::std::string* encrypted_initiator_mask_;
  ::std::string* encrypted_share_;
  ::pamrac::ShareID* share_id_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static KeyShare* default_instance_;
};
// -------------------------------------------------------------------

class ShareUpload : public ::google::protobuf::Message {
 public:
  ShareUpload();
  virtual ~ShareUpload();

  ShareUpload(const ShareUpload& from);

  inline ShareUpload& operator=(const ShareUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareUpload& default_instance();

  void Swap(ShareUpload* other);

  // implements Message ----------------------------------------------

  ShareUpload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareUpload& from);
  void MergeFrom(const ShareUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pamrac.ShareID revoke_id = 1;
  inline int revoke_id_size() const;
  inline void clear_revoke_id();
  static const int kRevokeIdFieldNumber = 1;
  inline const ::pamrac::ShareID& revoke_id(int index) const;
  inline ::pamrac::ShareID* mutable_revoke_id(int index);
  inline ::pamrac::ShareID* add_revoke_id();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >&
      revoke_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >*
      mutable_revoke_id();

  // repeated .pamrac.KeyShare share = 2;
  inline int share_size() const;
  inline void clear_share();
  static const int kShareFieldNumber = 2;
  inline const ::pamrac::KeyShare& share(int index) const;
  inline ::pamrac::KeyShare* mutable_share(int index);
  inline ::pamrac::KeyShare* add_share();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::KeyShare >&
      share() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::KeyShare >*
      mutable_share();

  // optional .pamrac.ShareList list = 3;
  inline bool has_list() const;
  inline void clear_list();
  static const int kListFieldNumber = 3;
  inline const ::pamrac::ShareList& list() const;
  inline ::pamrac::ShareList* mutable_list();
  inline ::pamrac::ShareList* release_list();
  inline void set_allocated_list(::pamrac::ShareList* list);

  // required bytes nonce = 4;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 4;
  inline const ::std::string& nonce() const;
  inline void set_nonce(const ::std::string& value);
  inline void set_nonce(const char* value);
  inline void set_nonce(const void* value, size_t size);
  inline ::std::string* mutable_nonce();
  inline ::std::string* release_nonce();
  inline void set_allocated_nonce(::std::string* nonce);

  // optional bytes signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:pamrac.ShareUpload)
 private:
  inline void set_has_list();
  inline void clear_has_list();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID > revoke_id_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::KeyShare > share_;
  ::pamrac::ShareList* list_;
  ::std::string* nonce_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareUpload* default_instance_;
};
// -------------------------------------------------------------------

class ShareUploadResult : public ::google::protobuf::Message {
 public:
  ShareUploadResult();
  virtual ~ShareUploadResult();

  ShareUploadResult(const ShareUploadResult& from);

  inline ShareUploadResult& operator=(const ShareUploadResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareUploadResult& default_instance();

  void Swap(ShareUploadResult* other);

  // implements Message ----------------------------------------------

  ShareUploadResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareUploadResult& from);
  void MergeFrom(const ShareUploadResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool verification_ok = 1;
  inline bool has_verification_ok() const;
  inline void clear_verification_ok();
  static const int kVerificationOkFieldNumber = 1;
  inline bool verification_ok() const;
  inline void set_verification_ok(bool value);

  // repeated .pamrac.ShareID ids_revoked = 2;
  inline int ids_revoked_size() const;
  inline void clear_ids_revoked();
  static const int kIdsRevokedFieldNumber = 2;
  inline const ::pamrac::ShareID& ids_revoked(int index) const;
  inline ::pamrac::ShareID* mutable_ids_revoked(int index);
  inline ::pamrac::ShareID* add_ids_revoked();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >&
      ids_revoked() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >*
      mutable_ids_revoked();

  // repeated .pamrac.ShareID shares_added = 3;
  inline int shares_added_size() const;
  inline void clear_shares_added();
  static const int kSharesAddedFieldNumber = 3;
  inline const ::pamrac::ShareID& shares_added(int index) const;
  inline ::pamrac::ShareID* mutable_shares_added(int index);
  inline ::pamrac::ShareID* add_shares_added();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >&
      shares_added() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >*
      mutable_shares_added();

  // @@protoc_insertion_point(class_scope:pamrac.ShareUploadResult)
 private:
  inline void set_has_verification_ok();
  inline void clear_has_verification_ok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID > ids_revoked_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID > shares_added_;
  bool verification_ok_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ShareUploadResult* default_instance_;
};
// -------------------------------------------------------------------

class FriendNameMap_FriendNickname : public ::google::protobuf::Message {
 public:
  FriendNameMap_FriendNickname();
  virtual ~FriendNameMap_FriendNickname();

  FriendNameMap_FriendNickname(const FriendNameMap_FriendNickname& from);

  inline FriendNameMap_FriendNickname& operator=(const FriendNameMap_FriendNickname& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendNameMap_FriendNickname& default_instance();

  void Swap(FriendNameMap_FriendNickname* other);

  // implements Message ----------------------------------------------

  FriendNameMap_FriendNickname* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendNameMap_FriendNickname& from);
  void MergeFrom(const FriendNameMap_FriendNickname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes friend_fingerprint = 2;
  inline bool has_friend_fingerprint() const;
  inline void clear_friend_fingerprint();
  static const int kFriendFingerprintFieldNumber = 2;
  inline const ::std::string& friend_fingerprint() const;
  inline void set_friend_fingerprint(const ::std::string& value);
  inline void set_friend_fingerprint(const char* value);
  inline void set_friend_fingerprint(const void* value, size_t size);
  inline ::std::string* mutable_friend_fingerprint();
  inline ::std::string* release_friend_fingerprint();
  inline void set_allocated_friend_fingerprint(::std::string* friend_fingerprint);

  // required bytes friend_pubkey = 3;
  inline bool has_friend_pubkey() const;
  inline void clear_friend_pubkey();
  static const int kFriendPubkeyFieldNumber = 3;
  inline const ::std::string& friend_pubkey() const;
  inline void set_friend_pubkey(const ::std::string& value);
  inline void set_friend_pubkey(const char* value);
  inline void set_friend_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_friend_pubkey();
  inline ::std::string* release_friend_pubkey();
  inline void set_allocated_friend_pubkey(::std::string* friend_pubkey);

  // required bytes friend_server_cert = 4;
  inline bool has_friend_server_cert() const;
  inline void clear_friend_server_cert();
  static const int kFriendServerCertFieldNumber = 4;
  inline const ::std::string& friend_server_cert() const;
  inline void set_friend_server_cert(const ::std::string& value);
  inline void set_friend_server_cert(const char* value);
  inline void set_friend_server_cert(const void* value, size_t size);
  inline ::std::string* mutable_friend_server_cert();
  inline ::std::string* release_friend_server_cert();
  inline void set_allocated_friend_server_cert(::std::string* friend_server_cert);

  // required string server_address = 5;
  inline bool has_server_address() const;
  inline void clear_server_address();
  static const int kServerAddressFieldNumber = 5;
  inline const ::std::string& server_address() const;
  inline void set_server_address(const ::std::string& value);
  inline void set_server_address(const char* value);
  inline void set_server_address(const char* value, size_t size);
  inline ::std::string* mutable_server_address();
  inline ::std::string* release_server_address();
  inline void set_allocated_server_address(::std::string* server_address);

  // @@protoc_insertion_point(class_scope:pamrac.FriendNameMap.FriendNickname)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_friend_fingerprint();
  inline void clear_has_friend_fingerprint();
  inline void set_has_friend_pubkey();
  inline void clear_has_friend_pubkey();
  inline void set_has_friend_server_cert();
  inline void clear_has_friend_server_cert();
  inline void set_has_server_address();
  inline void clear_has_server_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* friend_fingerprint_;
  ::std::string* friend_pubkey_;
  ::std::string* friend_server_cert_;
  ::std::string* server_address_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static FriendNameMap_FriendNickname* default_instance_;
};
// -------------------------------------------------------------------

class FriendNameMap : public ::google::protobuf::Message {
 public:
  FriendNameMap();
  virtual ~FriendNameMap();

  FriendNameMap(const FriendNameMap& from);

  inline FriendNameMap& operator=(const FriendNameMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendNameMap& default_instance();

  void Swap(FriendNameMap* other);

  // implements Message ----------------------------------------------

  FriendNameMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendNameMap& from);
  void MergeFrom(const FriendNameMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FriendNameMap_FriendNickname FriendNickname;

  // accessors -------------------------------------------------------

  // repeated .pamrac.FriendNameMap.FriendNickname friends = 1;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 1;
  inline const ::pamrac::FriendNameMap_FriendNickname& friends(int index) const;
  inline ::pamrac::FriendNameMap_FriendNickname* mutable_friends(int index);
  inline ::pamrac::FriendNameMap_FriendNickname* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::pamrac::FriendNameMap_FriendNickname >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::pamrac::FriendNameMap_FriendNickname >*
      mutable_friends();

  // required int64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:pamrac.FriendNameMap)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pamrac::FriendNameMap_FriendNickname > friends_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* signature_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static FriendNameMap* default_instance_;
};
// -------------------------------------------------------------------

class ConnectToNewStore : public ::google::protobuf::Message {
 public:
  ConnectToNewStore();
  virtual ~ConnectToNewStore();

  ConnectToNewStore(const ConnectToNewStore& from);

  inline ConnectToNewStore& operator=(const ConnectToNewStore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectToNewStore& default_instance();

  void Swap(ConnectToNewStore* other);

  // implements Message ----------------------------------------------

  ConnectToNewStore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectToNewStore& from);
  void MergeFrom(const ConnectToNewStore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string passcode = 1;
  inline bool has_passcode() const;
  inline void clear_passcode();
  static const int kPasscodeFieldNumber = 1;
  inline const ::std::string& passcode() const;
  inline void set_passcode(const ::std::string& value);
  inline void set_passcode(const char* value);
  inline void set_passcode(const char* value, size_t size);
  inline ::std::string* mutable_passcode();
  inline ::std::string* release_passcode();
  inline void set_allocated_passcode(::std::string* passcode);

  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // required bytes download_secret = 3;
  inline bool has_download_secret() const;
  inline void clear_download_secret();
  static const int kDownloadSecretFieldNumber = 3;
  inline const ::std::string& download_secret() const;
  inline void set_download_secret(const ::std::string& value);
  inline void set_download_secret(const char* value);
  inline void set_download_secret(const void* value, size_t size);
  inline ::std::string* mutable_download_secret();
  inline ::std::string* release_download_secret();
  inline void set_allocated_download_secret(::std::string* download_secret);

  // optional string nickname = 4;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 4;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional .pamrac.MasterKeyPasswordedFile encrypted_master = 5;
  inline bool has_encrypted_master() const;
  inline void clear_encrypted_master();
  static const int kEncryptedMasterFieldNumber = 5;
  inline const ::pamrac::MasterKeyPasswordedFile& encrypted_master() const;
  inline ::pamrac::MasterKeyPasswordedFile* mutable_encrypted_master();
  inline ::pamrac::MasterKeyPasswordedFile* release_encrypted_master();
  inline void set_allocated_encrypted_master(::pamrac::MasterKeyPasswordedFile* encrypted_master);

  // @@protoc_insertion_point(class_scope:pamrac.ConnectToNewStore)
 private:
  inline void set_has_passcode();
  inline void clear_has_passcode();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_download_secret();
  inline void clear_has_download_secret();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_encrypted_master();
  inline void clear_has_encrypted_master();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* passcode_;
  ::std::string* public_key_;
  ::std::string* download_secret_;
  ::std::string* nickname_;
  ::pamrac::MasterKeyPasswordedFile* encrypted_master_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ConnectToNewStore* default_instance_;
};
// -------------------------------------------------------------------

class NewStoreConnectResult : public ::google::protobuf::Message {
 public:
  NewStoreConnectResult();
  virtual ~NewStoreConnectResult();

  NewStoreConnectResult(const NewStoreConnectResult& from);

  inline NewStoreConnectResult& operator=(const NewStoreConnectResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewStoreConnectResult& default_instance();

  void Swap(NewStoreConnectResult* other);

  // implements Message ----------------------------------------------

  NewStoreConnectResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewStoreConnectResult& from);
  void MergeFrom(const NewStoreConnectResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // @@protoc_insertion_point(class_scope:pamrac.NewStoreConnectResult)
 private:
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool success_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static NewStoreConnectResult* default_instance_;
};
// -------------------------------------------------------------------

class ConnectFriendServerResult : public ::google::protobuf::Message {
 public:
  ConnectFriendServerResult();
  virtual ~ConnectFriendServerResult();

  ConnectFriendServerResult(const ConnectFriendServerResult& from);

  inline ConnectFriendServerResult& operator=(const ConnectFriendServerResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectFriendServerResult& default_instance();

  void Swap(ConnectFriendServerResult* other);

  // implements Message ----------------------------------------------

  ConnectFriendServerResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectFriendServerResult& from);
  void MergeFrom(const ConnectFriendServerResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user_public_key = 1;
  inline bool has_user_public_key() const;
  inline void clear_user_public_key();
  static const int kUserPublicKeyFieldNumber = 1;
  inline const ::std::string& user_public_key() const;
  inline void set_user_public_key(const ::std::string& value);
  inline void set_user_public_key(const char* value);
  inline void set_user_public_key(const void* value, size_t size);
  inline ::std::string* mutable_user_public_key();
  inline ::std::string* release_user_public_key();
  inline void set_allocated_user_public_key(::std::string* user_public_key);

  // required bytes server_cert = 2;
  inline bool has_server_cert() const;
  inline void clear_server_cert();
  static const int kServerCertFieldNumber = 2;
  inline const ::std::string& server_cert() const;
  inline void set_server_cert(const ::std::string& value);
  inline void set_server_cert(const char* value);
  inline void set_server_cert(const void* value, size_t size);
  inline ::std::string* mutable_server_cert();
  inline ::std::string* release_server_cert();
  inline void set_allocated_server_cert(::std::string* server_cert);

  // required bytes sig_of_cert = 3;
  inline bool has_sig_of_cert() const;
  inline void clear_sig_of_cert();
  static const int kSigOfCertFieldNumber = 3;
  inline const ::std::string& sig_of_cert() const;
  inline void set_sig_of_cert(const ::std::string& value);
  inline void set_sig_of_cert(const char* value);
  inline void set_sig_of_cert(const void* value, size_t size);
  inline ::std::string* mutable_sig_of_cert();
  inline ::std::string* release_sig_of_cert();
  inline void set_allocated_sig_of_cert(::std::string* sig_of_cert);

  // @@protoc_insertion_point(class_scope:pamrac.ConnectFriendServerResult)
 private:
  inline void set_has_user_public_key();
  inline void clear_has_user_public_key();
  inline void set_has_server_cert();
  inline void clear_has_server_cert();
  inline void set_has_sig_of_cert();
  inline void clear_has_sig_of_cert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_public_key_;
  ::std::string* server_cert_;
  ::std::string* sig_of_cert_;
  friend void  protobuf_AddDesc_pamrac_2eproto();
  friend void protobuf_AssignDesc_pamrac_2eproto();
  friend void protobuf_ShutdownFile_pamrac_2eproto();

  void InitAsDefaultInstance();
  static ConnectFriendServerResult* default_instance_;
};
// ===================================================================


// ===================================================================

// PAMRACMessage

// optional bytes user_fingerprint = 1;
inline bool PAMRACMessage::has_user_fingerprint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PAMRACMessage::set_has_user_fingerprint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PAMRACMessage::clear_has_user_fingerprint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PAMRACMessage::clear_user_fingerprint() {
  if (user_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_fingerprint_->clear();
  }
  clear_has_user_fingerprint();
}
inline const ::std::string& PAMRACMessage::user_fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.user_fingerprint)
  return *user_fingerprint_;
}
inline void PAMRACMessage::set_user_fingerprint(const ::std::string& value) {
  set_has_user_fingerprint();
  if (user_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_fingerprint_ = new ::std::string;
  }
  user_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.PAMRACMessage.user_fingerprint)
}
inline void PAMRACMessage::set_user_fingerprint(const char* value) {
  set_has_user_fingerprint();
  if (user_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_fingerprint_ = new ::std::string;
  }
  user_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.PAMRACMessage.user_fingerprint)
}
inline void PAMRACMessage::set_user_fingerprint(const void* value, size_t size) {
  set_has_user_fingerprint();
  if (user_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_fingerprint_ = new ::std::string;
  }
  user_fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.PAMRACMessage.user_fingerprint)
}
inline ::std::string* PAMRACMessage::mutable_user_fingerprint() {
  set_has_user_fingerprint();
  if (user_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.user_fingerprint)
  return user_fingerprint_;
}
inline ::std::string* PAMRACMessage::release_user_fingerprint() {
  clear_has_user_fingerprint();
  if (user_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_fingerprint_;
    user_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PAMRACMessage::set_allocated_user_fingerprint(::std::string* user_fingerprint) {
  if (user_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_fingerprint_;
  }
  if (user_fingerprint) {
    set_has_user_fingerprint();
    user_fingerprint_ = user_fingerprint;
  } else {
    clear_has_user_fingerprint();
    user_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.user_fingerprint)
}

// required .pamrac.PAMRACMessage.Type type = 2;
inline bool PAMRACMessage::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PAMRACMessage::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PAMRACMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PAMRACMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pamrac::PAMRACMessage_Type PAMRACMessage::type() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.type)
  return static_cast< ::pamrac::PAMRACMessage_Type >(type_);
}
inline void PAMRACMessage::set_type(::pamrac::PAMRACMessage_Type value) {
  assert(::pamrac::PAMRACMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pamrac.PAMRACMessage.type)
}

// optional .pamrac.InitBlobRequest init_blob_request = 3;
inline bool PAMRACMessage::has_init_blob_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PAMRACMessage::set_has_init_blob_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PAMRACMessage::clear_has_init_blob_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PAMRACMessage::clear_init_blob_request() {
  if (init_blob_request_ != NULL) init_blob_request_->::pamrac::InitBlobRequest::Clear();
  clear_has_init_blob_request();
}
inline const ::pamrac::InitBlobRequest& PAMRACMessage::init_blob_request() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.init_blob_request)
  return init_blob_request_ != NULL ? *init_blob_request_ : *default_instance_->init_blob_request_;
}
inline ::pamrac::InitBlobRequest* PAMRACMessage::mutable_init_blob_request() {
  set_has_init_blob_request();
  if (init_blob_request_ == NULL) init_blob_request_ = new ::pamrac::InitBlobRequest;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.init_blob_request)
  return init_blob_request_;
}
inline ::pamrac::InitBlobRequest* PAMRACMessage::release_init_blob_request() {
  clear_has_init_blob_request();
  ::pamrac::InitBlobRequest* temp = init_blob_request_;
  init_blob_request_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_init_blob_request(::pamrac::InitBlobRequest* init_blob_request) {
  delete init_blob_request_;
  init_blob_request_ = init_blob_request;
  if (init_blob_request) {
    set_has_init_blob_request();
  } else {
    clear_has_init_blob_request();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.init_blob_request)
}

// optional .pamrac.InitBlobResponse init_blob_response = 4;
inline bool PAMRACMessage::has_init_blob_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PAMRACMessage::set_has_init_blob_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PAMRACMessage::clear_has_init_blob_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PAMRACMessage::clear_init_blob_response() {
  if (init_blob_response_ != NULL) init_blob_response_->::pamrac::InitBlobResponse::Clear();
  clear_has_init_blob_response();
}
inline const ::pamrac::InitBlobResponse& PAMRACMessage::init_blob_response() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.init_blob_response)
  return init_blob_response_ != NULL ? *init_blob_response_ : *default_instance_->init_blob_response_;
}
inline ::pamrac::InitBlobResponse* PAMRACMessage::mutable_init_blob_response() {
  set_has_init_blob_response();
  if (init_blob_response_ == NULL) init_blob_response_ = new ::pamrac::InitBlobResponse;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.init_blob_response)
  return init_blob_response_;
}
inline ::pamrac::InitBlobResponse* PAMRACMessage::release_init_blob_response() {
  clear_has_init_blob_response();
  ::pamrac::InitBlobResponse* temp = init_blob_response_;
  init_blob_response_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_init_blob_response(::pamrac::InitBlobResponse* init_blob_response) {
  delete init_blob_response_;
  init_blob_response_ = init_blob_response;
  if (init_blob_response) {
    set_has_init_blob_response();
  } else {
    clear_has_init_blob_response();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.init_blob_response)
}

// optional .pamrac.BlobRequest blob_request = 5;
inline bool PAMRACMessage::has_blob_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PAMRACMessage::set_has_blob_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PAMRACMessage::clear_has_blob_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PAMRACMessage::clear_blob_request() {
  if (blob_request_ != NULL) blob_request_->::pamrac::BlobRequest::Clear();
  clear_has_blob_request();
}
inline const ::pamrac::BlobRequest& PAMRACMessage::blob_request() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.blob_request)
  return blob_request_ != NULL ? *blob_request_ : *default_instance_->blob_request_;
}
inline ::pamrac::BlobRequest* PAMRACMessage::mutable_blob_request() {
  set_has_blob_request();
  if (blob_request_ == NULL) blob_request_ = new ::pamrac::BlobRequest;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.blob_request)
  return blob_request_;
}
inline ::pamrac::BlobRequest* PAMRACMessage::release_blob_request() {
  clear_has_blob_request();
  ::pamrac::BlobRequest* temp = blob_request_;
  blob_request_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_blob_request(::pamrac::BlobRequest* blob_request) {
  delete blob_request_;
  blob_request_ = blob_request;
  if (blob_request) {
    set_has_blob_request();
  } else {
    clear_has_blob_request();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.blob_request)
}

// optional .pamrac.BlobResponse blob_response = 6;
inline bool PAMRACMessage::has_blob_response() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PAMRACMessage::set_has_blob_response() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PAMRACMessage::clear_has_blob_response() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PAMRACMessage::clear_blob_response() {
  if (blob_response_ != NULL) blob_response_->::pamrac::BlobResponse::Clear();
  clear_has_blob_response();
}
inline const ::pamrac::BlobResponse& PAMRACMessage::blob_response() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.blob_response)
  return blob_response_ != NULL ? *blob_response_ : *default_instance_->blob_response_;
}
inline ::pamrac::BlobResponse* PAMRACMessage::mutable_blob_response() {
  set_has_blob_response();
  if (blob_response_ == NULL) blob_response_ = new ::pamrac::BlobResponse;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.blob_response)
  return blob_response_;
}
inline ::pamrac::BlobResponse* PAMRACMessage::release_blob_response() {
  clear_has_blob_response();
  ::pamrac::BlobResponse* temp = blob_response_;
  blob_response_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_blob_response(::pamrac::BlobResponse* blob_response) {
  delete blob_response_;
  blob_response_ = blob_response;
  if (blob_response) {
    set_has_blob_response();
  } else {
    clear_has_blob_response();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.blob_response)
}

// optional .pamrac.BlobUpload blob_upload = 7;
inline bool PAMRACMessage::has_blob_upload() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PAMRACMessage::set_has_blob_upload() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PAMRACMessage::clear_has_blob_upload() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PAMRACMessage::clear_blob_upload() {
  if (blob_upload_ != NULL) blob_upload_->::pamrac::BlobUpload::Clear();
  clear_has_blob_upload();
}
inline const ::pamrac::BlobUpload& PAMRACMessage::blob_upload() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.blob_upload)
  return blob_upload_ != NULL ? *blob_upload_ : *default_instance_->blob_upload_;
}
inline ::pamrac::BlobUpload* PAMRACMessage::mutable_blob_upload() {
  set_has_blob_upload();
  if (blob_upload_ == NULL) blob_upload_ = new ::pamrac::BlobUpload;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.blob_upload)
  return blob_upload_;
}
inline ::pamrac::BlobUpload* PAMRACMessage::release_blob_upload() {
  clear_has_blob_upload();
  ::pamrac::BlobUpload* temp = blob_upload_;
  blob_upload_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_blob_upload(::pamrac::BlobUpload* blob_upload) {
  delete blob_upload_;
  blob_upload_ = blob_upload;
  if (blob_upload) {
    set_has_blob_upload();
  } else {
    clear_has_blob_upload();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.blob_upload)
}

// optional .pamrac.BlobUploadResult blob_upload_result = 8;
inline bool PAMRACMessage::has_blob_upload_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PAMRACMessage::set_has_blob_upload_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PAMRACMessage::clear_has_blob_upload_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PAMRACMessage::clear_blob_upload_result() {
  if (blob_upload_result_ != NULL) blob_upload_result_->::pamrac::BlobUploadResult::Clear();
  clear_has_blob_upload_result();
}
inline const ::pamrac::BlobUploadResult& PAMRACMessage::blob_upload_result() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.blob_upload_result)
  return blob_upload_result_ != NULL ? *blob_upload_result_ : *default_instance_->blob_upload_result_;
}
inline ::pamrac::BlobUploadResult* PAMRACMessage::mutable_blob_upload_result() {
  set_has_blob_upload_result();
  if (blob_upload_result_ == NULL) blob_upload_result_ = new ::pamrac::BlobUploadResult;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.blob_upload_result)
  return blob_upload_result_;
}
inline ::pamrac::BlobUploadResult* PAMRACMessage::release_blob_upload_result() {
  clear_has_blob_upload_result();
  ::pamrac::BlobUploadResult* temp = blob_upload_result_;
  blob_upload_result_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_blob_upload_result(::pamrac::BlobUploadResult* blob_upload_result) {
  delete blob_upload_result_;
  blob_upload_result_ = blob_upload_result;
  if (blob_upload_result) {
    set_has_blob_upload_result();
  } else {
    clear_has_blob_upload_result();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.blob_upload_result)
}

// optional .pamrac.NonceResponse nonce_response = 9;
inline bool PAMRACMessage::has_nonce_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PAMRACMessage::set_has_nonce_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PAMRACMessage::clear_has_nonce_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PAMRACMessage::clear_nonce_response() {
  if (nonce_response_ != NULL) nonce_response_->::pamrac::NonceResponse::Clear();
  clear_has_nonce_response();
}
inline const ::pamrac::NonceResponse& PAMRACMessage::nonce_response() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.nonce_response)
  return nonce_response_ != NULL ? *nonce_response_ : *default_instance_->nonce_response_;
}
inline ::pamrac::NonceResponse* PAMRACMessage::mutable_nonce_response() {
  set_has_nonce_response();
  if (nonce_response_ == NULL) nonce_response_ = new ::pamrac::NonceResponse;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.nonce_response)
  return nonce_response_;
}
inline ::pamrac::NonceResponse* PAMRACMessage::release_nonce_response() {
  clear_has_nonce_response();
  ::pamrac::NonceResponse* temp = nonce_response_;
  nonce_response_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_nonce_response(::pamrac::NonceResponse* nonce_response) {
  delete nonce_response_;
  nonce_response_ = nonce_response;
  if (nonce_response) {
    set_has_nonce_response();
  } else {
    clear_has_nonce_response();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.nonce_response)
}

// optional .pamrac.ShareUpload share_upload = 10;
inline bool PAMRACMessage::has_share_upload() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PAMRACMessage::set_has_share_upload() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PAMRACMessage::clear_has_share_upload() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PAMRACMessage::clear_share_upload() {
  if (share_upload_ != NULL) share_upload_->::pamrac::ShareUpload::Clear();
  clear_has_share_upload();
}
inline const ::pamrac::ShareUpload& PAMRACMessage::share_upload() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.share_upload)
  return share_upload_ != NULL ? *share_upload_ : *default_instance_->share_upload_;
}
inline ::pamrac::ShareUpload* PAMRACMessage::mutable_share_upload() {
  set_has_share_upload();
  if (share_upload_ == NULL) share_upload_ = new ::pamrac::ShareUpload;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.share_upload)
  return share_upload_;
}
inline ::pamrac::ShareUpload* PAMRACMessage::release_share_upload() {
  clear_has_share_upload();
  ::pamrac::ShareUpload* temp = share_upload_;
  share_upload_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_share_upload(::pamrac::ShareUpload* share_upload) {
  delete share_upload_;
  share_upload_ = share_upload;
  if (share_upload) {
    set_has_share_upload();
  } else {
    clear_has_share_upload();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.share_upload)
}

// optional .pamrac.ShareUploadResult share_upload_result = 11;
inline bool PAMRACMessage::has_share_upload_result() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PAMRACMessage::set_has_share_upload_result() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PAMRACMessage::clear_has_share_upload_result() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PAMRACMessage::clear_share_upload_result() {
  if (share_upload_result_ != NULL) share_upload_result_->::pamrac::ShareUploadResult::Clear();
  clear_has_share_upload_result();
}
inline const ::pamrac::ShareUploadResult& PAMRACMessage::share_upload_result() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.share_upload_result)
  return share_upload_result_ != NULL ? *share_upload_result_ : *default_instance_->share_upload_result_;
}
inline ::pamrac::ShareUploadResult* PAMRACMessage::mutable_share_upload_result() {
  set_has_share_upload_result();
  if (share_upload_result_ == NULL) share_upload_result_ = new ::pamrac::ShareUploadResult;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.share_upload_result)
  return share_upload_result_;
}
inline ::pamrac::ShareUploadResult* PAMRACMessage::release_share_upload_result() {
  clear_has_share_upload_result();
  ::pamrac::ShareUploadResult* temp = share_upload_result_;
  share_upload_result_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_share_upload_result(::pamrac::ShareUploadResult* share_upload_result) {
  delete share_upload_result_;
  share_upload_result_ = share_upload_result;
  if (share_upload_result) {
    set_has_share_upload_result();
  } else {
    clear_has_share_upload_result();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.share_upload_result)
}

// optional .pamrac.ShareRequest share_request = 12;
inline bool PAMRACMessage::has_share_request() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PAMRACMessage::set_has_share_request() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PAMRACMessage::clear_has_share_request() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PAMRACMessage::clear_share_request() {
  if (share_request_ != NULL) share_request_->::pamrac::ShareRequest::Clear();
  clear_has_share_request();
}
inline const ::pamrac::ShareRequest& PAMRACMessage::share_request() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.share_request)
  return share_request_ != NULL ? *share_request_ : *default_instance_->share_request_;
}
inline ::pamrac::ShareRequest* PAMRACMessage::mutable_share_request() {
  set_has_share_request();
  if (share_request_ == NULL) share_request_ = new ::pamrac::ShareRequest;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.share_request)
  return share_request_;
}
inline ::pamrac::ShareRequest* PAMRACMessage::release_share_request() {
  clear_has_share_request();
  ::pamrac::ShareRequest* temp = share_request_;
  share_request_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_share_request(::pamrac::ShareRequest* share_request) {
  delete share_request_;
  share_request_ = share_request;
  if (share_request) {
    set_has_share_request();
  } else {
    clear_has_share_request();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.share_request)
}

// optional .pamrac.KeyShare key_share = 13;
inline bool PAMRACMessage::has_key_share() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PAMRACMessage::set_has_key_share() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PAMRACMessage::clear_has_key_share() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PAMRACMessage::clear_key_share() {
  if (key_share_ != NULL) key_share_->::pamrac::KeyShare::Clear();
  clear_has_key_share();
}
inline const ::pamrac::KeyShare& PAMRACMessage::key_share() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.key_share)
  return key_share_ != NULL ? *key_share_ : *default_instance_->key_share_;
}
inline ::pamrac::KeyShare* PAMRACMessage::mutable_key_share() {
  set_has_key_share();
  if (key_share_ == NULL) key_share_ = new ::pamrac::KeyShare;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.key_share)
  return key_share_;
}
inline ::pamrac::KeyShare* PAMRACMessage::release_key_share() {
  clear_has_key_share();
  ::pamrac::KeyShare* temp = key_share_;
  key_share_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_key_share(::pamrac::KeyShare* key_share) {
  delete key_share_;
  key_share_ = key_share;
  if (key_share) {
    set_has_key_share();
  } else {
    clear_has_key_share();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.key_share)
}

// optional .pamrac.ShareListRequest share_list_request = 14;
inline bool PAMRACMessage::has_share_list_request() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PAMRACMessage::set_has_share_list_request() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PAMRACMessage::clear_has_share_list_request() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PAMRACMessage::clear_share_list_request() {
  if (share_list_request_ != NULL) share_list_request_->::pamrac::ShareListRequest::Clear();
  clear_has_share_list_request();
}
inline const ::pamrac::ShareListRequest& PAMRACMessage::share_list_request() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.share_list_request)
  return share_list_request_ != NULL ? *share_list_request_ : *default_instance_->share_list_request_;
}
inline ::pamrac::ShareListRequest* PAMRACMessage::mutable_share_list_request() {
  set_has_share_list_request();
  if (share_list_request_ == NULL) share_list_request_ = new ::pamrac::ShareListRequest;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.share_list_request)
  return share_list_request_;
}
inline ::pamrac::ShareListRequest* PAMRACMessage::release_share_list_request() {
  clear_has_share_list_request();
  ::pamrac::ShareListRequest* temp = share_list_request_;
  share_list_request_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_share_list_request(::pamrac::ShareListRequest* share_list_request) {
  delete share_list_request_;
  share_list_request_ = share_list_request;
  if (share_list_request) {
    set_has_share_list_request();
  } else {
    clear_has_share_list_request();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.share_list_request)
}

// optional .pamrac.ShareList share_list = 15;
inline bool PAMRACMessage::has_share_list() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PAMRACMessage::set_has_share_list() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PAMRACMessage::clear_has_share_list() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PAMRACMessage::clear_share_list() {
  if (share_list_ != NULL) share_list_->::pamrac::ShareList::Clear();
  clear_has_share_list();
}
inline const ::pamrac::ShareList& PAMRACMessage::share_list() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.share_list)
  return share_list_ != NULL ? *share_list_ : *default_instance_->share_list_;
}
inline ::pamrac::ShareList* PAMRACMessage::mutable_share_list() {
  set_has_share_list();
  if (share_list_ == NULL) share_list_ = new ::pamrac::ShareList;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.share_list)
  return share_list_;
}
inline ::pamrac::ShareList* PAMRACMessage::release_share_list() {
  clear_has_share_list();
  ::pamrac::ShareList* temp = share_list_;
  share_list_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_share_list(::pamrac::ShareList* share_list) {
  delete share_list_;
  share_list_ = share_list;
  if (share_list) {
    set_has_share_list();
  } else {
    clear_has_share_list();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.share_list)
}

// optional .pamrac.ConnectToNewStore connect_to_new_store = 16;
inline bool PAMRACMessage::has_connect_to_new_store() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PAMRACMessage::set_has_connect_to_new_store() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PAMRACMessage::clear_has_connect_to_new_store() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PAMRACMessage::clear_connect_to_new_store() {
  if (connect_to_new_store_ != NULL) connect_to_new_store_->::pamrac::ConnectToNewStore::Clear();
  clear_has_connect_to_new_store();
}
inline const ::pamrac::ConnectToNewStore& PAMRACMessage::connect_to_new_store() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.connect_to_new_store)
  return connect_to_new_store_ != NULL ? *connect_to_new_store_ : *default_instance_->connect_to_new_store_;
}
inline ::pamrac::ConnectToNewStore* PAMRACMessage::mutable_connect_to_new_store() {
  set_has_connect_to_new_store();
  if (connect_to_new_store_ == NULL) connect_to_new_store_ = new ::pamrac::ConnectToNewStore;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.connect_to_new_store)
  return connect_to_new_store_;
}
inline ::pamrac::ConnectToNewStore* PAMRACMessage::release_connect_to_new_store() {
  clear_has_connect_to_new_store();
  ::pamrac::ConnectToNewStore* temp = connect_to_new_store_;
  connect_to_new_store_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_connect_to_new_store(::pamrac::ConnectToNewStore* connect_to_new_store) {
  delete connect_to_new_store_;
  connect_to_new_store_ = connect_to_new_store;
  if (connect_to_new_store) {
    set_has_connect_to_new_store();
  } else {
    clear_has_connect_to_new_store();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.connect_to_new_store)
}

// optional .pamrac.NewStoreConnectResult new_store_connect_result = 17;
inline bool PAMRACMessage::has_new_store_connect_result() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PAMRACMessage::set_has_new_store_connect_result() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PAMRACMessage::clear_has_new_store_connect_result() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PAMRACMessage::clear_new_store_connect_result() {
  if (new_store_connect_result_ != NULL) new_store_connect_result_->::pamrac::NewStoreConnectResult::Clear();
  clear_has_new_store_connect_result();
}
inline const ::pamrac::NewStoreConnectResult& PAMRACMessage::new_store_connect_result() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.new_store_connect_result)
  return new_store_connect_result_ != NULL ? *new_store_connect_result_ : *default_instance_->new_store_connect_result_;
}
inline ::pamrac::NewStoreConnectResult* PAMRACMessage::mutable_new_store_connect_result() {
  set_has_new_store_connect_result();
  if (new_store_connect_result_ == NULL) new_store_connect_result_ = new ::pamrac::NewStoreConnectResult;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.new_store_connect_result)
  return new_store_connect_result_;
}
inline ::pamrac::NewStoreConnectResult* PAMRACMessage::release_new_store_connect_result() {
  clear_has_new_store_connect_result();
  ::pamrac::NewStoreConnectResult* temp = new_store_connect_result_;
  new_store_connect_result_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_new_store_connect_result(::pamrac::NewStoreConnectResult* new_store_connect_result) {
  delete new_store_connect_result_;
  new_store_connect_result_ = new_store_connect_result;
  if (new_store_connect_result) {
    set_has_new_store_connect_result();
  } else {
    clear_has_new_store_connect_result();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.new_store_connect_result)
}

// optional .pamrac.ConnectFriendServerResult connect_friend_server_result = 18;
inline bool PAMRACMessage::has_connect_friend_server_result() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PAMRACMessage::set_has_connect_friend_server_result() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PAMRACMessage::clear_has_connect_friend_server_result() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PAMRACMessage::clear_connect_friend_server_result() {
  if (connect_friend_server_result_ != NULL) connect_friend_server_result_->::pamrac::ConnectFriendServerResult::Clear();
  clear_has_connect_friend_server_result();
}
inline const ::pamrac::ConnectFriendServerResult& PAMRACMessage::connect_friend_server_result() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.connect_friend_server_result)
  return connect_friend_server_result_ != NULL ? *connect_friend_server_result_ : *default_instance_->connect_friend_server_result_;
}
inline ::pamrac::ConnectFriendServerResult* PAMRACMessage::mutable_connect_friend_server_result() {
  set_has_connect_friend_server_result();
  if (connect_friend_server_result_ == NULL) connect_friend_server_result_ = new ::pamrac::ConnectFriendServerResult;
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.connect_friend_server_result)
  return connect_friend_server_result_;
}
inline ::pamrac::ConnectFriendServerResult* PAMRACMessage::release_connect_friend_server_result() {
  clear_has_connect_friend_server_result();
  ::pamrac::ConnectFriendServerResult* temp = connect_friend_server_result_;
  connect_friend_server_result_ = NULL;
  return temp;
}
inline void PAMRACMessage::set_allocated_connect_friend_server_result(::pamrac::ConnectFriendServerResult* connect_friend_server_result) {
  delete connect_friend_server_result_;
  connect_friend_server_result_ = connect_friend_server_result;
  if (connect_friend_server_result) {
    set_has_connect_friend_server_result();
  } else {
    clear_has_connect_friend_server_result();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.connect_friend_server_result)
}

// optional bytes client_pubkey = 19;
inline bool PAMRACMessage::has_client_pubkey() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PAMRACMessage::set_has_client_pubkey() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PAMRACMessage::clear_has_client_pubkey() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PAMRACMessage::clear_client_pubkey() {
  if (client_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_pubkey_->clear();
  }
  clear_has_client_pubkey();
}
inline const ::std::string& PAMRACMessage::client_pubkey() const {
  // @@protoc_insertion_point(field_get:pamrac.PAMRACMessage.client_pubkey)
  return *client_pubkey_;
}
inline void PAMRACMessage::set_client_pubkey(const ::std::string& value) {
  set_has_client_pubkey();
  if (client_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_pubkey_ = new ::std::string;
  }
  client_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.PAMRACMessage.client_pubkey)
}
inline void PAMRACMessage::set_client_pubkey(const char* value) {
  set_has_client_pubkey();
  if (client_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_pubkey_ = new ::std::string;
  }
  client_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.PAMRACMessage.client_pubkey)
}
inline void PAMRACMessage::set_client_pubkey(const void* value, size_t size) {
  set_has_client_pubkey();
  if (client_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_pubkey_ = new ::std::string;
  }
  client_pubkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.PAMRACMessage.client_pubkey)
}
inline ::std::string* PAMRACMessage::mutable_client_pubkey() {
  set_has_client_pubkey();
  if (client_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_pubkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.PAMRACMessage.client_pubkey)
  return client_pubkey_;
}
inline ::std::string* PAMRACMessage::release_client_pubkey() {
  clear_has_client_pubkey();
  if (client_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_pubkey_;
    client_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PAMRACMessage::set_allocated_client_pubkey(::std::string* client_pubkey) {
  if (client_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_pubkey_;
  }
  if (client_pubkey) {
    set_has_client_pubkey();
    client_pubkey_ = client_pubkey;
  } else {
    clear_has_client_pubkey();
    client_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.PAMRACMessage.client_pubkey)
}

// -------------------------------------------------------------------

// NonceResponse

// required bytes nonce = 1;
inline bool NonceResponse::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NonceResponse::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NonceResponse::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NonceResponse::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& NonceResponse::nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.NonceResponse.nonce)
  return *nonce_;
}
inline void NonceResponse::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.NonceResponse.nonce)
}
inline void NonceResponse::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.NonceResponse.nonce)
}
inline void NonceResponse::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.NonceResponse.nonce)
}
inline ::std::string* NonceResponse::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.NonceResponse.nonce)
  return nonce_;
}
inline ::std::string* NonceResponse::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NonceResponse::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.NonceResponse.nonce)
}

// -------------------------------------------------------------------

// BlobFile

// optional bytes salt = 1;
inline bool BlobFile::has_salt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobFile::set_has_salt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobFile::clear_has_salt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobFile::clear_salt() {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& BlobFile::salt() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobFile.salt)
  return *salt_;
}
inline void BlobFile::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobFile.salt)
}
inline void BlobFile::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobFile.salt)
}
inline void BlobFile::set_salt(const void* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobFile.salt)
}
inline ::std::string* BlobFile::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobFile.salt)
  return salt_;
}
inline ::std::string* BlobFile::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobFile::set_allocated_salt(::std::string* salt) {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete salt_;
  }
  if (salt) {
    set_has_salt();
    salt_ = salt;
  } else {
    clear_has_salt();
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobFile.salt)
}

// required int32 version = 2;
inline bool BlobFile::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobFile::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobFile::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobFile::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 BlobFile::version() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobFile.version)
  return version_;
}
inline void BlobFile::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pamrac.BlobFile.version)
}

// required bytes aes_init_vector = 3;
inline bool BlobFile::has_aes_init_vector() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobFile::set_has_aes_init_vector() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobFile::clear_has_aes_init_vector() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobFile::clear_aes_init_vector() {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_->clear();
  }
  clear_has_aes_init_vector();
}
inline const ::std::string& BlobFile::aes_init_vector() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobFile.aes_init_vector)
  return *aes_init_vector_;
}
inline void BlobFile::set_aes_init_vector(const ::std::string& value) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobFile.aes_init_vector)
}
inline void BlobFile::set_aes_init_vector(const char* value) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobFile.aes_init_vector)
}
inline void BlobFile::set_aes_init_vector(const void* value, size_t size) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobFile.aes_init_vector)
}
inline ::std::string* BlobFile::mutable_aes_init_vector() {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobFile.aes_init_vector)
  return aes_init_vector_;
}
inline ::std::string* BlobFile::release_aes_init_vector() {
  clear_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = aes_init_vector_;
    aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobFile::set_allocated_aes_init_vector(::std::string* aes_init_vector) {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes_init_vector_;
  }
  if (aes_init_vector) {
    set_has_aes_init_vector();
    aes_init_vector_ = aes_init_vector;
  } else {
    clear_has_aes_init_vector();
    aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobFile.aes_init_vector)
}

// required bytes inner_blob_ciphertext = 4;
inline bool BlobFile::has_inner_blob_ciphertext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlobFile::set_has_inner_blob_ciphertext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlobFile::clear_has_inner_blob_ciphertext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlobFile::clear_inner_blob_ciphertext() {
  if (inner_blob_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_blob_ciphertext_->clear();
  }
  clear_has_inner_blob_ciphertext();
}
inline const ::std::string& BlobFile::inner_blob_ciphertext() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobFile.inner_blob_ciphertext)
  return *inner_blob_ciphertext_;
}
inline void BlobFile::set_inner_blob_ciphertext(const ::std::string& value) {
  set_has_inner_blob_ciphertext();
  if (inner_blob_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_blob_ciphertext_ = new ::std::string;
  }
  inner_blob_ciphertext_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobFile.inner_blob_ciphertext)
}
inline void BlobFile::set_inner_blob_ciphertext(const char* value) {
  set_has_inner_blob_ciphertext();
  if (inner_blob_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_blob_ciphertext_ = new ::std::string;
  }
  inner_blob_ciphertext_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobFile.inner_blob_ciphertext)
}
inline void BlobFile::set_inner_blob_ciphertext(const void* value, size_t size) {
  set_has_inner_blob_ciphertext();
  if (inner_blob_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_blob_ciphertext_ = new ::std::string;
  }
  inner_blob_ciphertext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobFile.inner_blob_ciphertext)
}
inline ::std::string* BlobFile::mutable_inner_blob_ciphertext() {
  set_has_inner_blob_ciphertext();
  if (inner_blob_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_blob_ciphertext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobFile.inner_blob_ciphertext)
  return inner_blob_ciphertext_;
}
inline ::std::string* BlobFile::release_inner_blob_ciphertext() {
  clear_has_inner_blob_ciphertext();
  if (inner_blob_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inner_blob_ciphertext_;
    inner_blob_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobFile::set_allocated_inner_blob_ciphertext(::std::string* inner_blob_ciphertext) {
  if (inner_blob_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_blob_ciphertext_;
  }
  if (inner_blob_ciphertext) {
    set_has_inner_blob_ciphertext();
    inner_blob_ciphertext_ = inner_blob_ciphertext;
  } else {
    clear_has_inner_blob_ciphertext();
    inner_blob_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobFile.inner_blob_ciphertext)
}

// -------------------------------------------------------------------

// InnerBlob_KeyValue

// required string name = 1;
inline bool InnerBlob_KeyValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerBlob_KeyValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerBlob_KeyValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerBlob_KeyValue::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InnerBlob_KeyValue::name() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerBlob.KeyValue.name)
  return *name_;
}
inline void InnerBlob_KeyValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerBlob.KeyValue.name)
}
inline void InnerBlob_KeyValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerBlob.KeyValue.name)
}
inline void InnerBlob_KeyValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerBlob.KeyValue.name)
}
inline ::std::string* InnerBlob_KeyValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerBlob.KeyValue.name)
  return name_;
}
inline ::std::string* InnerBlob_KeyValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerBlob_KeyValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerBlob.KeyValue.name)
}

// required string value = 2;
inline bool InnerBlob_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerBlob_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerBlob_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerBlob_KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& InnerBlob_KeyValue::value() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerBlob.KeyValue.value)
  return *value_;
}
inline void InnerBlob_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerBlob.KeyValue.value)
}
inline void InnerBlob_KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerBlob.KeyValue.value)
}
inline void InnerBlob_KeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerBlob.KeyValue.value)
}
inline ::std::string* InnerBlob_KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerBlob.KeyValue.value)
  return value_;
}
inline ::std::string* InnerBlob_KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerBlob_KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerBlob.KeyValue.value)
}

// -------------------------------------------------------------------

// InnerBlob

// required string filename = 1;
inline bool InnerBlob::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerBlob::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerBlob::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerBlob::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& InnerBlob::filename() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerBlob.filename)
  return *filename_;
}
inline void InnerBlob::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerBlob.filename)
}
inline void InnerBlob::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerBlob.filename)
}
inline void InnerBlob::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerBlob.filename)
}
inline ::std::string* InnerBlob::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerBlob.filename)
  return filename_;
}
inline ::std::string* InnerBlob::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerBlob::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerBlob.filename)
}

// repeated .pamrac.InnerBlob.KeyValue fields = 2;
inline int InnerBlob::fields_size() const {
  return fields_.size();
}
inline void InnerBlob::clear_fields() {
  fields_.Clear();
}
inline const ::pamrac::InnerBlob_KeyValue& InnerBlob::fields(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.InnerBlob.fields)
  return fields_.Get(index);
}
inline ::pamrac::InnerBlob_KeyValue* InnerBlob::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.InnerBlob.fields)
  return fields_.Mutable(index);
}
inline ::pamrac::InnerBlob_KeyValue* InnerBlob::add_fields() {
  // @@protoc_insertion_point(field_add:pamrac.InnerBlob.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::InnerBlob_KeyValue >&
InnerBlob::fields() const {
  // @@protoc_insertion_point(field_list:pamrac.InnerBlob.fields)
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::InnerBlob_KeyValue >*
InnerBlob::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.InnerBlob.fields)
  return &fields_;
}

// -------------------------------------------------------------------

// MasterKeyPasswordedFile

// required bytes salt = 1;
inline bool MasterKeyPasswordedFile::has_salt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterKeyPasswordedFile::set_has_salt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterKeyPasswordedFile::clear_has_salt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterKeyPasswordedFile::clear_salt() {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& MasterKeyPasswordedFile::salt() const {
  // @@protoc_insertion_point(field_get:pamrac.MasterKeyPasswordedFile.salt)
  return *salt_;
}
inline void MasterKeyPasswordedFile::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.MasterKeyPasswordedFile.salt)
}
inline void MasterKeyPasswordedFile::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.MasterKeyPasswordedFile.salt)
}
inline void MasterKeyPasswordedFile::set_salt(const void* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.MasterKeyPasswordedFile.salt)
}
inline ::std::string* MasterKeyPasswordedFile::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.MasterKeyPasswordedFile.salt)
  return salt_;
}
inline ::std::string* MasterKeyPasswordedFile::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterKeyPasswordedFile::set_allocated_salt(::std::string* salt) {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete salt_;
  }
  if (salt) {
    set_has_salt();
    salt_ = salt;
  } else {
    clear_has_salt();
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.MasterKeyPasswordedFile.salt)
}

// required bytes aes_init_vector = 2;
inline bool MasterKeyPasswordedFile::has_aes_init_vector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterKeyPasswordedFile::set_has_aes_init_vector() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterKeyPasswordedFile::clear_has_aes_init_vector() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterKeyPasswordedFile::clear_aes_init_vector() {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_->clear();
  }
  clear_has_aes_init_vector();
}
inline const ::std::string& MasterKeyPasswordedFile::aes_init_vector() const {
  // @@protoc_insertion_point(field_get:pamrac.MasterKeyPasswordedFile.aes_init_vector)
  return *aes_init_vector_;
}
inline void MasterKeyPasswordedFile::set_aes_init_vector(const ::std::string& value) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.MasterKeyPasswordedFile.aes_init_vector)
}
inline void MasterKeyPasswordedFile::set_aes_init_vector(const char* value) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.MasterKeyPasswordedFile.aes_init_vector)
}
inline void MasterKeyPasswordedFile::set_aes_init_vector(const void* value, size_t size) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.MasterKeyPasswordedFile.aes_init_vector)
}
inline ::std::string* MasterKeyPasswordedFile::mutable_aes_init_vector() {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.MasterKeyPasswordedFile.aes_init_vector)
  return aes_init_vector_;
}
inline ::std::string* MasterKeyPasswordedFile::release_aes_init_vector() {
  clear_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = aes_init_vector_;
    aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterKeyPasswordedFile::set_allocated_aes_init_vector(::std::string* aes_init_vector) {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes_init_vector_;
  }
  if (aes_init_vector) {
    set_has_aes_init_vector();
    aes_init_vector_ = aes_init_vector;
  } else {
    clear_has_aes_init_vector();
    aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.MasterKeyPasswordedFile.aes_init_vector)
}

// required bytes inner_ciphertext = 3;
inline bool MasterKeyPasswordedFile::has_inner_ciphertext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterKeyPasswordedFile::set_has_inner_ciphertext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterKeyPasswordedFile::clear_has_inner_ciphertext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterKeyPasswordedFile::clear_inner_ciphertext() {
  if (inner_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_ciphertext_->clear();
  }
  clear_has_inner_ciphertext();
}
inline const ::std::string& MasterKeyPasswordedFile::inner_ciphertext() const {
  // @@protoc_insertion_point(field_get:pamrac.MasterKeyPasswordedFile.inner_ciphertext)
  return *inner_ciphertext_;
}
inline void MasterKeyPasswordedFile::set_inner_ciphertext(const ::std::string& value) {
  set_has_inner_ciphertext();
  if (inner_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_ciphertext_ = new ::std::string;
  }
  inner_ciphertext_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.MasterKeyPasswordedFile.inner_ciphertext)
}
inline void MasterKeyPasswordedFile::set_inner_ciphertext(const char* value) {
  set_has_inner_ciphertext();
  if (inner_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_ciphertext_ = new ::std::string;
  }
  inner_ciphertext_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.MasterKeyPasswordedFile.inner_ciphertext)
}
inline void MasterKeyPasswordedFile::set_inner_ciphertext(const void* value, size_t size) {
  set_has_inner_ciphertext();
  if (inner_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_ciphertext_ = new ::std::string;
  }
  inner_ciphertext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.MasterKeyPasswordedFile.inner_ciphertext)
}
inline ::std::string* MasterKeyPasswordedFile::mutable_inner_ciphertext() {
  set_has_inner_ciphertext();
  if (inner_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_ciphertext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.MasterKeyPasswordedFile.inner_ciphertext)
  return inner_ciphertext_;
}
inline ::std::string* MasterKeyPasswordedFile::release_inner_ciphertext() {
  clear_has_inner_ciphertext();
  if (inner_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inner_ciphertext_;
    inner_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterKeyPasswordedFile::set_allocated_inner_ciphertext(::std::string* inner_ciphertext) {
  if (inner_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_ciphertext_;
  }
  if (inner_ciphertext) {
    set_has_inner_ciphertext();
    inner_ciphertext_ = inner_ciphertext;
  } else {
    clear_has_inner_ciphertext();
    inner_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.MasterKeyPasswordedFile.inner_ciphertext)
}

// -------------------------------------------------------------------

// InnerPassworded

// required bytes master_key = 1;
inline bool InnerPassworded::has_master_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerPassworded::set_has_master_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerPassworded::clear_has_master_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerPassworded::clear_master_key() {
  if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_->clear();
  }
  clear_has_master_key();
}
inline const ::std::string& InnerPassworded::master_key() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerPassworded.master_key)
  return *master_key_;
}
inline void InnerPassworded::set_master_key(const ::std::string& value) {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  master_key_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerPassworded.master_key)
}
inline void InnerPassworded::set_master_key(const char* value) {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  master_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerPassworded.master_key)
}
inline void InnerPassworded::set_master_key(const void* value, size_t size) {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  master_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerPassworded.master_key)
}
inline ::std::string* InnerPassworded::mutable_master_key() {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerPassworded.master_key)
  return master_key_;
}
inline ::std::string* InnerPassworded::release_master_key() {
  clear_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_key_;
    master_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerPassworded::set_allocated_master_key(::std::string* master_key) {
  if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_key_;
  }
  if (master_key) {
    set_has_master_key();
    master_key_ = master_key;
  } else {
    clear_has_master_key();
    master_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerPassworded.master_key)
}

// required bytes filenamesalt = 2;
inline bool InnerPassworded::has_filenamesalt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerPassworded::set_has_filenamesalt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerPassworded::clear_has_filenamesalt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerPassworded::clear_filenamesalt() {
  if (filenamesalt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filenamesalt_->clear();
  }
  clear_has_filenamesalt();
}
inline const ::std::string& InnerPassworded::filenamesalt() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerPassworded.filenamesalt)
  return *filenamesalt_;
}
inline void InnerPassworded::set_filenamesalt(const ::std::string& value) {
  set_has_filenamesalt();
  if (filenamesalt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filenamesalt_ = new ::std::string;
  }
  filenamesalt_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerPassworded.filenamesalt)
}
inline void InnerPassworded::set_filenamesalt(const char* value) {
  set_has_filenamesalt();
  if (filenamesalt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filenamesalt_ = new ::std::string;
  }
  filenamesalt_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerPassworded.filenamesalt)
}
inline void InnerPassworded::set_filenamesalt(const void* value, size_t size) {
  set_has_filenamesalt();
  if (filenamesalt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filenamesalt_ = new ::std::string;
  }
  filenamesalt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerPassworded.filenamesalt)
}
inline ::std::string* InnerPassworded::mutable_filenamesalt() {
  set_has_filenamesalt();
  if (filenamesalt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filenamesalt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerPassworded.filenamesalt)
  return filenamesalt_;
}
inline ::std::string* InnerPassworded::release_filenamesalt() {
  clear_has_filenamesalt();
  if (filenamesalt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filenamesalt_;
    filenamesalt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerPassworded::set_allocated_filenamesalt(::std::string* filenamesalt) {
  if (filenamesalt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filenamesalt_;
  }
  if (filenamesalt) {
    set_has_filenamesalt();
    filenamesalt_ = filenamesalt;
  } else {
    clear_has_filenamesalt();
    filenamesalt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerPassworded.filenamesalt)
}

// repeated string site_names = 3;
inline int InnerPassworded::site_names_size() const {
  return site_names_.size();
}
inline void InnerPassworded::clear_site_names() {
  site_names_.Clear();
}
inline const ::std::string& InnerPassworded::site_names(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.InnerPassworded.site_names)
  return site_names_.Get(index);
}
inline ::std::string* InnerPassworded::mutable_site_names(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.InnerPassworded.site_names)
  return site_names_.Mutable(index);
}
inline void InnerPassworded::set_site_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pamrac.InnerPassworded.site_names)
  site_names_.Mutable(index)->assign(value);
}
inline void InnerPassworded::set_site_names(int index, const char* value) {
  site_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerPassworded.site_names)
}
inline void InnerPassworded::set_site_names(int index, const char* value, size_t size) {
  site_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerPassworded.site_names)
}
inline ::std::string* InnerPassworded::add_site_names() {
  return site_names_.Add();
}
inline void InnerPassworded::add_site_names(const ::std::string& value) {
  site_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pamrac.InnerPassworded.site_names)
}
inline void InnerPassworded::add_site_names(const char* value) {
  site_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pamrac.InnerPassworded.site_names)
}
inline void InnerPassworded::add_site_names(const char* value, size_t size) {
  site_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pamrac.InnerPassworded.site_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InnerPassworded::site_names() const {
  // @@protoc_insertion_point(field_list:pamrac.InnerPassworded.site_names)
  return site_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InnerPassworded::mutable_site_names() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.InnerPassworded.site_names)
  return &site_names_;
}

// required bytes downloadsecret = 4;
inline bool InnerPassworded::has_downloadsecret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InnerPassworded::set_has_downloadsecret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InnerPassworded::clear_has_downloadsecret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InnerPassworded::clear_downloadsecret() {
  if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_->clear();
  }
  clear_has_downloadsecret();
}
inline const ::std::string& InnerPassworded::downloadsecret() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerPassworded.downloadsecret)
  return *downloadsecret_;
}
inline void InnerPassworded::set_downloadsecret(const ::std::string& value) {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  downloadsecret_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerPassworded.downloadsecret)
}
inline void InnerPassworded::set_downloadsecret(const char* value) {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  downloadsecret_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerPassworded.downloadsecret)
}
inline void InnerPassworded::set_downloadsecret(const void* value, size_t size) {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  downloadsecret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerPassworded.downloadsecret)
}
inline ::std::string* InnerPassworded::mutable_downloadsecret() {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerPassworded.downloadsecret)
  return downloadsecret_;
}
inline ::std::string* InnerPassworded::release_downloadsecret() {
  clear_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = downloadsecret_;
    downloadsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerPassworded::set_allocated_downloadsecret(::std::string* downloadsecret) {
  if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete downloadsecret_;
  }
  if (downloadsecret) {
    set_has_downloadsecret();
    downloadsecret_ = downloadsecret;
  } else {
    clear_has_downloadsecret();
    downloadsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerPassworded.downloadsecret)
}

// required bytes private_key = 5;
inline bool InnerPassworded::has_private_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InnerPassworded::set_has_private_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InnerPassworded::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InnerPassworded::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& InnerPassworded::private_key() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerPassworded.private_key)
  return *private_key_;
}
inline void InnerPassworded::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerPassworded.private_key)
}
inline void InnerPassworded::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerPassworded.private_key)
}
inline void InnerPassworded::set_private_key(const void* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerPassworded.private_key)
}
inline ::std::string* InnerPassworded::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    private_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerPassworded.private_key)
  return private_key_;
}
inline ::std::string* InnerPassworded::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerPassworded::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerPassworded.private_key)
}

// -------------------------------------------------------------------

// MasterKeyRetrievableFile

// required int64 timestamp = 1;
inline bool MasterKeyRetrievableFile::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterKeyRetrievableFile::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterKeyRetrievableFile::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterKeyRetrievableFile::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MasterKeyRetrievableFile::timestamp() const {
  // @@protoc_insertion_point(field_get:pamrac.MasterKeyRetrievableFile.timestamp)
  return timestamp_;
}
inline void MasterKeyRetrievableFile::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pamrac.MasterKeyRetrievableFile.timestamp)
}

// required bytes aes_init_vector = 2;
inline bool MasterKeyRetrievableFile::has_aes_init_vector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterKeyRetrievableFile::set_has_aes_init_vector() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterKeyRetrievableFile::clear_has_aes_init_vector() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterKeyRetrievableFile::clear_aes_init_vector() {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_->clear();
  }
  clear_has_aes_init_vector();
}
inline const ::std::string& MasterKeyRetrievableFile::aes_init_vector() const {
  // @@protoc_insertion_point(field_get:pamrac.MasterKeyRetrievableFile.aes_init_vector)
  return *aes_init_vector_;
}
inline void MasterKeyRetrievableFile::set_aes_init_vector(const ::std::string& value) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.MasterKeyRetrievableFile.aes_init_vector)
}
inline void MasterKeyRetrievableFile::set_aes_init_vector(const char* value) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.MasterKeyRetrievableFile.aes_init_vector)
}
inline void MasterKeyRetrievableFile::set_aes_init_vector(const void* value, size_t size) {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  aes_init_vector_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.MasterKeyRetrievableFile.aes_init_vector)
}
inline ::std::string* MasterKeyRetrievableFile::mutable_aes_init_vector() {
  set_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes_init_vector_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.MasterKeyRetrievableFile.aes_init_vector)
  return aes_init_vector_;
}
inline ::std::string* MasterKeyRetrievableFile::release_aes_init_vector() {
  clear_has_aes_init_vector();
  if (aes_init_vector_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = aes_init_vector_;
    aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterKeyRetrievableFile::set_allocated_aes_init_vector(::std::string* aes_init_vector) {
  if (aes_init_vector_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes_init_vector_;
  }
  if (aes_init_vector) {
    set_has_aes_init_vector();
    aes_init_vector_ = aes_init_vector;
  } else {
    clear_has_aes_init_vector();
    aes_init_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.MasterKeyRetrievableFile.aes_init_vector)
}

// required bytes inner_retrievable_ciphertext = 3;
inline bool MasterKeyRetrievableFile::has_inner_retrievable_ciphertext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterKeyRetrievableFile::set_has_inner_retrievable_ciphertext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterKeyRetrievableFile::clear_has_inner_retrievable_ciphertext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterKeyRetrievableFile::clear_inner_retrievable_ciphertext() {
  if (inner_retrievable_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_retrievable_ciphertext_->clear();
  }
  clear_has_inner_retrievable_ciphertext();
}
inline const ::std::string& MasterKeyRetrievableFile::inner_retrievable_ciphertext() const {
  // @@protoc_insertion_point(field_get:pamrac.MasterKeyRetrievableFile.inner_retrievable_ciphertext)
  return *inner_retrievable_ciphertext_;
}
inline void MasterKeyRetrievableFile::set_inner_retrievable_ciphertext(const ::std::string& value) {
  set_has_inner_retrievable_ciphertext();
  if (inner_retrievable_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_retrievable_ciphertext_ = new ::std::string;
  }
  inner_retrievable_ciphertext_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.MasterKeyRetrievableFile.inner_retrievable_ciphertext)
}
inline void MasterKeyRetrievableFile::set_inner_retrievable_ciphertext(const char* value) {
  set_has_inner_retrievable_ciphertext();
  if (inner_retrievable_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_retrievable_ciphertext_ = new ::std::string;
  }
  inner_retrievable_ciphertext_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.MasterKeyRetrievableFile.inner_retrievable_ciphertext)
}
inline void MasterKeyRetrievableFile::set_inner_retrievable_ciphertext(const void* value, size_t size) {
  set_has_inner_retrievable_ciphertext();
  if (inner_retrievable_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_retrievable_ciphertext_ = new ::std::string;
  }
  inner_retrievable_ciphertext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.MasterKeyRetrievableFile.inner_retrievable_ciphertext)
}
inline ::std::string* MasterKeyRetrievableFile::mutable_inner_retrievable_ciphertext() {
  set_has_inner_retrievable_ciphertext();
  if (inner_retrievable_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inner_retrievable_ciphertext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.MasterKeyRetrievableFile.inner_retrievable_ciphertext)
  return inner_retrievable_ciphertext_;
}
inline ::std::string* MasterKeyRetrievableFile::release_inner_retrievable_ciphertext() {
  clear_has_inner_retrievable_ciphertext();
  if (inner_retrievable_ciphertext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inner_retrievable_ciphertext_;
    inner_retrievable_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MasterKeyRetrievableFile::set_allocated_inner_retrievable_ciphertext(::std::string* inner_retrievable_ciphertext) {
  if (inner_retrievable_ciphertext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inner_retrievable_ciphertext_;
  }
  if (inner_retrievable_ciphertext) {
    set_has_inner_retrievable_ciphertext();
    inner_retrievable_ciphertext_ = inner_retrievable_ciphertext;
  } else {
    clear_has_inner_retrievable_ciphertext();
    inner_retrievable_ciphertext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.MasterKeyRetrievableFile.inner_retrievable_ciphertext)
}

// -------------------------------------------------------------------

// InnerRetrievable

// required bytes master_key = 1;
inline bool InnerRetrievable::has_master_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InnerRetrievable::set_has_master_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InnerRetrievable::clear_has_master_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InnerRetrievable::clear_master_key() {
  if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_->clear();
  }
  clear_has_master_key();
}
inline const ::std::string& InnerRetrievable::master_key() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerRetrievable.master_key)
  return *master_key_;
}
inline void InnerRetrievable::set_master_key(const ::std::string& value) {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  master_key_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerRetrievable.master_key)
}
inline void InnerRetrievable::set_master_key(const char* value) {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  master_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerRetrievable.master_key)
}
inline void InnerRetrievable::set_master_key(const void* value, size_t size) {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  master_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerRetrievable.master_key)
}
inline ::std::string* InnerRetrievable::mutable_master_key() {
  set_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerRetrievable.master_key)
  return master_key_;
}
inline ::std::string* InnerRetrievable::release_master_key() {
  clear_has_master_key();
  if (master_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_key_;
    master_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerRetrievable::set_allocated_master_key(::std::string* master_key) {
  if (master_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_key_;
  }
  if (master_key) {
    set_has_master_key();
    master_key_ = master_key;
  } else {
    clear_has_master_key();
    master_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerRetrievable.master_key)
}

// required bytes DOWNLOADSECRET = 2;
inline bool InnerRetrievable::has_downloadsecret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerRetrievable::set_has_downloadsecret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerRetrievable::clear_has_downloadsecret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerRetrievable::clear_downloadsecret() {
  if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_->clear();
  }
  clear_has_downloadsecret();
}
inline const ::std::string& InnerRetrievable::downloadsecret() const {
  // @@protoc_insertion_point(field_get:pamrac.InnerRetrievable.DOWNLOADSECRET)
  return *downloadsecret_;
}
inline void InnerRetrievable::set_downloadsecret(const ::std::string& value) {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  downloadsecret_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InnerRetrievable.DOWNLOADSECRET)
}
inline void InnerRetrievable::set_downloadsecret(const char* value) {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  downloadsecret_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InnerRetrievable.DOWNLOADSECRET)
}
inline void InnerRetrievable::set_downloadsecret(const void* value, size_t size) {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  downloadsecret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InnerRetrievable.DOWNLOADSECRET)
}
inline ::std::string* InnerRetrievable::mutable_downloadsecret() {
  set_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InnerRetrievable.DOWNLOADSECRET)
  return downloadsecret_;
}
inline ::std::string* InnerRetrievable::release_downloadsecret() {
  clear_has_downloadsecret();
  if (downloadsecret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = downloadsecret_;
    downloadsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InnerRetrievable::set_allocated_downloadsecret(::std::string* downloadsecret) {
  if (downloadsecret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete downloadsecret_;
  }
  if (downloadsecret) {
    set_has_downloadsecret();
    downloadsecret_ = downloadsecret;
  } else {
    clear_has_downloadsecret();
    downloadsecret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InnerRetrievable.DOWNLOADSECRET)
}

// -------------------------------------------------------------------

// InitBlobRequest

// required bytes all_hash_xor = 1;
inline bool InitBlobRequest::has_all_hash_xor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitBlobRequest::set_has_all_hash_xor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitBlobRequest::clear_has_all_hash_xor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitBlobRequest::clear_all_hash_xor() {
  if (all_hash_xor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    all_hash_xor_->clear();
  }
  clear_has_all_hash_xor();
}
inline const ::std::string& InitBlobRequest::all_hash_xor() const {
  // @@protoc_insertion_point(field_get:pamrac.InitBlobRequest.all_hash_xor)
  return *all_hash_xor_;
}
inline void InitBlobRequest::set_all_hash_xor(const ::std::string& value) {
  set_has_all_hash_xor();
  if (all_hash_xor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    all_hash_xor_ = new ::std::string;
  }
  all_hash_xor_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InitBlobRequest.all_hash_xor)
}
inline void InitBlobRequest::set_all_hash_xor(const char* value) {
  set_has_all_hash_xor();
  if (all_hash_xor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    all_hash_xor_ = new ::std::string;
  }
  all_hash_xor_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InitBlobRequest.all_hash_xor)
}
inline void InitBlobRequest::set_all_hash_xor(const void* value, size_t size) {
  set_has_all_hash_xor();
  if (all_hash_xor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    all_hash_xor_ = new ::std::string;
  }
  all_hash_xor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InitBlobRequest.all_hash_xor)
}
inline ::std::string* InitBlobRequest::mutable_all_hash_xor() {
  set_has_all_hash_xor();
  if (all_hash_xor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    all_hash_xor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InitBlobRequest.all_hash_xor)
  return all_hash_xor_;
}
inline ::std::string* InitBlobRequest::release_all_hash_xor() {
  clear_has_all_hash_xor();
  if (all_hash_xor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = all_hash_xor_;
    all_hash_xor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitBlobRequest::set_allocated_all_hash_xor(::std::string* all_hash_xor) {
  if (all_hash_xor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete all_hash_xor_;
  }
  if (all_hash_xor) {
    set_has_all_hash_xor();
    all_hash_xor_ = all_hash_xor;
  } else {
    clear_has_all_hash_xor();
    all_hash_xor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InitBlobRequest.all_hash_xor)
}

// -------------------------------------------------------------------

// InitBlobResponse

// required bool xor_matches = 1;
inline bool InitBlobResponse::has_xor_matches() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitBlobResponse::set_has_xor_matches() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitBlobResponse::clear_has_xor_matches() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitBlobResponse::clear_xor_matches() {
  xor_matches_ = false;
  clear_has_xor_matches();
}
inline bool InitBlobResponse::xor_matches() const {
  // @@protoc_insertion_point(field_get:pamrac.InitBlobResponse.xor_matches)
  return xor_matches_;
}
inline void InitBlobResponse::set_xor_matches(bool value) {
  set_has_xor_matches();
  xor_matches_ = value;
  // @@protoc_insertion_point(field_set:pamrac.InitBlobResponse.xor_matches)
}

// optional bytes nonce = 2;
inline bool InitBlobResponse::has_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitBlobResponse::set_has_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitBlobResponse::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitBlobResponse::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& InitBlobResponse::nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.InitBlobResponse.nonce)
  return *nonce_;
}
inline void InitBlobResponse::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.InitBlobResponse.nonce)
}
inline void InitBlobResponse::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.InitBlobResponse.nonce)
}
inline void InitBlobResponse::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.InitBlobResponse.nonce)
}
inline ::std::string* InitBlobResponse::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.InitBlobResponse.nonce)
  return nonce_;
}
inline ::std::string* InitBlobResponse::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitBlobResponse::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.InitBlobResponse.nonce)
}

// -------------------------------------------------------------------

// BlobRequest_BlobHash

// required string blob_name = 1;
inline bool BlobRequest_BlobHash::has_blob_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobRequest_BlobHash::set_has_blob_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobRequest_BlobHash::clear_has_blob_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobRequest_BlobHash::clear_blob_name() {
  if (blob_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_name_->clear();
  }
  clear_has_blob_name();
}
inline const ::std::string& BlobRequest_BlobHash::blob_name() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobRequest.BlobHash.blob_name)
  return *blob_name_;
}
inline void BlobRequest_BlobHash::set_blob_name(const ::std::string& value) {
  set_has_blob_name();
  if (blob_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_name_ = new ::std::string;
  }
  blob_name_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobRequest.BlobHash.blob_name)
}
inline void BlobRequest_BlobHash::set_blob_name(const char* value) {
  set_has_blob_name();
  if (blob_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_name_ = new ::std::string;
  }
  blob_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobRequest.BlobHash.blob_name)
}
inline void BlobRequest_BlobHash::set_blob_name(const char* value, size_t size) {
  set_has_blob_name();
  if (blob_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_name_ = new ::std::string;
  }
  blob_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobRequest.BlobHash.blob_name)
}
inline ::std::string* BlobRequest_BlobHash::mutable_blob_name() {
  set_has_blob_name();
  if (blob_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobRequest.BlobHash.blob_name)
  return blob_name_;
}
inline ::std::string* BlobRequest_BlobHash::release_blob_name() {
  clear_has_blob_name();
  if (blob_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blob_name_;
    blob_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobRequest_BlobHash::set_allocated_blob_name(::std::string* blob_name) {
  if (blob_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_name_;
  }
  if (blob_name) {
    set_has_blob_name();
    blob_name_ = blob_name;
  } else {
    clear_has_blob_name();
    blob_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobRequest.BlobHash.blob_name)
}

// required bytes blob_hash = 2;
inline bool BlobRequest_BlobHash::has_blob_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobRequest_BlobHash::set_has_blob_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobRequest_BlobHash::clear_has_blob_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobRequest_BlobHash::clear_blob_hash() {
  if (blob_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_hash_->clear();
  }
  clear_has_blob_hash();
}
inline const ::std::string& BlobRequest_BlobHash::blob_hash() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobRequest.BlobHash.blob_hash)
  return *blob_hash_;
}
inline void BlobRequest_BlobHash::set_blob_hash(const ::std::string& value) {
  set_has_blob_hash();
  if (blob_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_hash_ = new ::std::string;
  }
  blob_hash_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobRequest.BlobHash.blob_hash)
}
inline void BlobRequest_BlobHash::set_blob_hash(const char* value) {
  set_has_blob_hash();
  if (blob_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_hash_ = new ::std::string;
  }
  blob_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobRequest.BlobHash.blob_hash)
}
inline void BlobRequest_BlobHash::set_blob_hash(const void* value, size_t size) {
  set_has_blob_hash();
  if (blob_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_hash_ = new ::std::string;
  }
  blob_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobRequest.BlobHash.blob_hash)
}
inline ::std::string* BlobRequest_BlobHash::mutable_blob_hash() {
  set_has_blob_hash();
  if (blob_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobRequest.BlobHash.blob_hash)
  return blob_hash_;
}
inline ::std::string* BlobRequest_BlobHash::release_blob_hash() {
  clear_has_blob_hash();
  if (blob_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blob_hash_;
    blob_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobRequest_BlobHash::set_allocated_blob_hash(::std::string* blob_hash) {
  if (blob_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_hash_;
  }
  if (blob_hash) {
    set_has_blob_hash();
    blob_hash_ = blob_hash;
  } else {
    clear_has_blob_hash();
    blob_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobRequest.BlobHash.blob_hash)
}

// -------------------------------------------------------------------

// BlobRequest

// repeated .pamrac.BlobRequest.BlobHash cached_blobs = 1;
inline int BlobRequest::cached_blobs_size() const {
  return cached_blobs_.size();
}
inline void BlobRequest::clear_cached_blobs() {
  cached_blobs_.Clear();
}
inline const ::pamrac::BlobRequest_BlobHash& BlobRequest::cached_blobs(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.BlobRequest.cached_blobs)
  return cached_blobs_.Get(index);
}
inline ::pamrac::BlobRequest_BlobHash* BlobRequest::mutable_cached_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.BlobRequest.cached_blobs)
  return cached_blobs_.Mutable(index);
}
inline ::pamrac::BlobRequest_BlobHash* BlobRequest::add_cached_blobs() {
  // @@protoc_insertion_point(field_add:pamrac.BlobRequest.cached_blobs)
  return cached_blobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::BlobRequest_BlobHash >&
BlobRequest::cached_blobs() const {
  // @@protoc_insertion_point(field_list:pamrac.BlobRequest.cached_blobs)
  return cached_blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::BlobRequest_BlobHash >*
BlobRequest::mutable_cached_blobs() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.BlobRequest.cached_blobs)
  return &cached_blobs_;
}

// required bytes downloadsecret_proof = 2;
inline bool BlobRequest::has_downloadsecret_proof() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobRequest::set_has_downloadsecret_proof() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobRequest::clear_has_downloadsecret_proof() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobRequest::clear_downloadsecret_proof() {
  if (downloadsecret_proof_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_proof_->clear();
  }
  clear_has_downloadsecret_proof();
}
inline const ::std::string& BlobRequest::downloadsecret_proof() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobRequest.downloadsecret_proof)
  return *downloadsecret_proof_;
}
inline void BlobRequest::set_downloadsecret_proof(const ::std::string& value) {
  set_has_downloadsecret_proof();
  if (downloadsecret_proof_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_proof_ = new ::std::string;
  }
  downloadsecret_proof_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobRequest.downloadsecret_proof)
}
inline void BlobRequest::set_downloadsecret_proof(const char* value) {
  set_has_downloadsecret_proof();
  if (downloadsecret_proof_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_proof_ = new ::std::string;
  }
  downloadsecret_proof_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobRequest.downloadsecret_proof)
}
inline void BlobRequest::set_downloadsecret_proof(const void* value, size_t size) {
  set_has_downloadsecret_proof();
  if (downloadsecret_proof_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_proof_ = new ::std::string;
  }
  downloadsecret_proof_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobRequest.downloadsecret_proof)
}
inline ::std::string* BlobRequest::mutable_downloadsecret_proof() {
  set_has_downloadsecret_proof();
  if (downloadsecret_proof_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    downloadsecret_proof_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobRequest.downloadsecret_proof)
  return downloadsecret_proof_;
}
inline ::std::string* BlobRequest::release_downloadsecret_proof() {
  clear_has_downloadsecret_proof();
  if (downloadsecret_proof_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = downloadsecret_proof_;
    downloadsecret_proof_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobRequest::set_allocated_downloadsecret_proof(::std::string* downloadsecret_proof) {
  if (downloadsecret_proof_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete downloadsecret_proof_;
  }
  if (downloadsecret_proof) {
    set_has_downloadsecret_proof();
    downloadsecret_proof_ = downloadsecret_proof;
  } else {
    clear_has_downloadsecret_proof();
    downloadsecret_proof_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobRequest.downloadsecret_proof)
}

// required bytes proof_nonce = 3;
inline bool BlobRequest::has_proof_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobRequest::set_has_proof_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobRequest::clear_has_proof_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobRequest::clear_proof_nonce() {
  if (proof_nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proof_nonce_->clear();
  }
  clear_has_proof_nonce();
}
inline const ::std::string& BlobRequest::proof_nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobRequest.proof_nonce)
  return *proof_nonce_;
}
inline void BlobRequest::set_proof_nonce(const ::std::string& value) {
  set_has_proof_nonce();
  if (proof_nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proof_nonce_ = new ::std::string;
  }
  proof_nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobRequest.proof_nonce)
}
inline void BlobRequest::set_proof_nonce(const char* value) {
  set_has_proof_nonce();
  if (proof_nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proof_nonce_ = new ::std::string;
  }
  proof_nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobRequest.proof_nonce)
}
inline void BlobRequest::set_proof_nonce(const void* value, size_t size) {
  set_has_proof_nonce();
  if (proof_nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proof_nonce_ = new ::std::string;
  }
  proof_nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobRequest.proof_nonce)
}
inline ::std::string* BlobRequest::mutable_proof_nonce() {
  set_has_proof_nonce();
  if (proof_nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proof_nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobRequest.proof_nonce)
  return proof_nonce_;
}
inline ::std::string* BlobRequest::release_proof_nonce() {
  clear_has_proof_nonce();
  if (proof_nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = proof_nonce_;
    proof_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobRequest::set_allocated_proof_nonce(::std::string* proof_nonce) {
  if (proof_nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete proof_nonce_;
  }
  if (proof_nonce) {
    set_has_proof_nonce();
    proof_nonce_ = proof_nonce;
  } else {
    clear_has_proof_nonce();
    proof_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobRequest.proof_nonce)
}

// -------------------------------------------------------------------

// BlobResponse_NamedBlobFile

// required string name = 1;
inline bool BlobResponse_NamedBlobFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobResponse_NamedBlobFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobResponse_NamedBlobFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobResponse_NamedBlobFile::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BlobResponse_NamedBlobFile::name() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobResponse.NamedBlobFile.name)
  return *name_;
}
inline void BlobResponse_NamedBlobFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobResponse.NamedBlobFile.name)
}
inline void BlobResponse_NamedBlobFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobResponse.NamedBlobFile.name)
}
inline void BlobResponse_NamedBlobFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobResponse.NamedBlobFile.name)
}
inline ::std::string* BlobResponse_NamedBlobFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobResponse.NamedBlobFile.name)
  return name_;
}
inline ::std::string* BlobResponse_NamedBlobFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobResponse_NamedBlobFile::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobResponse.NamedBlobFile.name)
}

// required .pamrac.BlobFile blob = 2;
inline bool BlobResponse_NamedBlobFile::has_blob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobResponse_NamedBlobFile::set_has_blob() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobResponse_NamedBlobFile::clear_has_blob() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobResponse_NamedBlobFile::clear_blob() {
  if (blob_ != NULL) blob_->::pamrac::BlobFile::Clear();
  clear_has_blob();
}
inline const ::pamrac::BlobFile& BlobResponse_NamedBlobFile::blob() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobResponse.NamedBlobFile.blob)
  return blob_ != NULL ? *blob_ : *default_instance_->blob_;
}
inline ::pamrac::BlobFile* BlobResponse_NamedBlobFile::mutable_blob() {
  set_has_blob();
  if (blob_ == NULL) blob_ = new ::pamrac::BlobFile;
  // @@protoc_insertion_point(field_mutable:pamrac.BlobResponse.NamedBlobFile.blob)
  return blob_;
}
inline ::pamrac::BlobFile* BlobResponse_NamedBlobFile::release_blob() {
  clear_has_blob();
  ::pamrac::BlobFile* temp = blob_;
  blob_ = NULL;
  return temp;
}
inline void BlobResponse_NamedBlobFile::set_allocated_blob(::pamrac::BlobFile* blob) {
  delete blob_;
  blob_ = blob;
  if (blob) {
    set_has_blob();
  } else {
    clear_has_blob();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobResponse.NamedBlobFile.blob)
}

// -------------------------------------------------------------------

// BlobResponse

// repeated .pamrac.BlobResponse.NamedBlobFile new_blobs = 1;
inline int BlobResponse::new_blobs_size() const {
  return new_blobs_.size();
}
inline void BlobResponse::clear_new_blobs() {
  new_blobs_.Clear();
}
inline const ::pamrac::BlobResponse_NamedBlobFile& BlobResponse::new_blobs(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.BlobResponse.new_blobs)
  return new_blobs_.Get(index);
}
inline ::pamrac::BlobResponse_NamedBlobFile* BlobResponse::mutable_new_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.BlobResponse.new_blobs)
  return new_blobs_.Mutable(index);
}
inline ::pamrac::BlobResponse_NamedBlobFile* BlobResponse::add_new_blobs() {
  // @@protoc_insertion_point(field_add:pamrac.BlobResponse.new_blobs)
  return new_blobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::BlobResponse_NamedBlobFile >&
BlobResponse::new_blobs() const {
  // @@protoc_insertion_point(field_list:pamrac.BlobResponse.new_blobs)
  return new_blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::BlobResponse_NamedBlobFile >*
BlobResponse::mutable_new_blobs() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.BlobResponse.new_blobs)
  return &new_blobs_;
}

// -------------------------------------------------------------------

// BlobUpload

// required string hashed_filename = 1;
inline bool BlobUpload::has_hashed_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobUpload::set_has_hashed_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobUpload::clear_has_hashed_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobUpload::clear_hashed_filename() {
  if (hashed_filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hashed_filename_->clear();
  }
  clear_has_hashed_filename();
}
inline const ::std::string& BlobUpload::hashed_filename() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUpload.hashed_filename)
  return *hashed_filename_;
}
inline void BlobUpload::set_hashed_filename(const ::std::string& value) {
  set_has_hashed_filename();
  if (hashed_filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hashed_filename_ = new ::std::string;
  }
  hashed_filename_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobUpload.hashed_filename)
}
inline void BlobUpload::set_hashed_filename(const char* value) {
  set_has_hashed_filename();
  if (hashed_filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hashed_filename_ = new ::std::string;
  }
  hashed_filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobUpload.hashed_filename)
}
inline void BlobUpload::set_hashed_filename(const char* value, size_t size) {
  set_has_hashed_filename();
  if (hashed_filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hashed_filename_ = new ::std::string;
  }
  hashed_filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobUpload.hashed_filename)
}
inline ::std::string* BlobUpload::mutable_hashed_filename() {
  set_has_hashed_filename();
  if (hashed_filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hashed_filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobUpload.hashed_filename)
  return hashed_filename_;
}
inline ::std::string* BlobUpload::release_hashed_filename() {
  clear_has_hashed_filename();
  if (hashed_filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hashed_filename_;
    hashed_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobUpload::set_allocated_hashed_filename(::std::string* hashed_filename) {
  if (hashed_filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hashed_filename_;
  }
  if (hashed_filename) {
    set_has_hashed_filename();
    hashed_filename_ = hashed_filename;
  } else {
    clear_has_hashed_filename();
    hashed_filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobUpload.hashed_filename)
}

// required .pamrac.BlobFile blob = 2;
inline bool BlobUpload::has_blob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobUpload::set_has_blob() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobUpload::clear_has_blob() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobUpload::clear_blob() {
  if (blob_ != NULL) blob_->::pamrac::BlobFile::Clear();
  clear_has_blob();
}
inline const ::pamrac::BlobFile& BlobUpload::blob() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUpload.blob)
  return blob_ != NULL ? *blob_ : *default_instance_->blob_;
}
inline ::pamrac::BlobFile* BlobUpload::mutable_blob() {
  set_has_blob();
  if (blob_ == NULL) blob_ = new ::pamrac::BlobFile;
  // @@protoc_insertion_point(field_mutable:pamrac.BlobUpload.blob)
  return blob_;
}
inline ::pamrac::BlobFile* BlobUpload::release_blob() {
  clear_has_blob();
  ::pamrac::BlobFile* temp = blob_;
  blob_ = NULL;
  return temp;
}
inline void BlobUpload::set_allocated_blob(::pamrac::BlobFile* blob) {
  delete blob_;
  blob_ = blob;
  if (blob) {
    set_has_blob();
  } else {
    clear_has_blob();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobUpload.blob)
}

// required bytes nonce = 3;
inline bool BlobUpload::has_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobUpload::set_has_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobUpload::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobUpload::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& BlobUpload::nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUpload.nonce)
  return *nonce_;
}
inline void BlobUpload::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobUpload.nonce)
}
inline void BlobUpload::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobUpload.nonce)
}
inline void BlobUpload::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobUpload.nonce)
}
inline ::std::string* BlobUpload::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobUpload.nonce)
  return nonce_;
}
inline ::std::string* BlobUpload::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobUpload::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobUpload.nonce)
}

// optional bytes signature = 4;
inline bool BlobUpload::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlobUpload::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlobUpload::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlobUpload::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& BlobUpload::signature() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUpload.signature)
  return *signature_;
}
inline void BlobUpload::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.BlobUpload.signature)
}
inline void BlobUpload::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.BlobUpload.signature)
}
inline void BlobUpload::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.BlobUpload.signature)
}
inline ::std::string* BlobUpload::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.BlobUpload.signature)
  return signature_;
}
inline ::std::string* BlobUpload::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobUpload::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.BlobUpload.signature)
}

// -------------------------------------------------------------------

// BlobUploadResult

// required bool verification_ok = 1;
inline bool BlobUploadResult::has_verification_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobUploadResult::set_has_verification_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobUploadResult::clear_has_verification_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobUploadResult::clear_verification_ok() {
  verification_ok_ = false;
  clear_has_verification_ok();
}
inline bool BlobUploadResult::verification_ok() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUploadResult.verification_ok)
  return verification_ok_;
}
inline void BlobUploadResult::set_verification_ok(bool value) {
  set_has_verification_ok();
  verification_ok_ = value;
  // @@protoc_insertion_point(field_set:pamrac.BlobUploadResult.verification_ok)
}

// optional bool upload_successful = 2;
inline bool BlobUploadResult::has_upload_successful() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobUploadResult::set_has_upload_successful() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobUploadResult::clear_has_upload_successful() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobUploadResult::clear_upload_successful() {
  upload_successful_ = false;
  clear_has_upload_successful();
}
inline bool BlobUploadResult::upload_successful() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUploadResult.upload_successful)
  return upload_successful_;
}
inline void BlobUploadResult::set_upload_successful(bool value) {
  set_has_upload_successful();
  upload_successful_ = value;
  // @@protoc_insertion_point(field_set:pamrac.BlobUploadResult.upload_successful)
}

// optional int32 server_version = 3;
inline bool BlobUploadResult::has_server_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlobUploadResult::set_has_server_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlobUploadResult::clear_has_server_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlobUploadResult::clear_server_version() {
  server_version_ = 0;
  clear_has_server_version();
}
inline ::google::protobuf::int32 BlobUploadResult::server_version() const {
  // @@protoc_insertion_point(field_get:pamrac.BlobUploadResult.server_version)
  return server_version_;
}
inline void BlobUploadResult::set_server_version(::google::protobuf::int32 value) {
  set_has_server_version();
  server_version_ = value;
  // @@protoc_insertion_point(field_set:pamrac.BlobUploadResult.server_version)
}

// -------------------------------------------------------------------

// ShareListRequest

// required bytes requester_fingerprint = 1;
inline bool ShareListRequest::has_requester_fingerprint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareListRequest::set_has_requester_fingerprint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareListRequest::clear_has_requester_fingerprint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareListRequest::clear_requester_fingerprint() {
  if (requester_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_fingerprint_->clear();
  }
  clear_has_requester_fingerprint();
}
inline const ::std::string& ShareListRequest::requester_fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareListRequest.requester_fingerprint)
  return *requester_fingerprint_;
}
inline void ShareListRequest::set_requester_fingerprint(const ::std::string& value) {
  set_has_requester_fingerprint();
  if (requester_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_fingerprint_ = new ::std::string;
  }
  requester_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareListRequest.requester_fingerprint)
}
inline void ShareListRequest::set_requester_fingerprint(const char* value) {
  set_has_requester_fingerprint();
  if (requester_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_fingerprint_ = new ::std::string;
  }
  requester_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareListRequest.requester_fingerprint)
}
inline void ShareListRequest::set_requester_fingerprint(const void* value, size_t size) {
  set_has_requester_fingerprint();
  if (requester_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_fingerprint_ = new ::std::string;
  }
  requester_fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareListRequest.requester_fingerprint)
}
inline ::std::string* ShareListRequest::mutable_requester_fingerprint() {
  set_has_requester_fingerprint();
  if (requester_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareListRequest.requester_fingerprint)
  return requester_fingerprint_;
}
inline ::std::string* ShareListRequest::release_requester_fingerprint() {
  clear_has_requester_fingerprint();
  if (requester_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = requester_fingerprint_;
    requester_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareListRequest::set_allocated_requester_fingerprint(::std::string* requester_fingerprint) {
  if (requester_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requester_fingerprint_;
  }
  if (requester_fingerprint) {
    set_has_requester_fingerprint();
    requester_fingerprint_ = requester_fingerprint;
  } else {
    clear_has_requester_fingerprint();
    requester_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareListRequest.requester_fingerprint)
}

// required bytes nonce = 2;
inline bool ShareListRequest::has_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareListRequest::set_has_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareListRequest::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareListRequest::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& ShareListRequest::nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareListRequest.nonce)
  return *nonce_;
}
inline void ShareListRequest::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareListRequest.nonce)
}
inline void ShareListRequest::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareListRequest.nonce)
}
inline void ShareListRequest::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareListRequest.nonce)
}
inline ::std::string* ShareListRequest::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareListRequest.nonce)
  return nonce_;
}
inline ::std::string* ShareListRequest::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareListRequest::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareListRequest.nonce)
}

// optional bytes signature = 3;
inline bool ShareListRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareListRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareListRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareListRequest::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& ShareListRequest::signature() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareListRequest.signature)
  return *signature_;
}
inline void ShareListRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareListRequest.signature)
}
inline void ShareListRequest::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareListRequest.signature)
}
inline void ShareListRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareListRequest.signature)
}
inline ::std::string* ShareListRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareListRequest.signature)
  return signature_;
}
inline ::std::string* ShareListRequest::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareListRequest::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareListRequest.signature)
}

// -------------------------------------------------------------------

// ShareList_ShareRecipient

// optional string nickname = 1;
inline bool ShareList_ShareRecipient::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareList_ShareRecipient::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareList_ShareRecipient::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareList_ShareRecipient::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ShareList_ShareRecipient::nickname() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.ShareRecipient.nickname)
  return *nickname_;
}
inline void ShareList_ShareRecipient::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareList.ShareRecipient.nickname)
}
inline void ShareList_ShareRecipient::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareList.ShareRecipient.nickname)
}
inline void ShareList_ShareRecipient::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareList.ShareRecipient.nickname)
}
inline ::std::string* ShareList_ShareRecipient::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareList.ShareRecipient.nickname)
  return nickname_;
}
inline ::std::string* ShareList_ShareRecipient::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareList_ShareRecipient::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareList.ShareRecipient.nickname)
}

// required bytes fingerprint = 2;
inline bool ShareList_ShareRecipient::has_fingerprint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareList_ShareRecipient::set_has_fingerprint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareList_ShareRecipient::clear_has_fingerprint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareList_ShareRecipient::clear_fingerprint() {
  if (fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fingerprint_->clear();
  }
  clear_has_fingerprint();
}
inline const ::std::string& ShareList_ShareRecipient::fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.ShareRecipient.fingerprint)
  return *fingerprint_;
}
inline void ShareList_ShareRecipient::set_fingerprint(const ::std::string& value) {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fingerprint_ = new ::std::string;
  }
  fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareList.ShareRecipient.fingerprint)
}
inline void ShareList_ShareRecipient::set_fingerprint(const char* value) {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fingerprint_ = new ::std::string;
  }
  fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareList.ShareRecipient.fingerprint)
}
inline void ShareList_ShareRecipient::set_fingerprint(const void* value, size_t size) {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fingerprint_ = new ::std::string;
  }
  fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareList.ShareRecipient.fingerprint)
}
inline ::std::string* ShareList_ShareRecipient::mutable_fingerprint() {
  set_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareList.ShareRecipient.fingerprint)
  return fingerprint_;
}
inline ::std::string* ShareList_ShareRecipient::release_fingerprint() {
  clear_has_fingerprint();
  if (fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fingerprint_;
    fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareList_ShareRecipient::set_allocated_fingerprint(::std::string* fingerprint) {
  if (fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fingerprint_;
  }
  if (fingerprint) {
    set_has_fingerprint();
    fingerprint_ = fingerprint;
  } else {
    clear_has_fingerprint();
    fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareList.ShareRecipient.fingerprint)
}

// required bool initiator = 3;
inline bool ShareList_ShareRecipient::has_initiator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareList_ShareRecipient::set_has_initiator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareList_ShareRecipient::clear_has_initiator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareList_ShareRecipient::clear_initiator() {
  initiator_ = false;
  clear_has_initiator();
}
inline bool ShareList_ShareRecipient::initiator() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.ShareRecipient.initiator)
  return initiator_;
}
inline void ShareList_ShareRecipient::set_initiator(bool value) {
  set_has_initiator();
  initiator_ = value;
  // @@protoc_insertion_point(field_set:pamrac.ShareList.ShareRecipient.initiator)
}

// -------------------------------------------------------------------

// ShareList

// required int64 timestamp = 1;
inline bool ShareList::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareList::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareList::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareList::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ShareList::timestamp() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.timestamp)
  return timestamp_;
}
inline void ShareList::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pamrac.ShareList.timestamp)
}

// required int32 threshold = 2;
inline bool ShareList::has_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareList::set_has_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareList::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareList::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline ::google::protobuf::int32 ShareList::threshold() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.threshold)
  return threshold_;
}
inline void ShareList::set_threshold(::google::protobuf::int32 value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:pamrac.ShareList.threshold)
}

// repeated .pamrac.ShareList.ShareRecipient recipients = 3;
inline int ShareList::recipients_size() const {
  return recipients_.size();
}
inline void ShareList::clear_recipients() {
  recipients_.Clear();
}
inline const ::pamrac::ShareList_ShareRecipient& ShareList::recipients(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.recipients)
  return recipients_.Get(index);
}
inline ::pamrac::ShareList_ShareRecipient* ShareList::mutable_recipients(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.ShareList.recipients)
  return recipients_.Mutable(index);
}
inline ::pamrac::ShareList_ShareRecipient* ShareList::add_recipients() {
  // @@protoc_insertion_point(field_add:pamrac.ShareList.recipients)
  return recipients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareList_ShareRecipient >&
ShareList::recipients() const {
  // @@protoc_insertion_point(field_list:pamrac.ShareList.recipients)
  return recipients_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareList_ShareRecipient >*
ShareList::mutable_recipients() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.ShareList.recipients)
  return &recipients_;
}

// optional bytes signature = 4;
inline bool ShareList::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShareList::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShareList::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShareList::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& ShareList::signature() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareList.signature)
  return *signature_;
}
inline void ShareList::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareList.signature)
}
inline void ShareList::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareList.signature)
}
inline void ShareList::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareList.signature)
}
inline ::std::string* ShareList::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareList.signature)
  return signature_;
}
inline ::std::string* ShareList::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareList::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareList.signature)
}

// -------------------------------------------------------------------

// ShareID

// required bytes originator_fingerprint = 1;
inline bool ShareID::has_originator_fingerprint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareID::set_has_originator_fingerprint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareID::clear_has_originator_fingerprint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareID::clear_originator_fingerprint() {
  if (originator_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originator_fingerprint_->clear();
  }
  clear_has_originator_fingerprint();
}
inline const ::std::string& ShareID::originator_fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareID.originator_fingerprint)
  return *originator_fingerprint_;
}
inline void ShareID::set_originator_fingerprint(const ::std::string& value) {
  set_has_originator_fingerprint();
  if (originator_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originator_fingerprint_ = new ::std::string;
  }
  originator_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareID.originator_fingerprint)
}
inline void ShareID::set_originator_fingerprint(const char* value) {
  set_has_originator_fingerprint();
  if (originator_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originator_fingerprint_ = new ::std::string;
  }
  originator_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareID.originator_fingerprint)
}
inline void ShareID::set_originator_fingerprint(const void* value, size_t size) {
  set_has_originator_fingerprint();
  if (originator_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originator_fingerprint_ = new ::std::string;
  }
  originator_fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareID.originator_fingerprint)
}
inline ::std::string* ShareID::mutable_originator_fingerprint() {
  set_has_originator_fingerprint();
  if (originator_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originator_fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareID.originator_fingerprint)
  return originator_fingerprint_;
}
inline ::std::string* ShareID::release_originator_fingerprint() {
  clear_has_originator_fingerprint();
  if (originator_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = originator_fingerprint_;
    originator_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareID::set_allocated_originator_fingerprint(::std::string* originator_fingerprint) {
  if (originator_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete originator_fingerprint_;
  }
  if (originator_fingerprint) {
    set_has_originator_fingerprint();
    originator_fingerprint_ = originator_fingerprint;
  } else {
    clear_has_originator_fingerprint();
    originator_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareID.originator_fingerprint)
}

// required bytes owner_fingerprint = 2;
inline bool ShareID::has_owner_fingerprint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareID::set_has_owner_fingerprint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareID::clear_has_owner_fingerprint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareID::clear_owner_fingerprint() {
  if (owner_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_fingerprint_->clear();
  }
  clear_has_owner_fingerprint();
}
inline const ::std::string& ShareID::owner_fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareID.owner_fingerprint)
  return *owner_fingerprint_;
}
inline void ShareID::set_owner_fingerprint(const ::std::string& value) {
  set_has_owner_fingerprint();
  if (owner_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_fingerprint_ = new ::std::string;
  }
  owner_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareID.owner_fingerprint)
}
inline void ShareID::set_owner_fingerprint(const char* value) {
  set_has_owner_fingerprint();
  if (owner_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_fingerprint_ = new ::std::string;
  }
  owner_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareID.owner_fingerprint)
}
inline void ShareID::set_owner_fingerprint(const void* value, size_t size) {
  set_has_owner_fingerprint();
  if (owner_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_fingerprint_ = new ::std::string;
  }
  owner_fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareID.owner_fingerprint)
}
inline ::std::string* ShareID::mutable_owner_fingerprint() {
  set_has_owner_fingerprint();
  if (owner_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareID.owner_fingerprint)
  return owner_fingerprint_;
}
inline ::std::string* ShareID::release_owner_fingerprint() {
  clear_has_owner_fingerprint();
  if (owner_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = owner_fingerprint_;
    owner_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareID::set_allocated_owner_fingerprint(::std::string* owner_fingerprint) {
  if (owner_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_fingerprint_;
  }
  if (owner_fingerprint) {
    set_has_owner_fingerprint();
    owner_fingerprint_ = owner_fingerprint;
  } else {
    clear_has_owner_fingerprint();
    owner_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareID.owner_fingerprint)
}

// required bytes encrypted_to_fingerprint = 3;
inline bool ShareID::has_encrypted_to_fingerprint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareID::set_has_encrypted_to_fingerprint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareID::clear_has_encrypted_to_fingerprint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareID::clear_encrypted_to_fingerprint() {
  if (encrypted_to_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_to_fingerprint_->clear();
  }
  clear_has_encrypted_to_fingerprint();
}
inline const ::std::string& ShareID::encrypted_to_fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareID.encrypted_to_fingerprint)
  return *encrypted_to_fingerprint_;
}
inline void ShareID::set_encrypted_to_fingerprint(const ::std::string& value) {
  set_has_encrypted_to_fingerprint();
  if (encrypted_to_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_to_fingerprint_ = new ::std::string;
  }
  encrypted_to_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareID.encrypted_to_fingerprint)
}
inline void ShareID::set_encrypted_to_fingerprint(const char* value) {
  set_has_encrypted_to_fingerprint();
  if (encrypted_to_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_to_fingerprint_ = new ::std::string;
  }
  encrypted_to_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareID.encrypted_to_fingerprint)
}
inline void ShareID::set_encrypted_to_fingerprint(const void* value, size_t size) {
  set_has_encrypted_to_fingerprint();
  if (encrypted_to_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_to_fingerprint_ = new ::std::string;
  }
  encrypted_to_fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareID.encrypted_to_fingerprint)
}
inline ::std::string* ShareID::mutable_encrypted_to_fingerprint() {
  set_has_encrypted_to_fingerprint();
  if (encrypted_to_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_to_fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareID.encrypted_to_fingerprint)
  return encrypted_to_fingerprint_;
}
inline ::std::string* ShareID::release_encrypted_to_fingerprint() {
  clear_has_encrypted_to_fingerprint();
  if (encrypted_to_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_to_fingerprint_;
    encrypted_to_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareID::set_allocated_encrypted_to_fingerprint(::std::string* encrypted_to_fingerprint) {
  if (encrypted_to_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypted_to_fingerprint_;
  }
  if (encrypted_to_fingerprint) {
    set_has_encrypted_to_fingerprint();
    encrypted_to_fingerprint_ = encrypted_to_fingerprint;
  } else {
    clear_has_encrypted_to_fingerprint();
    encrypted_to_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareID.encrypted_to_fingerprint)
}

// -------------------------------------------------------------------

// ShareRequest

// required .pamrac.ShareID share_id = 1;
inline bool ShareRequest::has_share_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareRequest::set_has_share_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareRequest::clear_has_share_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareRequest::clear_share_id() {
  if (share_id_ != NULL) share_id_->::pamrac::ShareID::Clear();
  clear_has_share_id();
}
inline const ::pamrac::ShareID& ShareRequest::share_id() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareRequest.share_id)
  return share_id_ != NULL ? *share_id_ : *default_instance_->share_id_;
}
inline ::pamrac::ShareID* ShareRequest::mutable_share_id() {
  set_has_share_id();
  if (share_id_ == NULL) share_id_ = new ::pamrac::ShareID;
  // @@protoc_insertion_point(field_mutable:pamrac.ShareRequest.share_id)
  return share_id_;
}
inline ::pamrac::ShareID* ShareRequest::release_share_id() {
  clear_has_share_id();
  ::pamrac::ShareID* temp = share_id_;
  share_id_ = NULL;
  return temp;
}
inline void ShareRequest::set_allocated_share_id(::pamrac::ShareID* share_id) {
  delete share_id_;
  share_id_ = share_id;
  if (share_id) {
    set_has_share_id();
  } else {
    clear_has_share_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareRequest.share_id)
}

// required bytes nonce = 2;
inline bool ShareRequest::has_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShareRequest::set_has_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShareRequest::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShareRequest::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& ShareRequest::nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareRequest.nonce)
  return *nonce_;
}
inline void ShareRequest::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareRequest.nonce)
}
inline void ShareRequest::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareRequest.nonce)
}
inline void ShareRequest::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareRequest.nonce)
}
inline ::std::string* ShareRequest::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareRequest.nonce)
  return nonce_;
}
inline ::std::string* ShareRequest::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareRequest::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareRequest.nonce)
}

// optional bytes signature = 3;
inline bool ShareRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareRequest::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& ShareRequest::signature() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareRequest.signature)
  return *signature_;
}
inline void ShareRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareRequest.signature)
}
inline void ShareRequest::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareRequest.signature)
}
inline void ShareRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareRequest.signature)
}
inline ::std::string* ShareRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareRequest.signature)
  return signature_;
}
inline ::std::string* ShareRequest::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareRequest::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareRequest.signature)
}

// -------------------------------------------------------------------

// KeyShare

// required int64 timestamp = 1;
inline bool KeyShare::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyShare::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyShare::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyShare::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 KeyShare::timestamp() const {
  // @@protoc_insertion_point(field_get:pamrac.KeyShare.timestamp)
  return timestamp_;
}
inline void KeyShare::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pamrac.KeyShare.timestamp)
}

// optional .pamrac.MasterKeyRetrievableFile masterkey_retrievable_file = 2;
inline bool KeyShare::has_masterkey_retrievable_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyShare::set_has_masterkey_retrievable_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyShare::clear_has_masterkey_retrievable_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyShare::clear_masterkey_retrievable_file() {
  if (masterkey_retrievable_file_ != NULL) masterkey_retrievable_file_->::pamrac::MasterKeyRetrievableFile::Clear();
  clear_has_masterkey_retrievable_file();
}
inline const ::pamrac::MasterKeyRetrievableFile& KeyShare::masterkey_retrievable_file() const {
  // @@protoc_insertion_point(field_get:pamrac.KeyShare.masterkey_retrievable_file)
  return masterkey_retrievable_file_ != NULL ? *masterkey_retrievable_file_ : *default_instance_->masterkey_retrievable_file_;
}
inline ::pamrac::MasterKeyRetrievableFile* KeyShare::mutable_masterkey_retrievable_file() {
  set_has_masterkey_retrievable_file();
  if (masterkey_retrievable_file_ == NULL) masterkey_retrievable_file_ = new ::pamrac::MasterKeyRetrievableFile;
  // @@protoc_insertion_point(field_mutable:pamrac.KeyShare.masterkey_retrievable_file)
  return masterkey_retrievable_file_;
}
inline ::pamrac::MasterKeyRetrievableFile* KeyShare::release_masterkey_retrievable_file() {
  clear_has_masterkey_retrievable_file();
  ::pamrac::MasterKeyRetrievableFile* temp = masterkey_retrievable_file_;
  masterkey_retrievable_file_ = NULL;
  return temp;
}
inline void KeyShare::set_allocated_masterkey_retrievable_file(::pamrac::MasterKeyRetrievableFile* masterkey_retrievable_file) {
  delete masterkey_retrievable_file_;
  masterkey_retrievable_file_ = masterkey_retrievable_file;
  if (masterkey_retrievable_file) {
    set_has_masterkey_retrievable_file();
  } else {
    clear_has_masterkey_retrievable_file();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.KeyShare.masterkey_retrievable_file)
}

// optional bytes encrypted_initiator_mask = 3;
inline bool KeyShare::has_encrypted_initiator_mask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyShare::set_has_encrypted_initiator_mask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyShare::clear_has_encrypted_initiator_mask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyShare::clear_encrypted_initiator_mask() {
  if (encrypted_initiator_mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_initiator_mask_->clear();
  }
  clear_has_encrypted_initiator_mask();
}
inline const ::std::string& KeyShare::encrypted_initiator_mask() const {
  // @@protoc_insertion_point(field_get:pamrac.KeyShare.encrypted_initiator_mask)
  return *encrypted_initiator_mask_;
}
inline void KeyShare::set_encrypted_initiator_mask(const ::std::string& value) {
  set_has_encrypted_initiator_mask();
  if (encrypted_initiator_mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_initiator_mask_ = new ::std::string;
  }
  encrypted_initiator_mask_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.KeyShare.encrypted_initiator_mask)
}
inline void KeyShare::set_encrypted_initiator_mask(const char* value) {
  set_has_encrypted_initiator_mask();
  if (encrypted_initiator_mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_initiator_mask_ = new ::std::string;
  }
  encrypted_initiator_mask_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.KeyShare.encrypted_initiator_mask)
}
inline void KeyShare::set_encrypted_initiator_mask(const void* value, size_t size) {
  set_has_encrypted_initiator_mask();
  if (encrypted_initiator_mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_initiator_mask_ = new ::std::string;
  }
  encrypted_initiator_mask_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.KeyShare.encrypted_initiator_mask)
}
inline ::std::string* KeyShare::mutable_encrypted_initiator_mask() {
  set_has_encrypted_initiator_mask();
  if (encrypted_initiator_mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_initiator_mask_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.KeyShare.encrypted_initiator_mask)
  return encrypted_initiator_mask_;
}
inline ::std::string* KeyShare::release_encrypted_initiator_mask() {
  clear_has_encrypted_initiator_mask();
  if (encrypted_initiator_mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_initiator_mask_;
    encrypted_initiator_mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyShare::set_allocated_encrypted_initiator_mask(::std::string* encrypted_initiator_mask) {
  if (encrypted_initiator_mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypted_initiator_mask_;
  }
  if (encrypted_initiator_mask) {
    set_has_encrypted_initiator_mask();
    encrypted_initiator_mask_ = encrypted_initiator_mask;
  } else {
    clear_has_encrypted_initiator_mask();
    encrypted_initiator_mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.KeyShare.encrypted_initiator_mask)
}

// required bytes encrypted_share = 4;
inline bool KeyShare::has_encrypted_share() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyShare::set_has_encrypted_share() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyShare::clear_has_encrypted_share() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyShare::clear_encrypted_share() {
  if (encrypted_share_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_share_->clear();
  }
  clear_has_encrypted_share();
}
inline const ::std::string& KeyShare::encrypted_share() const {
  // @@protoc_insertion_point(field_get:pamrac.KeyShare.encrypted_share)
  return *encrypted_share_;
}
inline void KeyShare::set_encrypted_share(const ::std::string& value) {
  set_has_encrypted_share();
  if (encrypted_share_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_share_ = new ::std::string;
  }
  encrypted_share_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.KeyShare.encrypted_share)
}
inline void KeyShare::set_encrypted_share(const char* value) {
  set_has_encrypted_share();
  if (encrypted_share_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_share_ = new ::std::string;
  }
  encrypted_share_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.KeyShare.encrypted_share)
}
inline void KeyShare::set_encrypted_share(const void* value, size_t size) {
  set_has_encrypted_share();
  if (encrypted_share_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_share_ = new ::std::string;
  }
  encrypted_share_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.KeyShare.encrypted_share)
}
inline ::std::string* KeyShare::mutable_encrypted_share() {
  set_has_encrypted_share();
  if (encrypted_share_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encrypted_share_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.KeyShare.encrypted_share)
  return encrypted_share_;
}
inline ::std::string* KeyShare::release_encrypted_share() {
  clear_has_encrypted_share();
  if (encrypted_share_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_share_;
    encrypted_share_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyShare::set_allocated_encrypted_share(::std::string* encrypted_share) {
  if (encrypted_share_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encrypted_share_;
  }
  if (encrypted_share) {
    set_has_encrypted_share();
    encrypted_share_ = encrypted_share;
  } else {
    clear_has_encrypted_share();
    encrypted_share_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.KeyShare.encrypted_share)
}

// required .pamrac.ShareID share_id = 5;
inline bool KeyShare::has_share_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeyShare::set_has_share_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeyShare::clear_has_share_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeyShare::clear_share_id() {
  if (share_id_ != NULL) share_id_->::pamrac::ShareID::Clear();
  clear_has_share_id();
}
inline const ::pamrac::ShareID& KeyShare::share_id() const {
  // @@protoc_insertion_point(field_get:pamrac.KeyShare.share_id)
  return share_id_ != NULL ? *share_id_ : *default_instance_->share_id_;
}
inline ::pamrac::ShareID* KeyShare::mutable_share_id() {
  set_has_share_id();
  if (share_id_ == NULL) share_id_ = new ::pamrac::ShareID;
  // @@protoc_insertion_point(field_mutable:pamrac.KeyShare.share_id)
  return share_id_;
}
inline ::pamrac::ShareID* KeyShare::release_share_id() {
  clear_has_share_id();
  ::pamrac::ShareID* temp = share_id_;
  share_id_ = NULL;
  return temp;
}
inline void KeyShare::set_allocated_share_id(::pamrac::ShareID* share_id) {
  delete share_id_;
  share_id_ = share_id;
  if (share_id) {
    set_has_share_id();
  } else {
    clear_has_share_id();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.KeyShare.share_id)
}

// -------------------------------------------------------------------

// ShareUpload

// repeated .pamrac.ShareID revoke_id = 1;
inline int ShareUpload::revoke_id_size() const {
  return revoke_id_.size();
}
inline void ShareUpload::clear_revoke_id() {
  revoke_id_.Clear();
}
inline const ::pamrac::ShareID& ShareUpload::revoke_id(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUpload.revoke_id)
  return revoke_id_.Get(index);
}
inline ::pamrac::ShareID* ShareUpload::mutable_revoke_id(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUpload.revoke_id)
  return revoke_id_.Mutable(index);
}
inline ::pamrac::ShareID* ShareUpload::add_revoke_id() {
  // @@protoc_insertion_point(field_add:pamrac.ShareUpload.revoke_id)
  return revoke_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >&
ShareUpload::revoke_id() const {
  // @@protoc_insertion_point(field_list:pamrac.ShareUpload.revoke_id)
  return revoke_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >*
ShareUpload::mutable_revoke_id() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.ShareUpload.revoke_id)
  return &revoke_id_;
}

// repeated .pamrac.KeyShare share = 2;
inline int ShareUpload::share_size() const {
  return share_.size();
}
inline void ShareUpload::clear_share() {
  share_.Clear();
}
inline const ::pamrac::KeyShare& ShareUpload::share(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUpload.share)
  return share_.Get(index);
}
inline ::pamrac::KeyShare* ShareUpload::mutable_share(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUpload.share)
  return share_.Mutable(index);
}
inline ::pamrac::KeyShare* ShareUpload::add_share() {
  // @@protoc_insertion_point(field_add:pamrac.ShareUpload.share)
  return share_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::KeyShare >&
ShareUpload::share() const {
  // @@protoc_insertion_point(field_list:pamrac.ShareUpload.share)
  return share_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::KeyShare >*
ShareUpload::mutable_share() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.ShareUpload.share)
  return &share_;
}

// optional .pamrac.ShareList list = 3;
inline bool ShareUpload::has_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShareUpload::set_has_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShareUpload::clear_has_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShareUpload::clear_list() {
  if (list_ != NULL) list_->::pamrac::ShareList::Clear();
  clear_has_list();
}
inline const ::pamrac::ShareList& ShareUpload::list() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUpload.list)
  return list_ != NULL ? *list_ : *default_instance_->list_;
}
inline ::pamrac::ShareList* ShareUpload::mutable_list() {
  set_has_list();
  if (list_ == NULL) list_ = new ::pamrac::ShareList;
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUpload.list)
  return list_;
}
inline ::pamrac::ShareList* ShareUpload::release_list() {
  clear_has_list();
  ::pamrac::ShareList* temp = list_;
  list_ = NULL;
  return temp;
}
inline void ShareUpload::set_allocated_list(::pamrac::ShareList* list) {
  delete list_;
  list_ = list;
  if (list) {
    set_has_list();
  } else {
    clear_has_list();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareUpload.list)
}

// required bytes nonce = 4;
inline bool ShareUpload::has_nonce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShareUpload::set_has_nonce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShareUpload::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShareUpload::clear_nonce() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_->clear();
  }
  clear_has_nonce();
}
inline const ::std::string& ShareUpload::nonce() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUpload.nonce)
  return *nonce_;
}
inline void ShareUpload::set_nonce(const ::std::string& value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareUpload.nonce)
}
inline void ShareUpload::set_nonce(const char* value) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareUpload.nonce)
}
inline void ShareUpload::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  nonce_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareUpload.nonce)
}
inline ::std::string* ShareUpload::mutable_nonce() {
  set_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nonce_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUpload.nonce)
  return nonce_;
}
inline ::std::string* ShareUpload::release_nonce() {
  clear_has_nonce();
  if (nonce_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nonce_;
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareUpload::set_allocated_nonce(::std::string* nonce) {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (nonce) {
    set_has_nonce();
    nonce_ = nonce;
  } else {
    clear_has_nonce();
    nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareUpload.nonce)
}

// optional bytes signature = 5;
inline bool ShareUpload::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShareUpload::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShareUpload::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShareUpload::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& ShareUpload::signature() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUpload.signature)
  return *signature_;
}
inline void ShareUpload::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ShareUpload.signature)
}
inline void ShareUpload::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ShareUpload.signature)
}
inline void ShareUpload::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ShareUpload.signature)
}
inline ::std::string* ShareUpload::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUpload.signature)
  return signature_;
}
inline ::std::string* ShareUpload::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareUpload::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ShareUpload.signature)
}

// -------------------------------------------------------------------

// ShareUploadResult

// required bool verification_ok = 1;
inline bool ShareUploadResult::has_verification_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareUploadResult::set_has_verification_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareUploadResult::clear_has_verification_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareUploadResult::clear_verification_ok() {
  verification_ok_ = false;
  clear_has_verification_ok();
}
inline bool ShareUploadResult::verification_ok() const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUploadResult.verification_ok)
  return verification_ok_;
}
inline void ShareUploadResult::set_verification_ok(bool value) {
  set_has_verification_ok();
  verification_ok_ = value;
  // @@protoc_insertion_point(field_set:pamrac.ShareUploadResult.verification_ok)
}

// repeated .pamrac.ShareID ids_revoked = 2;
inline int ShareUploadResult::ids_revoked_size() const {
  return ids_revoked_.size();
}
inline void ShareUploadResult::clear_ids_revoked() {
  ids_revoked_.Clear();
}
inline const ::pamrac::ShareID& ShareUploadResult::ids_revoked(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUploadResult.ids_revoked)
  return ids_revoked_.Get(index);
}
inline ::pamrac::ShareID* ShareUploadResult::mutable_ids_revoked(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUploadResult.ids_revoked)
  return ids_revoked_.Mutable(index);
}
inline ::pamrac::ShareID* ShareUploadResult::add_ids_revoked() {
  // @@protoc_insertion_point(field_add:pamrac.ShareUploadResult.ids_revoked)
  return ids_revoked_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >&
ShareUploadResult::ids_revoked() const {
  // @@protoc_insertion_point(field_list:pamrac.ShareUploadResult.ids_revoked)
  return ids_revoked_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >*
ShareUploadResult::mutable_ids_revoked() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.ShareUploadResult.ids_revoked)
  return &ids_revoked_;
}

// repeated .pamrac.ShareID shares_added = 3;
inline int ShareUploadResult::shares_added_size() const {
  return shares_added_.size();
}
inline void ShareUploadResult::clear_shares_added() {
  shares_added_.Clear();
}
inline const ::pamrac::ShareID& ShareUploadResult::shares_added(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.ShareUploadResult.shares_added)
  return shares_added_.Get(index);
}
inline ::pamrac::ShareID* ShareUploadResult::mutable_shares_added(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.ShareUploadResult.shares_added)
  return shares_added_.Mutable(index);
}
inline ::pamrac::ShareID* ShareUploadResult::add_shares_added() {
  // @@protoc_insertion_point(field_add:pamrac.ShareUploadResult.shares_added)
  return shares_added_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >&
ShareUploadResult::shares_added() const {
  // @@protoc_insertion_point(field_list:pamrac.ShareUploadResult.shares_added)
  return shares_added_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::ShareID >*
ShareUploadResult::mutable_shares_added() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.ShareUploadResult.shares_added)
  return &shares_added_;
}

// -------------------------------------------------------------------

// FriendNameMap_FriendNickname

// required string name = 1;
inline bool FriendNameMap_FriendNickname::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendNameMap_FriendNickname::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendNameMap_FriendNickname::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendNameMap_FriendNickname::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FriendNameMap_FriendNickname::name() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.FriendNickname.name)
  return *name_;
}
inline void FriendNameMap_FriendNickname::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.FriendNickname.name)
}
inline void FriendNameMap_FriendNickname::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.FriendNameMap.FriendNickname.name)
}
inline void FriendNameMap_FriendNickname::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.FriendNameMap.FriendNickname.name)
}
inline ::std::string* FriendNameMap_FriendNickname::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.FriendNickname.name)
  return name_;
}
inline ::std::string* FriendNameMap_FriendNickname::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FriendNameMap_FriendNickname::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.FriendNameMap.FriendNickname.name)
}

// required bytes friend_fingerprint = 2;
inline bool FriendNameMap_FriendNickname::has_friend_fingerprint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendNameMap_FriendNickname::set_has_friend_fingerprint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendNameMap_FriendNickname::clear_has_friend_fingerprint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendNameMap_FriendNickname::clear_friend_fingerprint() {
  if (friend_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_fingerprint_->clear();
  }
  clear_has_friend_fingerprint();
}
inline const ::std::string& FriendNameMap_FriendNickname::friend_fingerprint() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.FriendNickname.friend_fingerprint)
  return *friend_fingerprint_;
}
inline void FriendNameMap_FriendNickname::set_friend_fingerprint(const ::std::string& value) {
  set_has_friend_fingerprint();
  if (friend_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_fingerprint_ = new ::std::string;
  }
  friend_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.FriendNickname.friend_fingerprint)
}
inline void FriendNameMap_FriendNickname::set_friend_fingerprint(const char* value) {
  set_has_friend_fingerprint();
  if (friend_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_fingerprint_ = new ::std::string;
  }
  friend_fingerprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.FriendNameMap.FriendNickname.friend_fingerprint)
}
inline void FriendNameMap_FriendNickname::set_friend_fingerprint(const void* value, size_t size) {
  set_has_friend_fingerprint();
  if (friend_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_fingerprint_ = new ::std::string;
  }
  friend_fingerprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.FriendNameMap.FriendNickname.friend_fingerprint)
}
inline ::std::string* FriendNameMap_FriendNickname::mutable_friend_fingerprint() {
  set_has_friend_fingerprint();
  if (friend_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_fingerprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.FriendNickname.friend_fingerprint)
  return friend_fingerprint_;
}
inline ::std::string* FriendNameMap_FriendNickname::release_friend_fingerprint() {
  clear_has_friend_fingerprint();
  if (friend_fingerprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = friend_fingerprint_;
    friend_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FriendNameMap_FriendNickname::set_allocated_friend_fingerprint(::std::string* friend_fingerprint) {
  if (friend_fingerprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete friend_fingerprint_;
  }
  if (friend_fingerprint) {
    set_has_friend_fingerprint();
    friend_fingerprint_ = friend_fingerprint;
  } else {
    clear_has_friend_fingerprint();
    friend_fingerprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.FriendNameMap.FriendNickname.friend_fingerprint)
}

// required bytes friend_pubkey = 3;
inline bool FriendNameMap_FriendNickname::has_friend_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendNameMap_FriendNickname::set_has_friend_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendNameMap_FriendNickname::clear_has_friend_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendNameMap_FriendNickname::clear_friend_pubkey() {
  if (friend_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_pubkey_->clear();
  }
  clear_has_friend_pubkey();
}
inline const ::std::string& FriendNameMap_FriendNickname::friend_pubkey() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.FriendNickname.friend_pubkey)
  return *friend_pubkey_;
}
inline void FriendNameMap_FriendNickname::set_friend_pubkey(const ::std::string& value) {
  set_has_friend_pubkey();
  if (friend_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_pubkey_ = new ::std::string;
  }
  friend_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.FriendNickname.friend_pubkey)
}
inline void FriendNameMap_FriendNickname::set_friend_pubkey(const char* value) {
  set_has_friend_pubkey();
  if (friend_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_pubkey_ = new ::std::string;
  }
  friend_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.FriendNameMap.FriendNickname.friend_pubkey)
}
inline void FriendNameMap_FriendNickname::set_friend_pubkey(const void* value, size_t size) {
  set_has_friend_pubkey();
  if (friend_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_pubkey_ = new ::std::string;
  }
  friend_pubkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.FriendNameMap.FriendNickname.friend_pubkey)
}
inline ::std::string* FriendNameMap_FriendNickname::mutable_friend_pubkey() {
  set_has_friend_pubkey();
  if (friend_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_pubkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.FriendNickname.friend_pubkey)
  return friend_pubkey_;
}
inline ::std::string* FriendNameMap_FriendNickname::release_friend_pubkey() {
  clear_has_friend_pubkey();
  if (friend_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = friend_pubkey_;
    friend_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FriendNameMap_FriendNickname::set_allocated_friend_pubkey(::std::string* friend_pubkey) {
  if (friend_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete friend_pubkey_;
  }
  if (friend_pubkey) {
    set_has_friend_pubkey();
    friend_pubkey_ = friend_pubkey;
  } else {
    clear_has_friend_pubkey();
    friend_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.FriendNameMap.FriendNickname.friend_pubkey)
}

// required bytes friend_server_cert = 4;
inline bool FriendNameMap_FriendNickname::has_friend_server_cert() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendNameMap_FriendNickname::set_has_friend_server_cert() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendNameMap_FriendNickname::clear_has_friend_server_cert() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendNameMap_FriendNickname::clear_friend_server_cert() {
  if (friend_server_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_server_cert_->clear();
  }
  clear_has_friend_server_cert();
}
inline const ::std::string& FriendNameMap_FriendNickname::friend_server_cert() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.FriendNickname.friend_server_cert)
  return *friend_server_cert_;
}
inline void FriendNameMap_FriendNickname::set_friend_server_cert(const ::std::string& value) {
  set_has_friend_server_cert();
  if (friend_server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_server_cert_ = new ::std::string;
  }
  friend_server_cert_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.FriendNickname.friend_server_cert)
}
inline void FriendNameMap_FriendNickname::set_friend_server_cert(const char* value) {
  set_has_friend_server_cert();
  if (friend_server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_server_cert_ = new ::std::string;
  }
  friend_server_cert_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.FriendNameMap.FriendNickname.friend_server_cert)
}
inline void FriendNameMap_FriendNickname::set_friend_server_cert(const void* value, size_t size) {
  set_has_friend_server_cert();
  if (friend_server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_server_cert_ = new ::std::string;
  }
  friend_server_cert_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.FriendNameMap.FriendNickname.friend_server_cert)
}
inline ::std::string* FriendNameMap_FriendNickname::mutable_friend_server_cert() {
  set_has_friend_server_cert();
  if (friend_server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_server_cert_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.FriendNickname.friend_server_cert)
  return friend_server_cert_;
}
inline ::std::string* FriendNameMap_FriendNickname::release_friend_server_cert() {
  clear_has_friend_server_cert();
  if (friend_server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = friend_server_cert_;
    friend_server_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FriendNameMap_FriendNickname::set_allocated_friend_server_cert(::std::string* friend_server_cert) {
  if (friend_server_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete friend_server_cert_;
  }
  if (friend_server_cert) {
    set_has_friend_server_cert();
    friend_server_cert_ = friend_server_cert;
  } else {
    clear_has_friend_server_cert();
    friend_server_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.FriendNameMap.FriendNickname.friend_server_cert)
}

// required string server_address = 5;
inline bool FriendNameMap_FriendNickname::has_server_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendNameMap_FriendNickname::set_has_server_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendNameMap_FriendNickname::clear_has_server_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendNameMap_FriendNickname::clear_server_address() {
  if (server_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_address_->clear();
  }
  clear_has_server_address();
}
inline const ::std::string& FriendNameMap_FriendNickname::server_address() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.FriendNickname.server_address)
  return *server_address_;
}
inline void FriendNameMap_FriendNickname::set_server_address(const ::std::string& value) {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_address_ = new ::std::string;
  }
  server_address_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.FriendNickname.server_address)
}
inline void FriendNameMap_FriendNickname::set_server_address(const char* value) {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_address_ = new ::std::string;
  }
  server_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.FriendNameMap.FriendNickname.server_address)
}
inline void FriendNameMap_FriendNickname::set_server_address(const char* value, size_t size) {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_address_ = new ::std::string;
  }
  server_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.FriendNameMap.FriendNickname.server_address)
}
inline ::std::string* FriendNameMap_FriendNickname::mutable_server_address() {
  set_has_server_address();
  if (server_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.FriendNickname.server_address)
  return server_address_;
}
inline ::std::string* FriendNameMap_FriendNickname::release_server_address() {
  clear_has_server_address();
  if (server_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_address_;
    server_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FriendNameMap_FriendNickname::set_allocated_server_address(::std::string* server_address) {
  if (server_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_address_;
  }
  if (server_address) {
    set_has_server_address();
    server_address_ = server_address;
  } else {
    clear_has_server_address();
    server_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.FriendNameMap.FriendNickname.server_address)
}

// -------------------------------------------------------------------

// FriendNameMap

// repeated .pamrac.FriendNameMap.FriendNickname friends = 1;
inline int FriendNameMap::friends_size() const {
  return friends_.size();
}
inline void FriendNameMap::clear_friends() {
  friends_.Clear();
}
inline const ::pamrac::FriendNameMap_FriendNickname& FriendNameMap::friends(int index) const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.friends)
  return friends_.Get(index);
}
inline ::pamrac::FriendNameMap_FriendNickname* FriendNameMap::mutable_friends(int index) {
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.friends)
  return friends_.Mutable(index);
}
inline ::pamrac::FriendNameMap_FriendNickname* FriendNameMap::add_friends() {
  // @@protoc_insertion_point(field_add:pamrac.FriendNameMap.friends)
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pamrac::FriendNameMap_FriendNickname >&
FriendNameMap::friends() const {
  // @@protoc_insertion_point(field_list:pamrac.FriendNameMap.friends)
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::pamrac::FriendNameMap_FriendNickname >*
FriendNameMap::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_list:pamrac.FriendNameMap.friends)
  return &friends_;
}

// required int64 timestamp = 2;
inline bool FriendNameMap::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendNameMap::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendNameMap::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendNameMap::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 FriendNameMap::timestamp() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.timestamp)
  return timestamp_;
}
inline void FriendNameMap::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.timestamp)
}

// optional bytes signature = 3;
inline bool FriendNameMap::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendNameMap::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendNameMap::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendNameMap::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& FriendNameMap::signature() const {
  // @@protoc_insertion_point(field_get:pamrac.FriendNameMap.signature)
  return *signature_;
}
inline void FriendNameMap::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.FriendNameMap.signature)
}
inline void FriendNameMap::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.FriendNameMap.signature)
}
inline void FriendNameMap::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.FriendNameMap.signature)
}
inline ::std::string* FriendNameMap::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.FriendNameMap.signature)
  return signature_;
}
inline ::std::string* FriendNameMap::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FriendNameMap::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.FriendNameMap.signature)
}

// -------------------------------------------------------------------

// ConnectToNewStore

// required string passcode = 1;
inline bool ConnectToNewStore::has_passcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectToNewStore::set_has_passcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectToNewStore::clear_has_passcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectToNewStore::clear_passcode() {
  if (passcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passcode_->clear();
  }
  clear_has_passcode();
}
inline const ::std::string& ConnectToNewStore::passcode() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectToNewStore.passcode)
  return *passcode_;
}
inline void ConnectToNewStore::set_passcode(const ::std::string& value) {
  set_has_passcode();
  if (passcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passcode_ = new ::std::string;
  }
  passcode_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectToNewStore.passcode)
}
inline void ConnectToNewStore::set_passcode(const char* value) {
  set_has_passcode();
  if (passcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passcode_ = new ::std::string;
  }
  passcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectToNewStore.passcode)
}
inline void ConnectToNewStore::set_passcode(const char* value, size_t size) {
  set_has_passcode();
  if (passcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passcode_ = new ::std::string;
  }
  passcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectToNewStore.passcode)
}
inline ::std::string* ConnectToNewStore::mutable_passcode() {
  set_has_passcode();
  if (passcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectToNewStore.passcode)
  return passcode_;
}
inline ::std::string* ConnectToNewStore::release_passcode() {
  clear_has_passcode();
  if (passcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passcode_;
    passcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectToNewStore::set_allocated_passcode(::std::string* passcode) {
  if (passcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passcode_;
  }
  if (passcode) {
    set_has_passcode();
    passcode_ = passcode;
  } else {
    clear_has_passcode();
    passcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectToNewStore.passcode)
}

// required bytes public_key = 2;
inline bool ConnectToNewStore::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectToNewStore::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectToNewStore::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectToNewStore::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& ConnectToNewStore::public_key() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectToNewStore.public_key)
  return *public_key_;
}
inline void ConnectToNewStore::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectToNewStore.public_key)
}
inline void ConnectToNewStore::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectToNewStore.public_key)
}
inline void ConnectToNewStore::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectToNewStore.public_key)
}
inline ::std::string* ConnectToNewStore::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    public_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectToNewStore.public_key)
  return public_key_;
}
inline ::std::string* ConnectToNewStore::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectToNewStore::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectToNewStore.public_key)
}

// required bytes download_secret = 3;
inline bool ConnectToNewStore::has_download_secret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectToNewStore::set_has_download_secret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectToNewStore::clear_has_download_secret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectToNewStore::clear_download_secret() {
  if (download_secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    download_secret_->clear();
  }
  clear_has_download_secret();
}
inline const ::std::string& ConnectToNewStore::download_secret() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectToNewStore.download_secret)
  return *download_secret_;
}
inline void ConnectToNewStore::set_download_secret(const ::std::string& value) {
  set_has_download_secret();
  if (download_secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    download_secret_ = new ::std::string;
  }
  download_secret_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectToNewStore.download_secret)
}
inline void ConnectToNewStore::set_download_secret(const char* value) {
  set_has_download_secret();
  if (download_secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    download_secret_ = new ::std::string;
  }
  download_secret_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectToNewStore.download_secret)
}
inline void ConnectToNewStore::set_download_secret(const void* value, size_t size) {
  set_has_download_secret();
  if (download_secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    download_secret_ = new ::std::string;
  }
  download_secret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectToNewStore.download_secret)
}
inline ::std::string* ConnectToNewStore::mutable_download_secret() {
  set_has_download_secret();
  if (download_secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    download_secret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectToNewStore.download_secret)
  return download_secret_;
}
inline ::std::string* ConnectToNewStore::release_download_secret() {
  clear_has_download_secret();
  if (download_secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = download_secret_;
    download_secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectToNewStore::set_allocated_download_secret(::std::string* download_secret) {
  if (download_secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete download_secret_;
  }
  if (download_secret) {
    set_has_download_secret();
    download_secret_ = download_secret;
  } else {
    clear_has_download_secret();
    download_secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectToNewStore.download_secret)
}

// optional string nickname = 4;
inline bool ConnectToNewStore::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectToNewStore::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectToNewStore::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectToNewStore::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ConnectToNewStore::nickname() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectToNewStore.nickname)
  return *nickname_;
}
inline void ConnectToNewStore::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectToNewStore.nickname)
}
inline void ConnectToNewStore::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectToNewStore.nickname)
}
inline void ConnectToNewStore::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectToNewStore.nickname)
}
inline ::std::string* ConnectToNewStore::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectToNewStore.nickname)
  return nickname_;
}
inline ::std::string* ConnectToNewStore::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectToNewStore::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectToNewStore.nickname)
}

// optional .pamrac.MasterKeyPasswordedFile encrypted_master = 5;
inline bool ConnectToNewStore::has_encrypted_master() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectToNewStore::set_has_encrypted_master() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectToNewStore::clear_has_encrypted_master() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectToNewStore::clear_encrypted_master() {
  if (encrypted_master_ != NULL) encrypted_master_->::pamrac::MasterKeyPasswordedFile::Clear();
  clear_has_encrypted_master();
}
inline const ::pamrac::MasterKeyPasswordedFile& ConnectToNewStore::encrypted_master() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectToNewStore.encrypted_master)
  return encrypted_master_ != NULL ? *encrypted_master_ : *default_instance_->encrypted_master_;
}
inline ::pamrac::MasterKeyPasswordedFile* ConnectToNewStore::mutable_encrypted_master() {
  set_has_encrypted_master();
  if (encrypted_master_ == NULL) encrypted_master_ = new ::pamrac::MasterKeyPasswordedFile;
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectToNewStore.encrypted_master)
  return encrypted_master_;
}
inline ::pamrac::MasterKeyPasswordedFile* ConnectToNewStore::release_encrypted_master() {
  clear_has_encrypted_master();
  ::pamrac::MasterKeyPasswordedFile* temp = encrypted_master_;
  encrypted_master_ = NULL;
  return temp;
}
inline void ConnectToNewStore::set_allocated_encrypted_master(::pamrac::MasterKeyPasswordedFile* encrypted_master) {
  delete encrypted_master_;
  encrypted_master_ = encrypted_master;
  if (encrypted_master) {
    set_has_encrypted_master();
  } else {
    clear_has_encrypted_master();
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectToNewStore.encrypted_master)
}

// -------------------------------------------------------------------

// NewStoreConnectResult

// required bool success = 1;
inline bool NewStoreConnectResult::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewStoreConnectResult::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewStoreConnectResult::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewStoreConnectResult::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool NewStoreConnectResult::success() const {
  // @@protoc_insertion_point(field_get:pamrac.NewStoreConnectResult.success)
  return success_;
}
inline void NewStoreConnectResult::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:pamrac.NewStoreConnectResult.success)
}

// -------------------------------------------------------------------

// ConnectFriendServerResult

// required bytes user_public_key = 1;
inline bool ConnectFriendServerResult::has_user_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectFriendServerResult::set_has_user_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectFriendServerResult::clear_has_user_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectFriendServerResult::clear_user_public_key() {
  if (user_public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_public_key_->clear();
  }
  clear_has_user_public_key();
}
inline const ::std::string& ConnectFriendServerResult::user_public_key() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectFriendServerResult.user_public_key)
  return *user_public_key_;
}
inline void ConnectFriendServerResult::set_user_public_key(const ::std::string& value) {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_public_key_ = new ::std::string;
  }
  user_public_key_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectFriendServerResult.user_public_key)
}
inline void ConnectFriendServerResult::set_user_public_key(const char* value) {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_public_key_ = new ::std::string;
  }
  user_public_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectFriendServerResult.user_public_key)
}
inline void ConnectFriendServerResult::set_user_public_key(const void* value, size_t size) {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_public_key_ = new ::std::string;
  }
  user_public_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectFriendServerResult.user_public_key)
}
inline ::std::string* ConnectFriendServerResult::mutable_user_public_key() {
  set_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_public_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectFriendServerResult.user_public_key)
  return user_public_key_;
}
inline ::std::string* ConnectFriendServerResult::release_user_public_key() {
  clear_has_user_public_key();
  if (user_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_public_key_;
    user_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectFriendServerResult::set_allocated_user_public_key(::std::string* user_public_key) {
  if (user_public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_public_key_;
  }
  if (user_public_key) {
    set_has_user_public_key();
    user_public_key_ = user_public_key;
  } else {
    clear_has_user_public_key();
    user_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectFriendServerResult.user_public_key)
}

// required bytes server_cert = 2;
inline bool ConnectFriendServerResult::has_server_cert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectFriendServerResult::set_has_server_cert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectFriendServerResult::clear_has_server_cert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectFriendServerResult::clear_server_cert() {
  if (server_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_cert_->clear();
  }
  clear_has_server_cert();
}
inline const ::std::string& ConnectFriendServerResult::server_cert() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectFriendServerResult.server_cert)
  return *server_cert_;
}
inline void ConnectFriendServerResult::set_server_cert(const ::std::string& value) {
  set_has_server_cert();
  if (server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_cert_ = new ::std::string;
  }
  server_cert_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectFriendServerResult.server_cert)
}
inline void ConnectFriendServerResult::set_server_cert(const char* value) {
  set_has_server_cert();
  if (server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_cert_ = new ::std::string;
  }
  server_cert_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectFriendServerResult.server_cert)
}
inline void ConnectFriendServerResult::set_server_cert(const void* value, size_t size) {
  set_has_server_cert();
  if (server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_cert_ = new ::std::string;
  }
  server_cert_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectFriendServerResult.server_cert)
}
inline ::std::string* ConnectFriendServerResult::mutable_server_cert() {
  set_has_server_cert();
  if (server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_cert_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectFriendServerResult.server_cert)
  return server_cert_;
}
inline ::std::string* ConnectFriendServerResult::release_server_cert() {
  clear_has_server_cert();
  if (server_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_cert_;
    server_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectFriendServerResult::set_allocated_server_cert(::std::string* server_cert) {
  if (server_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_cert_;
  }
  if (server_cert) {
    set_has_server_cert();
    server_cert_ = server_cert;
  } else {
    clear_has_server_cert();
    server_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectFriendServerResult.server_cert)
}

// required bytes sig_of_cert = 3;
inline bool ConnectFriendServerResult::has_sig_of_cert() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectFriendServerResult::set_has_sig_of_cert() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectFriendServerResult::clear_has_sig_of_cert() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectFriendServerResult::clear_sig_of_cert() {
  if (sig_of_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_of_cert_->clear();
  }
  clear_has_sig_of_cert();
}
inline const ::std::string& ConnectFriendServerResult::sig_of_cert() const {
  // @@protoc_insertion_point(field_get:pamrac.ConnectFriendServerResult.sig_of_cert)
  return *sig_of_cert_;
}
inline void ConnectFriendServerResult::set_sig_of_cert(const ::std::string& value) {
  set_has_sig_of_cert();
  if (sig_of_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_of_cert_ = new ::std::string;
  }
  sig_of_cert_->assign(value);
  // @@protoc_insertion_point(field_set:pamrac.ConnectFriendServerResult.sig_of_cert)
}
inline void ConnectFriendServerResult::set_sig_of_cert(const char* value) {
  set_has_sig_of_cert();
  if (sig_of_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_of_cert_ = new ::std::string;
  }
  sig_of_cert_->assign(value);
  // @@protoc_insertion_point(field_set_char:pamrac.ConnectFriendServerResult.sig_of_cert)
}
inline void ConnectFriendServerResult::set_sig_of_cert(const void* value, size_t size) {
  set_has_sig_of_cert();
  if (sig_of_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_of_cert_ = new ::std::string;
  }
  sig_of_cert_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pamrac.ConnectFriendServerResult.sig_of_cert)
}
inline ::std::string* ConnectFriendServerResult::mutable_sig_of_cert() {
  set_has_sig_of_cert();
  if (sig_of_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_of_cert_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pamrac.ConnectFriendServerResult.sig_of_cert)
  return sig_of_cert_;
}
inline ::std::string* ConnectFriendServerResult::release_sig_of_cert() {
  clear_has_sig_of_cert();
  if (sig_of_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sig_of_cert_;
    sig_of_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectFriendServerResult::set_allocated_sig_of_cert(::std::string* sig_of_cert) {
  if (sig_of_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sig_of_cert_;
  }
  if (sig_of_cert) {
    set_has_sig_of_cert();
    sig_of_cert_ = sig_of_cert;
  } else {
    clear_has_sig_of_cert();
    sig_of_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pamrac.ConnectFriendServerResult.sig_of_cert)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pamrac

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pamrac::PAMRACMessage_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pamrac::PAMRACMessage_Type>() {
  return ::pamrac::PAMRACMessage_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pamrac_2eproto__INCLUDED
